This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-18T13:10:25.300Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
demos/
  python/
    sdk_wireless_camera_control/
      open_gopro/
        api/
          __init__.py
          api.py
          ble_commands.py
          builders.py
          http_commands.py
          params.py
          parsers.py
        ble/
          adapters/
            __init__.py
            bleak_wrapper.py
          __init__.py
          client.py
          controller.py
          services.py
        demos/
          gui/
            __init__.py
            livestream.py
            preview_stream.py
            util.py
            webcam.py
          __init__.py
          cohn.py
          connect_wifi.py
          log_battery.py
          photo.py
          video.py
        models/
          __init__.py
          bases.py
          general.py
          media_list.py
          response.py
        proto/
          __init__.py
          cohn_pb2.py
          cohn_pb2.pyi
          live_streaming_pb2.py
          live_streaming_pb2.pyi
          media_pb2.py
          media_pb2.pyi
          network_management_pb2.py
          network_management_pb2.pyi
          preset_status_pb2.py
          preset_status_pb2.pyi
          request_get_preset_status_pb2.py
          request_get_preset_status_pb2.pyi
          response_generic_pb2.py
          response_generic_pb2.pyi
          set_camera_control_status_pb2.py
          set_camera_control_status_pb2.pyi
          turbo_transfer_pb2.py
          turbo_transfer_pb2.pyi
        wifi/
          adapters/
            __init__.py
            wireless.py
          __init__.py
          client.py
          controller.py
          mdns_scanner.py
        __init__.py
        communicator_interface.py
        constants.py
        enum.py
        exceptions.py
        gopro_base.py
        gopro_wired.py
        gopro_wireless.py
        logger.py
        parser_interface.py
        types.py
        util.py

================================================================
Repository Files
================================================================

================
File: demos/python/sdk_wireless_camera_control/open_gopro/api/__init__.py
================
# __init__.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Thu Feb  3 00:30:25 UTC 2022

"""Top level API module definition"""

from . import params as Params
from .api import WiredApi, WirelessApi
from .ble_commands import BleCommands, BleSettings, BleStatuses
from .builders import (
    BleAsyncResponse,
    BleProtoCommand,
    BleReadCommand,
    BleSettingFacade,
    BleStatusFacade,
    BleWriteCommand,
    HttpSetting,
    RegisterUnregisterAll,
)
from .http_commands import HttpCommands, HttpSettings

# We need to ensure the API instantiated so that all parsers are set up.
WirelessApi(None)  # type: ignore

================
File: demos/python/sdk_wireless_camera_control/open_gopro/api/api.py
================
# api.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Tue Sep  7 21:35:52 UTC 2021

"""Implementation of Open GoPro API version 2.0"""

from __future__ import annotations

from typing import Final

from open_gopro.communicator_interface import GoProHttp, GoProWirelessInterface

from .ble_commands import BleAsyncResponses, BleCommands, BleSettings, BleStatuses
from .http_commands import HttpCommands, HttpSettings


class WirelessApi:
    """Implementation of Open GoPro API version 2.0 for Wireless interface (Wifi and BLE)

    Args:
        communicator (GoProWirelessInterface): used to communicate via BLE and Wifi
    """

    version: Final = "2.0"

    def __init__(self, communicator: GoProWirelessInterface) -> None:
        self._communicator = communicator
        self.ble_command = BleCommands(communicator)
        self.ble_setting = BleSettings(communicator)
        self.ble_status = BleStatuses(communicator)
        BleAsyncResponses.add_parsers()
        self.http_command = HttpCommands(communicator)
        self.http_setting = HttpSettings(communicator)


class WiredApi:
    """Implementation of Open GoPro API version 2.0 for Wired interface (USB)

    Args:
        communicator (GoProHttp): used to communicate via BLE and Wifi
    """

    version: Final = "2.0"

    def __init__(self, communicator: GoProHttp) -> None:
        self._communicator = communicator
        self.http_command = HttpCommands(communicator)
        self.http_setting = HttpSettings(communicator)

================
File: demos/python/sdk_wireless_camera_control/open_gopro/api/ble_commands.py
================
# ble_commands.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Tue Sep  7 21:35:52 UTC 2021

"""BLE API for Open GoPro"""

# mypy: disable-error-code=empty-body

from __future__ import annotations

import datetime
import logging
from pathlib import Path
from typing import Any, Final

from construct import (
    Flag,
    GreedyBytes,
    GreedyString,
    Hex,
    Int8ub,
    Int16ub,
    Int32ub,
    Int64ub,
    PaddedString,
    Padding,
    Struct,
    this,
)

from open_gopro import proto
from open_gopro.api.builders import BleAsyncResponse
from open_gopro.api.builders import BleSettingFacade as BleSetting
from open_gopro.api.builders import BleStatusFacade as BleStatus
from open_gopro.api.builders import (
    RegisterUnregisterAll,
    ble_proto_command,
    ble_read_command,
    ble_register_command,
    ble_write_command,
)
from open_gopro.api.parsers import ByteParserBuilders, JsonParsers
from open_gopro.communicator_interface import (
    BleMessage,
    BleMessages,
    GoProBle,
    MessageRules,
)
from open_gopro.constants import (
    ActionId,
    CmdId,
    FeatureId,
    GoProUUIDs,
    SettingId,
    StatusId,
)
from open_gopro.models import CameraInfo, TzDstDateTime
from open_gopro.models.response import GlobalParsers, GoProResp
from open_gopro.parser_interface import Parser
from open_gopro.types import CameraState, UpdateCb

from . import params as Params

logger = logging.getLogger(__name__)


class BleCommands(BleMessages[BleMessage]):
    """All of the BLE commands.

    To be used as a delegate for a GoProBle instance to build commands
    """

    ######################################################################################################
    #                          BLE WRITE COMMANDS
    ######################################################################################################

    @ble_write_command(
        uuid=GoProUUIDs.CQ_COMMAND,
        cmd=CmdId.SET_SHUTTER,
        param_builder=Int8ub,
        rules=MessageRules(
            fastpass_analyzer=lambda **kwargs: kwargs["shutter"] == Params.Toggle.DISABLE,
            wait_for_encoding_analyzer=lambda **kwargs: kwargs["shutter"] == Params.Toggle.ENABLE,
        ),
    )
    async def set_shutter(self, *, shutter: Params.Toggle) -> GoProResp[None]:
        """Set the Shutter to start / stop encoding

        Args:
            shutter (Params.Toggle): on or off

        Returns:
            GoProResp[None]: status of command
        """

    @ble_write_command(GoProUUIDs.CQ_COMMAND, CmdId.TAG_HILIGHT)
    async def tag_hilight(self) -> GoProResp[None]:
        """Tag a highlight during encoding

        Returns:
            GoProResp[None]: status of command
        """

    @ble_write_command(GoProUUIDs.CQ_COMMAND, CmdId.POWER_DOWN)
    async def power_down(self) -> GoProResp[None]:
        """Power Down the camera

        Returns:
            GoProResp[None]: status of command
        """

    @ble_write_command(GoProUUIDs.CQ_COMMAND, CmdId.SLEEP)
    async def sleep(self) -> GoProResp[None]:
        """Put the camera in standby

        Returns:
            GoProResp[None]: status of command
        """

    @ble_write_command(
        uuid=GoProUUIDs.CQ_COMMAND,
        cmd=CmdId.GET_HW_INFO,
        parser=Parser(
            byte_json_adapter=ByteParserBuilders.Construct(
                Struct(
                    Padding(1),
                    "model_number" / Int32ub,
                    "model_name_len" / Int8ub,
                    "model_name" / PaddedString(this.model_name_len, "utf-8"),
                    Padding(1),
                    "board_type" / Hex(Int32ub),
                    "firmware_version_len" / Int8ub,
                    "firmware_version" / PaddedString(this.firmware_version_len, "utf-8"),
                    "serial_number_len" / Int8ub,
                    "serial_number" / PaddedString(this.serial_number_len, "utf-8"),
                    "ap_ssid_len" / Int8ub,
                    "ap_ssid" / PaddedString(this.ap_ssid_len, "utf-8"),
                    "ap_mac_len" / Int8ub,
                    "ap_mac_addr" / PaddedString(this.ap_mac_len, "utf-8"),
                )
            ),
            json_parser=JsonParsers.PydanticAdapter(CameraInfo),
        ),
    )
    async def get_hardware_info(self) -> GoProResp[CameraInfo]:
        """Get the model number, board, type, firmware version, serial number, and AP info

        Returns:
            GoProResp[CameraInfo]: response as JSON
        """

    @ble_write_command(GoProUUIDs.CQ_COMMAND, CmdId.SET_WIFI, Int8ub)
    async def enable_wifi_ap(self, *, enable: bool) -> GoProResp[None]:
        """Enable / disable the Wi-Fi Access Point.

        Args:
            enable (bool): True to enable, False to disable

        Returns:
            GoProResp[None]: response as JSON
        """

    @ble_write_command(GoProUUIDs.CQ_COMMAND, CmdId.LOAD_PRESET_GROUP, Int16ub)
    async def load_preset_group(self, *, group: proto.EnumPresetGroup.ValueType) -> GoProResp[None]:
        """Load a Preset Group.

        Once complete, the most recently used preset in this group will be active.

        Args:
            group (proto.EnumPresetGroup.ValueType): preset group to load

        Returns:
            GoProResp[None]: response as JSON
        """

    @ble_write_command(GoProUUIDs.CQ_COMMAND, CmdId.LOAD_PRESET, Int32ub)
    async def load_preset(self, *, preset: int) -> GoProResp[None]:
        """Load a Preset

        The integer preset value can be found from the get_preset_status command

        Args:
            preset (int): preset ID to load

        Returns:
            GoProResp[None]: command status
        """

    @ble_write_command(GoProUUIDs.CQ_COMMAND, CmdId.SET_THIRD_PARTY_CLIENT_INFO)
    async def set_third_party_client_info(self) -> GoProResp[None]:
        """Flag as third party app

        Returns:
            GoProResp[None]: command status
        """

    @ble_write_command(
        uuid=GoProUUIDs.CQ_COMMAND,
        cmd=CmdId.GET_THIRD_PARTY_API_VERSION,
        parser=Parser(
            byte_json_adapter=ByteParserBuilders.Construct(
                Struct(Padding(1), "major" / Int8ub, Padding(1), "minor" / Int8ub)
            ),
            json_parser=JsonParsers.LambdaParser(lambda data: f"{data['major']}.{data['minor']}"),
        ),
    )
    async def get_open_gopro_api_version(self) -> GoProResp[str]:
        """Get Open GoPro API Version

        Returns:
            GoProResp[str]: response as JSON
        """

    @ble_write_command(
        GoProUUIDs.CQ_QUERY,
        CmdId.GET_CAMERA_STATUSES,
        parser=Parser(json_parser=JsonParsers.CameraStateParser()),
    )
    async def get_camera_statuses(self) -> GoProResp[CameraState]:
        """Get all of the camera's statuses

        Returns:
            GoProResp[CameraState]: response as JSON
        """

    @ble_write_command(
        GoProUUIDs.CQ_QUERY,
        CmdId.GET_CAMERA_SETTINGS,
        parser=Parser(json_parser=JsonParsers.CameraStateParser()),
    )
    async def get_camera_settings(self) -> GoProResp[CameraState]:
        """Get all of the camera's settings

        Returns:
            GoProResp[CameraState]: response as JSON
        """

    @ble_write_command(
        GoProUUIDs.CQ_QUERY,
        CmdId.GET_CAMERA_CAPABILITIES,
        parser=Parser(json_parser=JsonParsers.CameraStateParser()),
    )
    async def get_camera_capabilities(self) -> GoProResp[CameraState]:
        """Get the current capabilities of each camera setting

        Returns:
            GoProResp[CameraState]: response as JSON
        """

    @ble_write_command(GoProUUIDs.CQ_COMMAND, CmdId.SET_DATE_TIME, param_builder=ByteParserBuilders.DateTime())
    async def set_date_time(self, *, date_time: datetime.datetime) -> GoProResp[None]:
        """Set the camera's date and time (non timezone / DST version)

        Args:
            date_time (datetime.datetime): Date and time to set (Timezone will be ignored)

        Returns:
            GoProResp[None]: command status
        """

    @ble_write_command(
        GoProUUIDs.CQ_COMMAND,
        CmdId.GET_DATE_TIME,
        parser=Parser(
            byte_json_adapter=ByteParserBuilders.DateTime(),
            json_parser=JsonParsers.LambdaParser(lambda data: data["datetime"]),
        ),
    )
    async def get_date_time(self) -> GoProResp[datetime.datetime]:
        """Get the camera's date and time (non timezone / DST version)

        Returns:
            GoProResp[datetime.datetime]: response as JSON
        """

    @ble_write_command(GoProUUIDs.CQ_COMMAND, CmdId.SET_DATE_TIME_DST, param_builder=ByteParserBuilders.DateTime())
    async def set_date_time_tz_dst(
        self, *, date_time: datetime.datetime, tz_offset: int, is_dst: bool
    ) -> GoProResp[None]:
        """Set the camera's date and time with timezone and DST

        Args:
            date_time (datetime.datetime): date and time
            tz_offset (int): timezone as UTC offset
            is_dst (bool): is daylight savings time?

        Returns:
            GoProResp[None]: command status
        """

    @ble_write_command(
        GoProUUIDs.CQ_COMMAND,
        CmdId.GET_DATE_TIME_DST,
        parser=Parser(
            byte_json_adapter=ByteParserBuilders.DateTime(),
            json_parser=JsonParsers.PydanticAdapter(TzDstDateTime),
        ),
    )
    async def get_date_time_tz_dst(self) -> GoProResp[TzDstDateTime]:
        """Get the camera's date and time with timezone / DST

        Returns:
            GoProResp[TzDstDateTime]: response as JSON
        """

    ######################################################################################################
    #                          BLE DIRECT CHARACTERISTIC READ COMMANDS
    ######################################################################################################

    @ble_read_command(
        uuid=GoProUUIDs.WAP_SSID,
        parser=Parser(
            byte_json_adapter=ByteParserBuilders.Construct(Struct("ssid" / GreedyString("utf-8"))),
            json_parser=JsonParsers.LambdaParser(lambda data: data["ssid"]),
        ),
    )
    async def get_wifi_ssid(self) -> GoProResp[str]:
        """Get the Wifi SSID.

        Returns:
            GoProResp[str]: command status and SSID
        """

    @ble_read_command(
        uuid=GoProUUIDs.WAP_PASSWORD,
        parser=Parser(
            byte_json_adapter=ByteParserBuilders.Construct(Struct("password" / GreedyString("utf-8"))),
            json_parser=JsonParsers.LambdaParser(lambda data: data["password"]),
        ),
    )
    async def get_wifi_password(self) -> GoProResp[str]:
        """Get the Wifi password.

        Returns:
            GoProResp[str]: command status and password
        """

    ######################################################################################################
    #                          REGISTER / UNREGISTER ALL COMMANDS
    ######################################################################################################

    @ble_register_command(
        GoProUUIDs.CQ_QUERY,
        CmdId.REGISTER_ALL_STATUSES,
        update_set=StatusId,
        action=RegisterUnregisterAll.Action.REGISTER,
    )
    async def register_for_all_statuses(self, callback: UpdateCb) -> GoProResp[None]:
        """Register push notifications for all statuses

        Args:
            callback (UpdateCb): callback to be notified with

        Returns:
            GoProResp[None]: command status and current value of all statuses
        """

    @ble_register_command(
        GoProUUIDs.CQ_QUERY,
        CmdId.UNREGISTER_ALL_STATUSES,
        update_set=StatusId,
        action=RegisterUnregisterAll.Action.UNREGISTER,
    )
    async def unregister_for_all_statuses(self, callback: UpdateCb) -> GoProResp[None]:
        """Unregister push notifications for all statuses

        Args:
            callback (UpdateCb): callback to be notified with

        Returns:
            GoProResp[None]: command status
        """

    @ble_register_command(
        GoProUUIDs.CQ_QUERY,
        CmdId.REGISTER_ALL_SETTINGS,
        update_set=SettingId,
        action=RegisterUnregisterAll.Action.REGISTER,
    )
    async def register_for_all_settings(self, callback: UpdateCb) -> GoProResp[None]:
        """Register push notifications for all settings

        Args:
            callback (UpdateCb): callback to be notified with

        Returns:
            GoProResp[None]: command status and current value of all settings
        """

    @ble_register_command(
        GoProUUIDs.CQ_QUERY,
        CmdId.UNREGISTER_ALL_SETTINGS,
        update_set=SettingId,
        action=RegisterUnregisterAll.Action.UNREGISTER,
    )
    async def unregister_for_all_settings(self, callback: UpdateCb) -> GoProResp[None]:
        """Unregister push notifications for all settings

        Args:
            callback (UpdateCb): callback to be notified with

        Returns:
            GoProResp[None]: command status
        """

    @ble_register_command(
        GoProUUIDs.CQ_QUERY,
        CmdId.REGISTER_ALL_CAPABILITIES,
        update_set=SettingId,
        action=RegisterUnregisterAll.Action.REGISTER,
    )
    async def register_for_all_capabilities(self, callback: UpdateCb) -> GoProResp[None]:
        """Register push notifications for all capabilities

        Args:
            callback (UpdateCb): callback to be notified with

        Returns:
            GoProResp[None]: command status and current value of all capabilities
        """

    @ble_register_command(
        GoProUUIDs.CQ_QUERY,
        CmdId.UNREGISTER_ALL_CAPABILITIES,
        update_set=SettingId,
        action=RegisterUnregisterAll.Action.UNREGISTER,
    )
    async def unregister_for_all_capabilities(self, callback: UpdateCb) -> GoProResp[None]:
        """Unregister push notifications for all capabilities

        Args:
            callback (UpdateCb): callback to be notified with

        Returns:
            GoProResp[None]: command status
        """

    ######################################################################################################
    #                          PROTOBUF COMMANDS
    ######################################################################################################

    @ble_proto_command(
        uuid=GoProUUIDs.CQ_COMMAND,
        feature_id=FeatureId.COMMAND,
        action_id=ActionId.SET_CAMERA_CONTROL,
        response_action_id=ActionId.SET_CAMERA_CONTROL_RSP,
        request_proto=proto.RequestSetCameraControlStatus,
        response_proto=proto.ResponseGeneric,
    )
    async def set_camera_control(
        self, *, camera_control_status: proto.EnumCameraControlStatus.ValueType
    ) -> GoProResp[None]:
        """Tell the camera that the app (i.e. External Control) wishes to claim control of the camera.

        Args:
            camera_control_status (proto.EnumCameraControlStatus.ValueType): Desired camera control.

        Returns:
            GoProResp[None]: command status of request
        """

    @ble_proto_command(
        uuid=GoProUUIDs.CQ_COMMAND,
        feature_id=FeatureId.COMMAND,
        action_id=ActionId.SET_TURBO_MODE,
        response_action_id=ActionId.SET_TURBO_MODE_RSP,
        request_proto=proto.RequestSetTurboActive,
        response_proto=proto.ResponseGeneric,
    )
    async def set_turbo_mode(self, *, mode: Params.Toggle) -> GoProResp[None]:
        """Enable / disable turbo mode.

        Args:
            mode (Params.Toggle): True to enable, False to disable.

        Returns:
            GoProResp[None]: command status of request
        """
        return {"active": mode}  # type: ignore

    @ble_proto_command(
        uuid=GoProUUIDs.CQ_QUERY,
        feature_id=FeatureId.QUERY,
        action_id=ActionId.GET_PRESET_STATUS,
        response_action_id=ActionId.GET_PRESET_STATUS_RSP,
        request_proto=proto.RequestGetPresetStatus,
        response_proto=proto.NotifyPresetStatus,
        additional_matching_ids={ActionId.PRESET_MODIFIED_NOTIFICATION},
    )
    async def get_preset_status(
        self,
        *,
        register: list[proto.EnumRegisterPresetStatus.ValueType] | None = None,
        unregister: list[proto.EnumRegisterPresetStatus.ValueType] | None = None,
    ) -> GoProResp[proto.NotifyPresetStatus]:
        """Get information about what Preset Groups and Presets the camera supports in its current state

        Also optionally (un)register for preset / group preset modified notifications which  will be
        sent asynchronously as :py:attr:`open_gopro.constants.ActionId.PRESET_MODIFIED_NOTIFICATION`

        Args:
            register (list[proto.EnumRegisterPresetStatus.ValueType] | None): Types of preset modified
                updates to register for. Defaults to None.
            unregister (list[proto.EnumRegisterPresetStatus.ValueType] | None): Types of preset modified
                updates to unregister for. Defaults to None.

        Returns:
            GoProResp[proto.NotifyPresetStatus]: JSON data describing all currently available presets
        """
        return {  # type: ignore
            "register_preset_status": register or [],
            "unregister_preset_status": unregister or [],
        }

    @ble_proto_command(
        uuid=GoProUUIDs.CQ_COMMAND,
        feature_id=FeatureId.COMMAND,
        action_id=ActionId.REQUEST_PRESET_UPDATE_CUSTOM,
        response_action_id=ActionId.RESPONSE_PRESET_UPDATE_CUSTOM,
        request_proto=proto.RequestCustomPresetUpdate,
        response_proto=proto.ResponseGeneric,
    )
    async def custom_preset_update(
        self,
        icon_id: proto.EnumPresetIcon.ValueType | None = None,
        title: str | proto.EnumPresetTitle.ValueType | None = None,
    ) -> GoProResp[proto.ResponseGeneric]:
        """Update a custom preset title and / or icon

        Args:
            icon_id (proto.EnumPresetIcon.ValueType | None): Icon ID. Defaults to None.
            title (str | proto.EnumPresetTitle.ValueType | None): Custom Preset name or Factory Title ID. Defaults to None.

        Raises:
            ValueError: Did not set a parameter
            TypeError: Title was not proto.EnumPresetTitle.ValueType or string

        Returns:
            GoProResp[proto.ResponseGeneric]: status of preset update
        """
        if icon_id is None and title is None:
            raise ValueError("One of the parameters must be set")
        d: dict[Any, Any] = {}
        if icon_id:
            d["icon_id"] = icon_id
        if title is not None:
            if isinstance(title, str):
                d["title_id"] = proto.EnumPresetTitle.PRESET_TITLE_USER_DEFINED_CUSTOM_NAME
                d["custom_name"] = title
            elif isinstance(title, proto.EnumPresetTitle.ValueType):
                d["title_id"] = title
            else:
                raise TypeError("Title must be either int or str")
        return d  # type: ignore

    @ble_proto_command(
        uuid=GoProUUIDs.CQ_QUERY,
        feature_id=FeatureId.QUERY,
        action_id=ActionId.REQUEST_GET_LAST_MEDIA,
        response_action_id=ActionId.RESPONSE_GET_LAST_MEDIA,
        request_proto=proto.RequestGetLastCapturedMedia,
        response_proto=proto.ResponseLastCapturedMedia,
    )
    async def get_last_captured_media(self) -> GoProResp[proto.ResponseLastCapturedMedia]:
        """Get the last captured media file

        Returns:
            GoProResp[proto.ResponseLastCapturedMedia]: status of request and last captured file if successful
        """

    @ble_proto_command(
        uuid=GoProUUIDs.CM_NET_MGMT_COMM,
        feature_id=FeatureId.NETWORK_MANAGEMENT,
        action_id=ActionId.SCAN_WIFI_NETWORKS,
        response_action_id=ActionId.SCAN_WIFI_NETWORKS_RSP,
        request_proto=proto.RequestStartScan,
        response_proto=proto.ResponseStartScanning,
    )
    async def scan_wifi_networks(self) -> GoProResp[proto.ResponseStartScanning]:
        """Scan for Wifi networks

        Returns:
            GoProResp[proto.ResponseStartScanning]: Command status of request
        """

    @ble_proto_command(
        uuid=GoProUUIDs.CM_NET_MGMT_COMM,
        feature_id=FeatureId.NETWORK_MANAGEMENT,
        action_id=ActionId.GET_AP_ENTRIES,
        response_action_id=ActionId.GET_AP_ENTRIES_RSP,
        request_proto=proto.RequestGetApEntries,
        response_proto=proto.ResponseGetApEntries,
    )
    async def get_ap_entries(
        self, *, scan_id: int, start_index: int = 0, max_entries: int = 100
    ) -> GoProResp[proto.ResponseGetApEntries]:
        """Get the results of a scan for wifi networks

        Args:
            scan_id (int): ID corresponding to a set of scan results
            start_index (int): Used for paging. 0 <= start_index < NotifStartScanning.total_entries. Defaults to 0.
            max_entries (int): Used for paging. Value must be < NotifStartScanning.total_entries. Defaults to 100.

        Returns:
            GoProResp[proto.ResponseGetApEntries]: result of scan with entries for WiFi networks
        """
        return {"scan_id": scan_id, "start_index": start_index, "max_entries": max_entries}  # type: ignore

    @ble_proto_command(
        uuid=GoProUUIDs.CM_NET_MGMT_COMM,
        feature_id=FeatureId.NETWORK_MANAGEMENT,
        action_id=ActionId.REQUEST_WIFI_CONNECT,
        response_action_id=ActionId.REQUEST_WIFI_CONNECT_RSP,
        request_proto=proto.RequestConnect,
        response_proto=proto.ResponseConnect,
        additional_matching_ids={ActionId.REQUEST_WIFI_CONNECT_RSP},
    )
    async def request_wifi_connect(self, *, ssid: str) -> GoProResp[proto.ResponseConnect]:
        """Request the camera to connect to a WiFi network that is already provisioned.

        Updates will be sent as :py:attr:`open_gopro.constants.ActionId.NOTIF_PROVIS_STATE`

        Args:
            ssid (str): SSID to connect to

        Returns:
            GoProResp[proto.ResponseConnect]: Command status of request
        """

    @ble_proto_command(
        uuid=GoProUUIDs.CM_NET_MGMT_COMM,
        feature_id=FeatureId.NETWORK_MANAGEMENT,
        action_id=ActionId.REQUEST_WIFI_CONNECT_NEW,
        response_action_id=ActionId.REQUEST_WIFI_CONNECT_NEW_RSP,
        request_proto=proto.RequestConnectNew,
        response_proto=proto.ResponseConnectNew,
        additional_matching_ids={ActionId.REQUEST_WIFI_CONNECT_NEW_RSP},
    )
    async def request_wifi_connect_new(self, *, ssid: str, password: str) -> GoProResp[proto.ResponseConnectNew]:
        """Request the camera to connect to a WiFi network that is not already provisioned.

        Updates will be sent as :py:attr:`open_gopro.constants.ActionId.NOTIF_PROVIS_STATE`

        Args:
            ssid (str): SSID to connect to
            password (str): password of WiFi network

        Returns:
            GoProResp[proto.ResponseConnectNew]: Command status of request
        """

    @ble_proto_command(
        uuid=GoProUUIDs.CQ_COMMAND,
        feature_id=FeatureId.COMMAND,
        action_id=ActionId.SET_LIVESTREAM_MODE,
        response_action_id=ActionId.SET_LIVESTREAM_MODE_RSP,
        request_proto=proto.RequestSetLiveStreamMode,
        response_proto=proto.ResponseGeneric,
    )
    async def set_livestream_mode(
        self,
        *,
        url: str,
        minimum_bitrate: int,
        maximum_bitrate: int,
        starting_bitrate: int,
        window_size: proto.EnumWindowSize.ValueType | None = None,
        lens: proto.EnumLens.ValueType | None = None,
        certs: list[Path] | None = None,
    ) -> GoProResp[None]:
        """Initiate livestream to any site that accepts an RTMP URL and simultaneously encode to camera.

        Args:
            url (str): url used to stream. Set to empty string to invalidate/cancel stream
            minimum_bitrate (int): Desired minimum streaming bitrate (>= 800)
            maximum_bitrate (int): Desired maximum streaming bitrate (<= 8000)
            starting_bitrate (int): Initial streaming bitrate (honored if 800 <= value <= 8000)
            window_size (proto.EnumWindowSize.ValueType | None): Streaming video resolution. Defaults to None (use camera default).
            lens (proto.EnumLens.ValueType | None): Streaming Field of View. Defaults to None (use camera default).
            certs (list[Path] | None): list of certificates to use. Defaults to None.

        Returns:
            GoProResp[None]: command status of request
        """
        d = {
            "url": url,
            "encode": True,
            "minimum_bitrate": minimum_bitrate,
            "maximum_bitrate": maximum_bitrate,
            "starting_bitrate": starting_bitrate,
        }
        if certs:
            cert_buf = bytearray()
            for cert in certs:
                with open(cert, "rb") as fp:
                    cert_buf += bytearray(fp.read()) + "\n".encode()

            cert_buf.pop()
            d["cert"] = bytes(cert_buf)
        if lens:
            d["lens"] = lens
        if window_size:
            d["window_size"] = window_size
        return d  # type: ignore

    @ble_proto_command(
        uuid=GoProUUIDs.CQ_QUERY,
        feature_id=FeatureId.QUERY,
        action_id=ActionId.GET_LIVESTREAM_STATUS,
        response_action_id=ActionId.LIVESTREAM_STATUS_RSP,
        request_proto=proto.RequestGetLiveStreamStatus,
        response_proto=proto.NotifyLiveStreamStatus,
        additional_matching_ids={ActionId.LIVESTREAM_STATUS_NOTIF},
    )
    async def register_livestream_status(
        self,
        *,
        register: list[proto.EnumRegisterLiveStreamStatus.ValueType] | None = None,
        unregister: list[proto.EnumRegisterLiveStreamStatus.ValueType] | None = None,
    ) -> GoProResp[proto.NotifyLiveStreamStatus]:
        """Register / unregister to receive asynchronous livestream statuses

        Args:
            register (list[proto.EnumRegisterLiveStreamStatus.ValueType] | None): Statuses to register
                for. Defaults to None (don't register for any).
            unregister (list[proto.EnumRegisterLiveStreamStatus.ValueType] | None): Statuses to
                unregister for. Defaults to None (don't unregister for any).

        Returns:
            GoProResp[proto.NotifyLiveStreamStatus]: current livestream status
        """
        return {"register_live_stream_status": register or [], "unregister_live_stream_status": unregister or []}  # type: ignore

    @ble_proto_command(
        uuid=GoProUUIDs.CQ_COMMAND,
        feature_id=FeatureId.COMMAND,
        action_id=ActionId.RELEASE_NETWORK,
        response_action_id=ActionId.RELEASE_NETWORK_RSP,
        request_proto=proto.RequestReleaseNetwork,
        response_proto=proto.ResponseGeneric,
    )
    async def release_network(self) -> GoProResp[None]:
        """Disconnect the camera Wifi network in STA mode so that it returns to AP mode.

        Returns:
            GoProResp[None]: status of release request
        """

    @ble_proto_command(
        uuid=GoProUUIDs.CQ_QUERY,
        feature_id=FeatureId.QUERY,
        action_id=ActionId.REQUEST_GET_COHN_STATUS,
        response_action_id=ActionId.RESPONSE_GET_COHN_STATUS,
        request_proto=proto.RequestGetCOHNStatus,
        response_proto=proto.NotifyCOHNStatus,
    )
    async def cohn_get_status(self, *, register: bool) -> GoProResp[proto.NotifyCOHNStatus]:
        """Get (and optionally register for) the current COHN status

        Args:
            register (bool): whether or not to register

        Returns:
            GoProResp[proto.NotifyCOHNStatus]: current COHN status
        """
        return {"register_cohn_status": int(register)}  # type: ignore

    @ble_proto_command(
        uuid=GoProUUIDs.CQ_COMMAND,
        feature_id=FeatureId.COMMAND,
        action_id=ActionId.REQUEST_CREATE_COHN_CERT,
        response_action_id=ActionId.RESPONSE_CREATE_COHN_CERT,
        request_proto=proto.RequestCreateCOHNCert,
        response_proto=proto.ResponseGeneric,
    )
    async def cohn_create_certificate(self, *, override: bool = False) -> GoProResp[None]:
        """Create an SSL certificate on the camera to use for COHN

        Args:
            override (bool): Should the current cert be overwritten?. Defaults to True.

        Returns:
            GoProResp[None]: certificate creation status
        """
        return {"override": int(override)}  # type: ignore

    @ble_proto_command(
        uuid=GoProUUIDs.CQ_COMMAND,
        feature_id=FeatureId.COMMAND,
        action_id=ActionId.REQUEST_CLEAR_COHN_CERT,
        response_action_id=ActionId.RESPONSE_CLEAR_COHN_CERT,
        request_proto=proto.RequestClearCOHNCert,
        response_proto=proto.ResponseGeneric,
    )
    async def cohn_clear_certificate(self) -> GoProResp[None]:
        """Clear the current SSL certificate on the camera that is used for COHN

        Returns:
            GoProResp[None]: was the clear successful?
        """

    @ble_proto_command(
        uuid=GoProUUIDs.CQ_QUERY,
        feature_id=FeatureId.QUERY,
        action_id=ActionId.REQUEST_GET_COHN_CERT,
        response_action_id=ActionId.RESPONSE_GET_COHN_CERT,
        request_proto=proto.RequestCOHNCert,
        response_proto=proto.ResponseCOHNCert,
    )
    async def cohn_get_certificate(self) -> GoProResp[proto.ResponseCOHNCert]:
        """Get the current SSL certificate that the camera is using for COHN.

        Returns:
            GoProResp[proto.ResponseCOHNCert]: the certificate
        """

    @ble_proto_command(
        uuid=GoProUUIDs.CQ_COMMAND,
        feature_id=FeatureId.COMMAND,
        action_id=ActionId.REQUEST_COHN_SETTING,
        response_action_id=ActionId.RESPONSE_COHN_SETTING,
        request_proto=proto.RequestSetCOHNSetting,
        response_proto=proto.ResponseGeneric,
    )
    async def cohn_set_setting(self, *, mode: Params.Toggle) -> GoProResp[None]:
        """Set a COHN specific setting.

        Args:
            mode (Params.Toggle): should camera auto connect to home network?

        Returns:
            GoProResp[None]: status of set
        """
        return {"cohn_active": mode}  # type: ignore


class BleSettings(BleMessages[BleSetting.BleSettingMessageBase]):
    # pylint: disable=missing-class-docstring, unused-argument
    """The collection of all BLE Settings.

    To be used by a GoProBle delegate to build setting messages.

    Args:
        communicator (GoProBle): Adapter to read / write settings
    """

    def __init__(self, communicator: GoProBle):
        self.resolution: BleSetting[Params.Resolution] = BleSetting[Params.Resolution](
            communicator, SettingId.RESOLUTION, Params.Resolution
        )
        """Resolution."""

        self.fps: BleSetting[Params.FPS] = BleSetting[Params.FPS](communicator, SettingId.FPS, Params.FPS)
        """Frames per second."""

        self.auto_off: BleSetting[Params.AutoOff] = BleSetting[Params.AutoOff](
            communicator, SettingId.AUTO_OFF, Params.AutoOff
        )
        """Set the auto off time."""

        self.video_field_of_view: BleSetting[Params.VideoFOV] = BleSetting[Params.VideoFOV](
            communicator, SettingId.VIDEO_FOV, Params.VideoFOV
        )
        """Video FOV."""

        self.photo_field_of_view: BleSetting[Params.PhotoFOV] = BleSetting[Params.PhotoFOV](
            communicator, SettingId.PHOTO_FOV, Params.PhotoFOV
        )
        """Photo FOV."""

        self.multi_shot_field_of_view: BleSetting[Params.MultishotFOV] = BleSetting[Params.MultishotFOV](
            communicator, SettingId.MULTI_SHOT_FOV, Params.MultishotFOV
        )
        """Multi-shot FOV."""

        self.led: BleSetting[Params.LED] = BleSetting[Params.LED](communicator, SettingId.LED, Params.LED)
        """Set the LED options (or also send the BLE keep alive signal)."""

        self.max_lens_mode: BleSetting[Params.MaxLensMode] = BleSetting[Params.MaxLensMode](
            communicator, SettingId.MAX_LENS_MOD, Params.MaxLensMode
        )
        """Enable / disable max lens mod."""

        self.hypersmooth: BleSetting[Params.HypersmoothMode] = BleSetting[Params.HypersmoothMode](
            communicator, SettingId.HYPERSMOOTH, Params.HypersmoothMode
        )
        """Set / disable hypersmooth."""

        self.video_performance_mode: BleSetting[Params.PerformanceMode] = BleSetting[Params.PerformanceMode](
            communicator,
            SettingId.VIDEO_PERFORMANCE_MODE,
            Params.PerformanceMode,
        )
        """Video Performance Mode."""

        self.media_format: BleSetting[Params.MediaFormat] = BleSetting[Params.MediaFormat](
            communicator, SettingId.MEDIA_FORMAT, Params.MediaFormat
        )
        """Set the media format."""

        self.anti_flicker: BleSetting[Params.AntiFlicker] = BleSetting[Params.AntiFlicker](
            communicator,
            SettingId.ANTI_FLICKER,
            Params.AntiFlicker,
        )
        """Anti Flicker frequency."""

        self.camera_ux_mode: BleSetting[Params.CameraUxMode] = BleSetting[Params.CameraUxMode](
            communicator,
            SettingId.CAMERA_UX_MODE,
            Params.CameraUxMode,
        )
        """Camera controls configuration."""

        self.video_easy_mode: BleSetting[int] = BleSetting[int](
            communicator,
            SettingId.VIDEO_EASY_MODE,
            Int8ub,
        )
        """Video easy mode speed. It is not feasible to maintain this setting without code generation so just read as int."""

        self.photo_easy_mode: BleSetting[Params.PhotoEasyMode] = BleSetting[Params.PhotoEasyMode](
            communicator,
            SettingId.PHOTO_EASY_MODE,
            Params.PhotoEasyMode,
        )
        """Night Photo easy mode."""

        self.wifi_band: BleSetting[Params.WifiBand] = BleSetting[Params.WifiBand](
            communicator,
            SettingId.WIFI_BAND,
            Params.WifiBand,
        )
        """Current WiFi band being used."""

        self.star_trail_length: BleSetting[Params.StarTrailLength] = BleSetting[Params.StarTrailLength](
            communicator,
            SettingId.STAR_TRAIL_LENGTH,
            Params.StarTrailLength,
        )
        """Multi shot star trail length."""

        self.system_video_mode: BleSetting[Params.SystemVideoMode] = BleSetting[Params.SystemVideoMode](
            communicator,
            SettingId.SYSTEM_VIDEO_MODE,
            Params.SystemVideoMode,
        )
        """System video mode."""

        self.video_horizon_leveling: BleSetting[Params.HorizonLeveling] = BleSetting[Params.HorizonLeveling](
            communicator,
            SettingId.VIDEO_HORIZON_LEVELING,
            Params.HorizonLeveling,
        )
        """Lock / unlock horizon leveling for video."""

        self.photo_horizon_leveling: BleSetting[Params.HorizonLeveling] = BleSetting[Params.HorizonLeveling](
            communicator,
            SettingId.PHOTO_HORIZON_LEVELING,
            Params.HorizonLeveling,
        )
        """Lock / unlock horizon leveling for photo."""

        self.bit_rate: BleSetting[Params.BitRate] = BleSetting[Params.BitRate](
            communicator,
            SettingId.BIT_RATE,
            Params.BitRate,
        )
        """System Video Bit Rate."""

        self.bit_depth: BleSetting[Params.BitDepth] = BleSetting[Params.BitDepth](
            communicator,
            SettingId.BIT_DEPTH,
            Params.BitDepth,
        )
        """System Video Bit depth."""

        self.video_profile: BleSetting[Params.VideoProfile] = BleSetting[Params.VideoProfile](
            communicator,
            SettingId.VIDEO_PROFILE,
            Params.VideoProfile,
        )
        """Video Profile (hdr, etc.)"""

        self.video_aspect_ratio: BleSetting[Params.VideoAspectRatio] = BleSetting[Params.VideoAspectRatio](
            communicator,
            SettingId.VIDEO_ASPECT_RATIO,
            Params.VideoAspectRatio,
        )
        """Video aspect ratio"""

        self.video_easy_aspect_ratio: BleSetting[Params.EasyAspectRatio] = BleSetting[Params.EasyAspectRatio](
            communicator,
            SettingId.VIDEO_EASY_ASPECT_RATIO,
            Params.EasyAspectRatio,
        )
        """Video easy aspect ratio"""

        self.multi_shot_easy_aspect_ratio: BleSetting[Params.EasyAspectRatio] = BleSetting[Params.EasyAspectRatio](
            communicator,
            SettingId.MULTI_SHOT_EASY_ASPECT_RATIO,
            Params.EasyAspectRatio,
        )
        """Multi shot easy aspect ratio"""

        self.multi_shot_nlv_aspect_ratio: BleSetting[Params.EasyAspectRatio] = BleSetting[Params.EasyAspectRatio](
            communicator,
            SettingId.MULTI_SHOT_NLV_ASPECT_RATIO,
            Params.EasyAspectRatio,
        )
        """Multi shot NLV aspect ratio"""

        self.video_mode: BleSetting[Params.VideoMode] = BleSetting[Params.VideoMode](
            communicator,
            SettingId.VIDEO_MODE,
            Params.VideoMode,
        )
        """Video Mode (i.e. quality)"""

        self.timelapse_mode: BleSetting[Params.TimelapseMode] = BleSetting[Params.TimelapseMode](
            communicator,
            SettingId.TIMELAPSE_MODE,
            Params.TimelapseMode,
        )
        """Timelapse Mode"""

        self.maxlens_mod_type: BleSetting[Params.MaxLensModType] = BleSetting[Params.MaxLensModType](
            communicator,
            SettingId.ADDON_MAX_LENS_MOD,
            Params.MaxLensModType,
        )
        """Max lens mod? If so, what type?"""

        self.maxlens_status: BleSetting[Params.Toggle] = BleSetting[Params.Toggle](
            communicator,
            SettingId.ADDON_MAX_LENS_MOD_ENABLE,
            Params.Toggle,
        )
        """Enable / disable max lens mod"""

        self.photo_mode: BleSetting[Params.PhotoMode] = BleSetting[Params.PhotoMode](
            communicator,
            SettingId.PHOTO_MODE,
            Params.PhotoMode,
        )
        """Photo Mode"""

        self.framing: BleSetting[Params.Framing] = BleSetting[Params.Framing](
            communicator,
            SettingId.FRAMING,
            Params.Framing,
        )
        """Video Framing Mode"""

        self.hindsight: BleSetting[Params.Hindsight] = BleSetting[Params.Hindsight](
            communicator,
            SettingId.HINDSIGHT,
            Params.Hindsight,
        )
        """Hindsight time / disable"""

        self.photo_interval: BleSetting[Params.PhotoInterval] = BleSetting[Params.PhotoInterval](
            communicator,
            SettingId.PHOTO_INTERVAL,
            Params.PhotoInterval,
        )
        """Interval between photo captures"""

        self.photo_duration: BleSetting[Params.PhotoDuration] = BleSetting[Params.PhotoDuration](
            communicator,
            SettingId.PHOTO_INTERVAL_DURATION,
            Params.PhotoDuration,
        )
        """Interval between photo captures"""

        self.photo_output: BleSetting[Params.PhotoOutput] = BleSetting[Params.PhotoOutput](
            communicator,
            SettingId.PHOTO_OUTPUT,
            Params.PhotoOutput,
        )
        """File type of photo output"""

        self.video_duration: BleSetting[Params.VideoDuration] = BleSetting[Params.VideoDuration](
            communicator, SettingId.VIDEO_DURATION, Params.VideoDuration
        )
        """If set, a video will automatically be stopped after recording for this long."""

        self.regional_format: BleSetting[Params.RegionalFormat] = BleSetting[Params.RegionalFormat](
            communicator, SettingId.REGIONAL_FORMAT, Params.RegionalFormat
        )

        self.quality_control: BleSetting[Params.QualityControl] = BleSetting[Params.QualityControl](
            communicator, SettingId.QUALITY_CONTROL, Params.QualityControl
        )

        self.camera_volume: BleSetting[Params.Volume] = BleSetting[Params.Volume](
            communicator, SettingId.CAMERA_VOLUME, Params.Volume
        )

        self.lens_attachment: BleSetting[Params.LensAttachment] = BleSetting[Params.LensAttachment](
            communicator, SettingId.LENS_ATTACHMENT, Params.LensAttachment
        )

        self.setup_screensaver: BleSetting[Params.ScreenSaverTimeout] = BleSetting[Params.ScreenSaverTimeout](
            communicator, SettingId.SETUP_SCREEN_SAVER, Params.ScreenSaverTimeout
        )

        self.setup_language: BleSetting[Params.SetupLanguage] = BleSetting[Params.SetupLanguage](
            communicator, SettingId.SETUP_LANGUAGE, Params.SetupLanguage
        )

        self.auto_power_off: BleSetting[Params.AutoPowerOff] = BleSetting[Params.AutoPowerOff](
            communicator, SettingId.AUTO_POWER_OFF, Params.AutoPowerOff
        )

        self.photo_mode_v2: BleSetting[Params.PhotoModeV2] = BleSetting[Params.PhotoModeV2](
            communicator, SettingId.PHOTO_MODE_V2, Params.PhotoModeV2
        )

        self.video_digital_lens_v2: BleSetting[Params.VideoLensV2] = BleSetting[Params.VideoLensV2](
            communicator, SettingId.VIDEO_DIGITAL_LENSES_V2, Params.VideoLensV2
        )

        self.photo_digital_lens_v2: BleSetting[Params.PhotoLensV2] = BleSetting[Params.PhotoLensV2](
            communicator, SettingId.PHOTO_DIGITAL_LENSES_V2, Params.PhotoLensV2
        )

        self.timelapse_digital_lens_v2: BleSetting[Params.TimelapseLensV2] = BleSetting[Params.TimelapseLensV2](
            communicator, SettingId.TIMELAPSE_DIGITAL_LENSES_V2, Params.TimelapseLensV2
        )

        self.video_framing: BleSetting[Params.VideoFraming] = BleSetting[Params.VideoFraming](
            communicator, SettingId.VIDEO_FRAMING, Params.VideoFraming
        )

        self.multi_shot_framing: BleSetting[Params.MultishotFraming] = BleSetting[Params.MultishotFraming](
            communicator, SettingId.MULTI_SHOT_FRAMING, Params.MultishotFraming
        )

        self.frame_rate: BleSetting[Params.FrameRate] = BleSetting[Params.FrameRate](
            communicator, SettingId.FRAME_RATE, Params.FrameRate
        )

        super().__init__(communicator)


class BleAsyncResponses:
    """These are responses whose ID's are not associated with any messages"""

    generic_parser: Final = Parser[bytes](
        byte_json_adapter=ByteParserBuilders.Construct(Struct("unparsed" / GreedyBytes))
    )

    responses: list[BleAsyncResponse] = [
        BleAsyncResponse(
            FeatureId.NETWORK_MANAGEMENT,
            ActionId.NOTIF_PROVIS_STATE,
            Parser(byte_json_adapter=ByteParserBuilders.Protobuf(proto.NotifProvisioningState)),
        ),
        BleAsyncResponse(
            FeatureId.NETWORK_MANAGEMENT,
            ActionId.NOTIF_START_SCAN,
            Parser(byte_json_adapter=ByteParserBuilders.Protobuf(proto.NotifStartScanning)),
        ),
        BleAsyncResponse(
            FeatureId.QUERY,
            ActionId.INTERNAL_FF,
            generic_parser,
        ),
    ]

    @classmethod
    def add_parsers(cls) -> None:
        """Add all of the defined asynchronous responses to the global parser map"""
        for response in cls.responses:
            GlobalParsers.add(response.action_id, response.parser)
            GlobalParsers.add_feature_action_id_mapping(response.feature_id, response.action_id)


class BleStatuses(BleMessages[BleStatus.BleStatusMessageBase]):
    """All of the BLE Statuses.

    To be used by a GoProBle delegate to build status messages.

    Args:
        communicator (GoProBle): Adapter to read / write settings
    """

    def __init__(self, communicator: GoProBle) -> None:
        self.batt_present: BleStatus[bool] = BleStatus(communicator, StatusId.BATT_PRESENT, Flag)
        """Is the system's internal battery present?"""

        self.batt_level: BleStatus[int] = BleStatus(communicator, StatusId.BATT_LEVEL, Int8ub)
        """Rough approximation of internal battery level in bars."""

        self.deprecated_3: BleStatus[Any] = BleStatus(
            communicator, StatusId.DEPRECATED_3, ByteParserBuilders.DeprecatedMarker()
        )
        """This status is deprecated."""

        self.deprecated_4: BleStatus[Any] = BleStatus(
            communicator, StatusId.DEPRECATED_4, ByteParserBuilders.DeprecatedMarker()
        )
        """This status is deprecated."""

        self.system_hot: BleStatus[bool] = BleStatus(communicator, StatusId.SYSTEM_HOT, Flag)
        """Is the system currently overheating?"""

        self.system_busy: BleStatus[bool] = BleStatus(communicator, StatusId.SYSTEM_BUSY, Flag)
        """Is the camera busy?"""

        self.quick_capture: BleStatus[bool] = BleStatus(communicator, StatusId.QUICK_CAPTURE, Flag)
        """Is quick capture feature enabled?"""

        self.encoding_active: BleStatus[bool] = BleStatus(communicator, StatusId.ENCODING, Flag)
        """Is the camera currently encoding (i.e. capturing photo / video)?"""

        self.lcd_lock_active: BleStatus[bool] = BleStatus(communicator, StatusId.LCD_LOCK_ACTIVE, Flag)
        """Is the LCD lock currently active?"""

        self.video_progress: BleStatus[int] = BleStatus(communicator, StatusId.VIDEO_PROGRESS, Int32ub)
        """When encoding video, this is the duration (seconds) of the video so far; 0 otherwise."""

        self.wireless_enabled: BleStatus[bool] = BleStatus(communicator, StatusId.WIRELESS_ENABLED, Flag)
        """Are Wireless Connections enabled?"""

        self.pair_state: BleStatus[Params.PairState] = BleStatus(communicator, StatusId.PAIR_STATE, Params.PairState)
        """What is the pair state?"""

        self.pair_type: BleStatus[Params.PairType] = BleStatus(communicator, StatusId.PAIR_TYPE, Params.PairType)
        """The last type of pairing that the camera was engaged in."""

        self.pair_time: BleStatus[int] = BleStatus(communicator, StatusId.PAIR_TIME, Int32ub)
        """	Time (milliseconds) since boot of last successful pairing complete action."""

        self.wap_scan_state: BleStatus[Params.PairType] = BleStatus(
            communicator, StatusId.WAP_SCAN_STATE, Params.WAPState
        )
        """State of current scan for Wifi Access Points. Appears to only change for CAH-related scans."""

        # TODO this is returning different sized data in BLE vs WiFi
        # self.wap_scan_time:[int] BleStatus = BleStatus(communicator, StatusId.WAP_SCAN_TIME, Int8ub)
        # """The time, in milliseconds since boot that the Wifi Access Point scan completed."""

        self.wap_prov_stat: BleStatus[Params.PairType] = BleStatus(
            communicator, StatusId.WAP_PROV_STAT, Params.WAPState
        )
        """Wifi AP provisioning state."""

        self.remote_ctrl_ver: BleStatus[int] = BleStatus(communicator, StatusId.REMOTE_CTRL_VER, Int8ub)
        """What is the remote control version?"""

        self.remote_ctrl_conn: BleStatus[bool] = BleStatus(communicator, StatusId.REMOTE_CTRL_CONN, Flag)
        """Is the remote control connected?"""

        self.pair_state2: BleStatus[int] = BleStatus(communicator, StatusId.PAIR_STATE2, Int8ub)
        """Wireless Pairing State."""

        self.wlan_ssid: BleStatus[str] = BleStatus(communicator, StatusId.WLAN_SSID, GreedyString(encoding="utf-8"))
        """Provisioned WIFI AP SSID. On BLE connection, value is big-endian byte-encoded int."""

        self.ap_ssid: BleStatus[str] = BleStatus(communicator, StatusId.AP_SSID, GreedyString(encoding="utf-8"))
        """Camera's WIFI SSID. On BLE connection, value is big-endian byte-encoded int."""

        self.app_count: BleStatus[int] = BleStatus(communicator, StatusId.APP_COUNT, Int8ub)
        """The number of wireless devices connected to the camera."""

        self.preview_enabled: BleStatus[bool] = BleStatus(communicator, StatusId.PREVIEW_ENABLED, Flag)
        """Is preview stream enabled?"""

        self.sd_status: BleStatus[Params.SDStatus] = BleStatus(communicator, StatusId.SD_STATUS, Params.SDStatus)
        """Primary Storage Status."""

        self.photos_rem: BleStatus[int] = BleStatus(communicator, StatusId.PHOTOS_REM, Int32ub)
        """How many photos can be taken before sdcard is full?"""

        self.video_rem: BleStatus[int] = BleStatus(communicator, StatusId.VIDEO_REM, Int32ub)
        """How many minutes of video can be captured with current settings before sdcard is full?"""

        self.num_group_photo: BleStatus[int] = BleStatus(communicator, StatusId.NUM_GROUP_PHOTO, Int32ub)
        """How many group photos can be taken with current settings before sdcard is full?"""

        self.num_group_video: BleStatus[int] = BleStatus(communicator, StatusId.NUM_GROUP_VIDEO, Int32ub)
        """Total number of group videos on sdcard."""

        self.num_total_photo: BleStatus[int] = BleStatus(communicator, StatusId.NUM_TOTAL_PHOTO, Int32ub)
        """Total number of photos on sdcard."""

        self.num_total_video: BleStatus[int] = BleStatus(communicator, StatusId.NUM_TOTAL_VIDEO, Int32ub)
        """Total number of videos on sdcard."""

        self.deprecated_40: BleStatus[Any] = BleStatus(
            communicator, StatusId.DEPRECATED_40, ByteParserBuilders.DeprecatedMarker()
        )
        """This status is deprecated."""

        self.ota_stat: BleStatus[Params.OTAStatus] = BleStatus(communicator, StatusId.OTA_STAT, Params.OTAStatus)
        """The current status of Over The Air (OTA) update."""

        self.download_cancel_pend: BleStatus[bool] = BleStatus(communicator, StatusId.DOWNLOAD_CANCEL_PEND, Flag)
        """Is download firmware update cancel request pending?"""

        self.mode_group: BleStatus[int] = BleStatus(communicator, StatusId.MODE_GROUP, Int8ub)
        """Current mode group (deprecated in HERO8)."""

        self.locate_active: BleStatus[bool] = BleStatus(communicator, StatusId.LOCATE_ACTIVE, Flag)
        """Is locate camera feature active?"""

        self.multi_count_down: BleStatus[int] = BleStatus(communicator, StatusId.MULTI_COUNT_DOWN, Int32ub)
        """The current timelapse interval countdown value (e.g. 5...4...3...2...1...)."""

        self.space_rem: BleStatus[int] = BleStatus(communicator, StatusId.SPACE_REM, Int64ub)
        """Remaining space on the sdcard in Kilobytes."""

        self.streaming_supp: BleStatus[bool] = BleStatus(communicator, StatusId.STREAMING_SUPP, Flag)
        """Is streaming supports in current recording/flatmode/secondary-stream?"""

        self.wifi_bars: BleStatus[int] = BleStatus(communicator, StatusId.WIFI_BARS, Int8ub)
        """Wifi signal strength in bars."""

        self.current_time_ms: BleStatus[int] = BleStatus(communicator, StatusId.CURRENT_TIME_MS, Int32ub)
        """System time in milliseconds since system was booted."""

        self.num_hilights: BleStatus[int] = BleStatus(communicator, StatusId.NUM_HILIGHTS, Int8ub)
        """The number of hilights in encoding video (set to 0 when encoding stops)."""

        self.last_hilight: BleStatus[int] = BleStatus(communicator, StatusId.LAST_HILIGHT, Int32ub)
        """Time since boot (msec) of most recent hilight in encoding video (set to 0 when encoding stops)."""

        self.next_poll: BleStatus[int] = BleStatus(communicator, StatusId.NEXT_POLL, Int32ub)
        """The min time between camera status updates (msec). Do not poll for status more often than this."""

        self.analytics_rdy: BleStatus[Params.AnalyticsState] = BleStatus(
            communicator, StatusId.ANALYTICS_RDY, Params.AnalyticsState
        )
        """The current state of camera analytics."""

        self.analytics_size: BleStatus[int] = BleStatus(communicator, StatusId.ANALYTICS_SIZE, Int32ub)
        """The size (units??) of the analytics file."""

        self.in_context_menu: BleStatus[bool] = BleStatus(communicator, StatusId.IN_CONTEXT_MENU, Flag)
        """Is the camera currently in a contextual menu (e.g. Preferences)?"""

        self.timelapse_rem: BleStatus[int] = BleStatus(communicator, StatusId.TIMELAPSE_REM, Int32ub)
        """How many min of Timelapse video can be captured with current settings before sdcard is full?"""

        self.exposure_type: BleStatus[Params.ExposureMode] = BleStatus(
            communicator, StatusId.EXPOSURE_TYPE, Params.ExposureMode
        )
        """Liveview Exposure Select Mode."""

        self.exposure_x: BleStatus[int] = BleStatus(communicator, StatusId.EXPOSURE_X, Int8ub)
        """Liveview Exposure Select for y-coordinate (percent)."""

        self.exposure_y: BleStatus[int] = BleStatus(communicator, StatusId.EXPOSURE_Y, Int8ub)
        """Liveview Exposure Select for y-coordinate (percent)."""

        self.gps_stat: BleStatus[bool] = BleStatus(communicator, StatusId.GPS_STAT, Flag)
        """Does the camera currently have a GPS lock?"""

        self.ap_state: BleStatus[bool] = BleStatus(communicator, StatusId.AP_STATE, Flag)
        """Is the Wifi radio enabled?"""

        self.int_batt_per: BleStatus[int] = BleStatus(communicator, StatusId.INT_BATT_PER, Int8ub)
        """Internal battery level (percent)."""

        self.acc_mic_stat: BleStatus[Params.ExposureMode] = BleStatus(
            communicator, StatusId.ACC_MIC_STAT, Params.ExposureMode
        )
        """Microphone Accessory status."""

        self.digital_zoom: BleStatus[int] = BleStatus(communicator, StatusId.DIGITAL_ZOOM, Int8ub)
        """	Digital Zoom level (percent)."""

        self.wireless_band: BleStatus[Params.WifiBand] = BleStatus(
            communicator, StatusId.WIRELESS_BAND, Params.WifiBand
        )
        """Wireless Band."""

        self.dig_zoom_active: BleStatus[bool] = BleStatus(communicator, StatusId.DIG_ZOOM_ACTIVE, Flag)
        """Is Digital Zoom feature available?"""

        self.mobile_video: BleStatus[bool] = BleStatus(communicator, StatusId.MOBILE_VIDEO, Flag)
        """Are current video settings mobile friendly? (related to video compression and frame rate)."""

        self.first_time: BleStatus[bool] = BleStatus(communicator, StatusId.FIRST_TIME, Flag)
        """Is the camera currently in First Time Use (FTU) UI flow?"""

        self.sec_sd_stat: BleStatus[Params.SDStatus] = BleStatus(communicator, StatusId.SEC_SD_STAT, Params.SDStatus)
        """Secondary Storage Status (exclusive to Superbank)."""

        self.band_5ghz_avail: BleStatus[bool] = BleStatus(communicator, StatusId.BAND_5GHZ_AVAIL, Flag)
        """Is 5GHz wireless band available?"""

        self.system_ready: BleStatus[bool] = BleStatus(communicator, StatusId.SYSTEM_READY, Flag)
        """Is the system ready to accept messages?"""

        self.batt_ok_ota: BleStatus[bool] = BleStatus(communicator, StatusId.BATT_OK_OTA, Flag)
        """Is the internal battery charged sufficiently to start Over The Air (OTA) update?"""

        self.video_low_temp: BleStatus[bool] = BleStatus(communicator, StatusId.VIDEO_LOW_TEMP, Flag)
        """Is the camera getting too cold to continue recording?"""

        self.orientation: BleStatus[Params.Orientation] = BleStatus(
            communicator, StatusId.ORIENTATION, Params.Orientation
        )
        """The rotational orientation of the camera."""

        self.deprecated_87: BleStatus[Any] = BleStatus(
            communicator, StatusId.DEPRECATED_87, ByteParserBuilders.DeprecatedMarker()
        )
        """This status is deprecated."""

        self.zoom_encoding: BleStatus[bool] = BleStatus(communicator, StatusId.ZOOM_ENCODING, Flag)
        """Is this camera capable of zooming while encoding (static value based on model, not settings)?"""

        self.flatmode_id: BleStatus[Params.Flatmode] = BleStatus(communicator, StatusId.FLATMODE_ID, Params.Flatmode)
        """Current flatmode ID."""

        self.logs_ready: BleStatus[bool] = BleStatus(communicator, StatusId.LOGS_READY, Flag)
        """	Are system logs ready to be downloaded?"""

        self.deprecated_92: BleStatus[Any] = BleStatus(
            communicator, StatusId.DEPRECATED_92, ByteParserBuilders.DeprecatedMarker()
        )
        """This status is deprecated."""

        self.video_presets: BleStatus[int] = BleStatus(communicator, StatusId.VIDEO_PRESETS, Int32ub)
        """Current Video Preset (ID)."""

        self.photo_presets: BleStatus[int] = BleStatus(communicator, StatusId.PHOTO_PRESETS, Int32ub)
        """Current Photo Preset (ID)."""

        self.timelapse_presets: BleStatus[int] = BleStatus(communicator, StatusId.TIMELAPSE_PRESETS, Int32ub)
        """	Current Timelapse Preset (ID)."""

        self.presets_group: BleStatus[int] = BleStatus(communicator, StatusId.PRESETS_GROUP, Int32ub)
        """Current Preset Group (ID)."""

        self.active_preset: BleStatus[int] = BleStatus(communicator, StatusId.ACTIVE_PRESET, Int32ub)
        """Currently Preset (ID)."""

        self.preset_modified: BleStatus[int] = BleStatus(communicator, StatusId.PRESET_MODIFIED, Int32ub)
        """Preset Modified Status, which contains an event ID and a preset (group) ID."""

        self.live_burst_rem: BleStatus[int] = BleStatus(communicator, StatusId.LIVE_BURST_REM, Int32ub)
        """How many Live Bursts can be captured before sdcard is full?"""

        self.live_burst_total: BleStatus[int] = BleStatus(communicator, StatusId.LIVE_BURST_TOTAL, Int32ub)
        """Total number of Live Bursts on sdcard."""

        self.capt_delay_active: BleStatus[bool] = BleStatus(communicator, StatusId.CAPT_DELAY_ACTIVE, Flag)
        """Is Capture Delay currently active (i.e. counting down)?"""

        self.media_mod_mic_stat: BleStatus[Params.MediaModMicStatus] = BleStatus(
            communicator, StatusId.MEDIA_MOD_MIC_STAT, Params.MediaModMicStatus
        )
        """Media mod State."""

        self.timewarp_speed_ramp: BleStatus[Params.TimeWarpSpeed] = BleStatus(
            communicator, StatusId.TIMEWARP_SPEED_RAMP, Params.TimeWarpSpeed
        )
        """Time Warp Speed."""

        self.linux_core_active: BleStatus[bool] = BleStatus(communicator, StatusId.LINUX_CORE_ACTIVE, Flag)
        """Is the system's Linux core active?"""

        self.camera_lens_type: BleStatus[Params.MaxLensMode] = BleStatus(
            communicator, StatusId.CAMERA_LENS_TYPE, Params.MaxLensMode
        )
        """Camera lens type (reflects changes to setting 162)."""

        self.video_hindsight: BleStatus[bool] = BleStatus(communicator, StatusId.VIDEO_HINDSIGHT, Flag)
        """Is Video Hindsight Capture Active?"""

        self.scheduled_preset: BleStatus[int] = BleStatus(communicator, StatusId.SCHEDULED_PRESET, Int32ub)
        """Scheduled Capture Preset ID."""

        self.scheduled_capture: BleStatus[bool] = BleStatus(communicator, StatusId.SCHEDULED_CAPTURE, Flag)
        """Is Scheduled Capture set?"""

        self.creating_preset: BleStatus[bool] = BleStatus(communicator, StatusId.CREATING_PRESET, Flag)
        """Is the camera in the process of creating a custom preset?"""

        self.media_mod_stat: BleStatus[Params.MediaModStatus] = BleStatus(
            communicator, StatusId.MEDIA_MOD_STAT, Params.MediaModStatus
        )
        """Media Mode Status (bitmasked)."""

        self.turbo_mode: BleStatus[bool] = BleStatus(communicator, StatusId.TURBO_MODE, Flag)
        """Is Turbo Transfer active?"""

        self.sd_rating_check_error: BleStatus[bool] = BleStatus(communicator, StatusId.SD_RATING_CHECK_ERROR, Flag)
        """Does sdcard meet specified minimum write speed?"""

        self.sd_write_speed_error: BleStatus[int] = BleStatus(communicator, StatusId.SD_WRITE_SPEED_ERROR, Int8ub)
        """Number of sdcard write speed errors since device booted"""

        self.camera_control: BleStatus[Params.CameraControl] = BleStatus(
            communicator, StatusId.CAMERA_CONTROL, Params.CameraControl
        )
        """Camera control status ID"""

        self.usb_connected: BleStatus[bool] = BleStatus(communicator, StatusId.USB_CONNECTED, Flag)
        """Is the camera connected to a PC via USB?"""

        self.control_allowed_over_usb: BleStatus[bool] = BleStatus(communicator, StatusId.CONTROL_OVER_USB, Flag)
        """Is control allowed over USB?"""

        self.total_sd_space_kb: BleStatus[int] = BleStatus(communicator, StatusId.TOTAL_SD_SPACE_KB, Int32ub)
        """Total space taken up on the SD card in kilobytes"""

        self.photo_interval_capture_count: BleStatus[int] = BleStatus(
            communicator, StatusId.PHOTO_INTERVAL_CAPTURE_COUNT, Int32ub
        )
        """Photo interval capture count"""

        self.camera_lens_mod: BleStatus[Params.LensModStatus] = BleStatus(
            communicator, StatusId.CAMERA_LENS_MOD, Params.LensModStatus
        )
        """Current camera lens mod"""

        super().__init__(communicator)

================
File: demos/python/sdk_wireless_camera_control/open_gopro/api/builders.py
================
# builders.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Tue Sep  7 21:35:53 UTC 2021

"""Common functionality across API versions to build commands, settings, and statuses"""

from __future__ import annotations

import enum
import logging
from collections.abc import Iterable
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Callable, Final, Generic, Protocol, TypeVar, Union

import construct
import wrapt

from open_gopro.api.parsers import ByteParserBuilders
from open_gopro.ble import BleUUID
from open_gopro.communicator_interface import (
    BleMessage,
    BleMessages,
    GoProBle,
    GoProHttp,
    HttpMessage,
    HttpMessages,
    MessageRules,
)
from open_gopro.constants import (
    ActionId,
    CmdId,
    FeatureId,
    GoProUUIDs,
    QueryCmdId,
    SettingId,
    StatusId,
)
from open_gopro.enum import GoProIntEnum
from open_gopro.logger import Logger
from open_gopro.models.response import GlobalParsers, GoProResp
from open_gopro.parser_interface import BytesBuilder, BytesParserBuilder, Parser
from open_gopro.types import CameraState, JsonDict, Protobuf, UpdateCb

logger = logging.getLogger(__name__)

ValueType = TypeVar("ValueType")

QueryParserType = Union[construct.Construct, type[GoProIntEnum], BytesParserBuilder]


######################################################## BLE #################################################

T = TypeVar("T")


class BleReadCommand(BleMessage):
    """A BLE command that reads data from a BleUUID

    Args:
        uuid (BleUUID):  BleUUID to read from
        parser (Parser): the parser that will parse the received bytestream into a JSON dict
    """

    def __init__(self, uuid: BleUUID, parser: Parser) -> None:
        super().__init__(uuid=uuid, parser=parser, identifier=uuid)

    def _build_data(self, **kwargs: Any) -> bytearray:
        # Read commands do not have data
        raise NotImplementedError

    def __str__(self) -> str:
        return f"Read {self._uuid.name.lower().replace('_', ' ').title()}"

    def _as_dict(self, **kwargs: Any) -> JsonDict:
        """Return the attributes of the command as a dict

        Args:
            **kwargs (Any): additional entries for the dict

        Returns:
            JsonDict: command as dict
        """
        return {"id": self._uuid, **self._base_dict} | kwargs


class BleWriteCommand(BleMessage):
    """A BLE command that writes to a BleUUID and retrieves responses by accumulating notifications

    Args:
        uuid (BleUUID): UUID to write to
        cmd (CmdId): command identifier
        param_builder (BytesBuilder | None, optional): builds bytes from params. Defaults to None.
        parser (Parser | None, optional): response parser to parse received bytes. Defaults to None.
        rules (MessageRules): rules this Message must obey. Defaults to MessageRules().
    """

    def __init__(
        self,
        uuid: BleUUID,
        cmd: CmdId,
        param_builder: BytesBuilder | None = None,
        parser: Parser | None = None,
        rules: MessageRules = MessageRules(),
    ) -> None:
        self.param_builder = param_builder
        self.cmd = cmd
        self.rules = rules
        super().__init__(uuid, cmd, parser)

    def _build_data(self, **kwargs: Any) -> bytearray:
        data = bytearray([self.cmd.value])
        params = bytearray()
        if self.param_builder:
            params.extend(self.param_builder.build(*kwargs.values()))
        else:
            for arg in kwargs.values():
                params.extend(arg.value if isinstance(arg, enum.Enum) else arg)
        if params:
            data.append(len(params))
            data.extend(params)
        return data

    def __str__(self) -> str:
        return self.cmd.name.lower().replace("_", " ").removeprefix("cmdid").title()

    def _as_dict(self, **kwargs: Any) -> JsonDict:
        """Return the attributes of the command as a dict

        Args:
            **kwargs (Any): additional entries for the dict

        Returns:
            JsonDict: command as dict
        """
        return {"id": self.cmd, **self._base_dict} | kwargs


class RegisterUnregisterAll(BleWriteCommand):
    """Base class for register / unregister all commands

    This will loop over all of the elements (i.e. settings / statuses found from the element_set entry of the
    producer tuple parameter) and individually register / unregister (depending on the action parameter) each
    element in the set

    Args:
        uuid (BleUUID): UUID to write to
        cmd (CmdId): Command ID that is being sent
        update_set (type[SettingId] | type[StatusId]): what are registering / unregistering for?
        action (Action): whether to register or unregister
        parser (Parser | None): Optional response parser. Defaults to None.
    """

    class Action(enum.Enum):
        """Enum to differentiate between register actions"""

        REGISTER = enum.auto()
        UNREGISTER = enum.auto()

    def __init__(
        self,
        uuid: BleUUID,
        cmd: CmdId,
        update_set: type[SettingId] | type[StatusId],
        action: Action,
        parser: Parser | None = None,
    ) -> None:
        self.action = action
        self.update_set = update_set
        super().__init__(uuid=uuid, cmd=cmd, parser=parser)


class BleProtoCommand(BleMessage):
    """A BLE command that is sent and received as using the Protobuf protocol

    Args:
        uuid (BleUUID): BleUUID to write to
        feature_id (FeatureId): Feature ID that is being executed
        action_id (ActionId): protobuf specific action ID that is being executed
        response_action_id (ActionId): the action ID that will be in the response to this command
        request_proto (type[Protobuf]): the action ID that will be in the response
        response_proto (type[Protobuf]): protobuf used to parse received bytestream
        parser (Parser | None): Optional response parser. Defaults to None.
        additional_matching_ids (set[ActionId | CmdId] | None): Other action ID's to share this parser. This is used, for
            example, if a notification shares the same ID as the synchronous response. Defaults to None. Defaults to None.
    """

    def __init__(
        self,
        uuid: BleUUID,
        feature_id: FeatureId,
        action_id: ActionId,
        response_action_id: ActionId,
        request_proto: type[Protobuf],
        response_proto: type[Protobuf],
        parser: Parser | None,
        additional_matching_ids: set[ActionId | CmdId] | None = None,
    ) -> None:
        p = parser or Parser()
        p.byte_json_adapter = ByteParserBuilders.Protobuf(response_proto)
        super().__init__(uuid=uuid, parser=p, identifier=response_action_id)
        self.feature_id = feature_id
        self.action_id = action_id
        self.response_action_id = response_action_id
        self.request_proto = request_proto
        self.response_proto = response_proto
        self.additional_matching_ids: set[ActionId | CmdId] = additional_matching_ids or set()
        assert self._parser
        for matching_id in [*self.additional_matching_ids, response_action_id]:
            GlobalParsers.add(matching_id, self._parser)
        GlobalParsers.add_feature_action_id_mapping(self.feature_id, self.response_action_id)

    def _build_data(self, **kwargs: Any) -> bytearray:
        """Build the byte data to prepare for command sending

        Args:
            **kwargs (Any): arguments to command to use to build protobuf

        Returns:
            bytearray: built byte data
        """
        proto = self.request_proto()
        for attr_name, arg in kwargs.items():
            value = arg.value if issubclass(type(arg), enum.Enum) else arg
            attr = getattr(proto, attr_name)
            # Protobuf "repeatable" (i.e. iterable) fields can not be set directly and must be appended / extended
            if isinstance(attr, Iterable) and not isinstance(value, (str, bytes)):
                if isinstance(value, Iterable):
                    for element in value:
                        attr.append(element.value if isinstance(element, enum.Enum) else element)  # type: ignore
                else:
                    attr.append(value.value if isinstance(value, enum.Enum) else value)  # type:ignore
            else:
                setattr(proto, attr_name, value)
        # Prepend headers and serialize
        return bytearray([self.feature_id.value, self.action_id.value, *proto.SerializeToString()])

    def __str__(self) -> str:
        return self.action_id.name.lower().replace("_", " ").removeprefix("actionid").title()

    def _as_dict(self, **kwargs: Any) -> JsonDict:
        """Return the attributes of the command as a dict

        Args:
            **kwargs (Any): additional entries for the dict

        Returns:
            JsonDict: command as dict
        """
        return {"id": self.action_id, "feature_id": self.feature_id, **self._base_dict} | kwargs


def ble_write_command(
    uuid: BleUUID,
    cmd: CmdId,
    param_builder: BytesBuilder | None = None,
    parser: Parser | None = None,
    rules: MessageRules = MessageRules(),
) -> Callable:
    """Decorator to build and encapsulate a BleWriteCommand in a Callable

    Args:
        uuid (BleUUID): UUID to write to
        cmd (CmdId): command identifier
        param_builder (BytesBuilder | None, optional): builds bytes from params. Defaults to None.
        parser (Parser | None, optional): response parser to parse received bytes. Defaults to None.
        rules (MessageRules): rules this Message must obey. Defaults to MessageRules().

    Returns:
        Callable: built callable to perform operation
    """
    message = BleWriteCommand(uuid, cmd, param_builder, parser)

    @wrapt.decorator
    async def wrapper(wrapped: Callable, instance: BleMessages, _: Any, kwargs: Any) -> GoProResp:
        return await instance._communicator._send_ble_message(message, rules, **(await wrapped(**kwargs) or kwargs))

    return wrapper


def ble_read_command(uuid: BleUUID, parser: Parser) -> Callable:
    """Decorator to build a BleReadCommand and wrapper to execute it

    Args:
        uuid (BleUUID):  BleUUID to read from
        parser (Parser): the parser that will parse the received bytestream into a JSON dict

    Returns:
        Callable: Generated method to perform command
    """
    message = BleReadCommand(uuid, parser)

    @wrapt.decorator
    async def wrapper(wrapped: Callable, instance: BleMessages, _: Any, kwargs: Any) -> GoProResp:
        return await instance._communicator._read_ble_characteristic(message, **(await wrapped(**kwargs) or kwargs))

    return wrapper


def ble_register_command(
    uuid: BleUUID,
    cmd: CmdId,
    update_set: type[SettingId] | type[StatusId],
    action: RegisterUnregisterAll.Action,
    parser: Parser | None = None,
) -> Callable:
    """Decorator to build a RegisterUnregisterAll command and wrapper to execute it

    Args:
        uuid (BleUUID): UUID to write to
        cmd (CmdId): Command ID that is being sent
        update_set (type[SettingId] | type[StatusId]): set of ID's being registered for
        action (RegisterUnregisterAll.Action): whether to register or unregister
        parser (Parser | None): Optional response parser. Defaults to None.

    Returns:
        Callable: Generated method to perform command
    """
    message = RegisterUnregisterAll(uuid, cmd, update_set, action, parser)

    @wrapt.decorator
    async def wrapper(wrapped: Callable, instance: BleMessages, _: Any, kwargs: Any) -> GoProResp:
        return await instance._communicator._send_ble_message(message, **(await wrapped(**kwargs) or kwargs))

    return wrapper


def ble_proto_command(
    uuid: BleUUID,
    feature_id: FeatureId,
    action_id: ActionId,
    response_action_id: ActionId,
    request_proto: type[Protobuf],
    response_proto: type[Protobuf],
    parser: Parser | None = None,
    additional_matching_ids: set[ActionId | CmdId] | None = None,
) -> Callable:
    """Decorator to build a BLE Protobuf command and wrapper to execute it

    Args:
        uuid (BleUUID): BleUUID to write to
        feature_id (FeatureId): Feature ID that is being executed
        action_id (ActionId): protobuf specific action ID that is being executed
        response_action_id (ActionId): the action ID that will be in the response to this command
        request_proto (type[Protobuf]): the action ID that will be in the response
        response_proto (type[Protobuf]): protobuf used to parse received bytestream
        parser (Parser | None): Response parser to transform received Protobuf bytes. Defaults to None.
        additional_matching_ids (set[ActionId | CmdId] | None): Other action ID's to share this parser. This is used,
            for example, if a notification shares the same ID as the synchronous response. Defaults to None.

    Returns:
        Callable: Generated method to perform command
    """
    message = BleProtoCommand(
        uuid,
        feature_id,
        action_id,
        response_action_id,
        request_proto,
        response_proto,
        parser,
        additional_matching_ids,
    )

    @wrapt.decorator
    async def wrapper(wrapped: Callable, instance: BleMessages, _: Any, kwargs: Any) -> GoProResp:
        return await instance._communicator._send_ble_message(message, **(await wrapped(**kwargs) or kwargs))

    return wrapper


@dataclass
class BleAsyncResponse:
    """A BLE protobuf response that is not associated with any message.

    Args:
        feature_id (FeatureId): Feature ID that response corresponds to
        action_id (ActionId): Action ID that response corresponds to
    """

    feature_id: FeatureId
    action_id: ActionId
    parser: Parser

    def __str__(self) -> str:
        return self.action_id.name.lower().replace("_", " ").removeprefix("actionid").title()


class BuilderProtocol(Protocol):
    """Protocol definition of data building methods"""

    def __call__(self, **kwargs: Any) -> bytearray:  # noqa: D102
        ...


class BleSettingFacade(Generic[ValueType]):
    """Wrapper around BleSetting since a BleSetting's message definition changes based on how it is being operated on.

    Raises:
        TypeError: Parser builder is not a valid type

    Args:
        communicator (GoProBle): BLE communicator that will operate on this object.
        identifier (SettingId): Setting Identifier
        parser_builder (QueryParserType): Parses responses from bytes and builds requests to bytes.
    """

    SETTER_UUID: Final[BleUUID] = GoProUUIDs.CQ_SETTINGS
    READER_UUID: Final[BleUUID] = GoProUUIDs.CQ_QUERY

    class BleSettingMessageBase(BleMessage):
        """Actual BLE Setting Message that is wrapped by the facade.

        Args:
            uuid (BleUUID): UUID to access this setting.
            identifier (SettingId | QueryCmdId): How responses to operations on this message will be identified.
            setting_id (SettingId): Setting identifier. May match identifier in some cases.
            builder (BuilderProtocol): Build request bytes from the current message.
        """

        def __init__(
            self,
            uuid: BleUUID,
            identifier: SettingId | QueryCmdId,
            setting_id: SettingId,
            builder: BuilderProtocol,
        ) -> None:
            self._build = builder
            self._setting_id = setting_id
            super().__init__(uuid, identifier, None)  # type: ignore

        def _build_data(self, **kwargs: Any) -> bytearray:
            return self._build(**kwargs)

        def _as_dict(self, **kwargs: Any) -> JsonDict:
            d = {"id": self._identifier, "setting_id": self._setting_id, **self._base_dict} | kwargs
            return d

    def __init__(self, communicator: GoProBle, identifier: SettingId, parser_builder: QueryParserType) -> None:
        # TODO abstract this
        parser = Parser[CameraState]()
        if isinstance(parser_builder, construct.Construct):
            parser.byte_json_adapter = ByteParserBuilders.Construct(parser_builder)
        elif isinstance(parser_builder, BytesParserBuilder):
            parser.byte_json_adapter = parser_builder
        elif issubclass(parser_builder, GoProIntEnum):
            parser.byte_json_adapter = ByteParserBuilders.GoProEnum(parser_builder)
        else:
            raise TypeError(f"Unexpected {parser_builder=}")
        GlobalParsers.add(identifier, parser)

        self._identifier = identifier
        self._builder = parser.byte_json_adapter
        self._communicator = communicator

    def _build_cmd(self, cmd: QueryCmdId) -> bytearray:
        """Build the data

        Args:
            cmd (QueryCmdId): query command

        Returns:
            bytearray: built data
        """
        return bytearray([cmd.value, int(self._identifier)])

    async def set(self, value: ValueType) -> GoProResp[None]:
        """Set the value of the setting.

        Args:
            value (ValueType): The argument to use to set the setting value.

        Returns:
            GoProResp[None]: Status of set
        """

        def _build_data(**kwargs: Any) -> bytearray:
            # Special case. Can't use _send_query
            data = bytearray([int(self._identifier)])
            try:
                param = self._builder.build(kwargs["value"])
                data.extend([len(param), *param])
            except IndexError:
                pass
            return data

        message = BleSettingFacade.BleSettingMessageBase(
            BleSettingFacade.SETTER_UUID,
            self._identifier,
            self._identifier,
            lambda **_: _build_data(value=value),
        )
        return await self._communicator._send_ble_message(message)

    async def get_value(self) -> GoProResp[ValueType]:
        """Get the settings value.

        Returns:
            GoProResp[ValueType]: settings value
        """
        message = BleSettingFacade.BleSettingMessageBase(
            BleSettingFacade.READER_UUID,
            QueryCmdId.GET_SETTING_VAL,
            self._identifier,
            lambda **_: self._build_cmd(QueryCmdId.GET_SETTING_VAL),
        )
        return await self._communicator._send_ble_message(message)

    async def get_name(self) -> GoProResp[str]:
        """Get the settings name.

        Raises:
            NotImplementedError: This isn't implemented on the camera

        Returns:
            GoProResp[str]: setting name as string
        """
        raise NotImplementedError("Not implemented on camera!")

    async def get_capabilities_values(self) -> GoProResp[list[ValueType]]:
        """Get currently supported settings capabilities values.

        Returns:
            GoProResp[list[ValueType]]: settings capabilities values
        """
        message = BleSettingFacade.BleSettingMessageBase(
            BleSettingFacade.READER_UUID,
            QueryCmdId.GET_CAPABILITIES_VAL,
            self._identifier,
            lambda **_: self._build_cmd(QueryCmdId.GET_CAPABILITIES_VAL),
        )
        return await self._communicator._send_ble_message(message)

    async def get_capabilities_names(self) -> GoProResp[list[str]]:
        """Get currently supported settings capabilities names.

        Raises:
            NotImplementedError: This isn't implemented on the camera

        Returns:
            GoProResp[list[str]]: list of capability names as strings
        """
        raise NotImplementedError("Not implemented on camera!")

    async def register_value_update(self, callback: UpdateCb) -> GoProResp[None]:
        """Register for asynchronous notifications when a given setting ID's value updates.

        Args:
            callback (UpdateCb): callback to be notified with

        Returns:
            GoProResp[None]: Current value of respective setting ID
        """
        message = BleSettingFacade.BleSettingMessageBase(
            BleSettingFacade.READER_UUID,
            QueryCmdId.REG_SETTING_VAL_UPDATE,
            self._identifier,
            lambda **_: self._build_cmd(QueryCmdId.REG_SETTING_VAL_UPDATE),
        )
        if (response := await self._communicator._send_ble_message(message)).ok:
            self._communicator.register_update(callback, self._identifier)
        return response

    async def unregister_value_update(self, callback: UpdateCb) -> GoProResp[None]:
        """Stop receiving notifications when a given setting ID's value updates.

        Args:
            callback (UpdateCb): callback to be notified with

        Returns:
            GoProResp[None]: Status of unregister
        """
        message = BleSettingFacade.BleSettingMessageBase(
            BleSettingFacade.READER_UUID,
            QueryCmdId.UNREG_SETTING_VAL_UPDATE,
            self._identifier,
            lambda **_: self._build_cmd(QueryCmdId.UNREG_SETTING_VAL_UPDATE),
        )
        if (response := await self._communicator._send_ble_message(message)).ok:
            self._communicator.unregister_update(callback, self._identifier)
        return response

    async def register_capability_update(self, callback: UpdateCb) -> GoProResp[None]:
        """Register for asynchronous notifications when a given setting ID's capabilities update.

        Args:
            callback (UpdateCb): callback to be notified with

        Returns:
            GoProResp[None]: Current capabilities of respective setting ID
        """
        message = BleSettingFacade.BleSettingMessageBase(
            BleSettingFacade.READER_UUID,
            QueryCmdId.REG_CAPABILITIES_UPDATE,
            self._identifier,
            lambda **_: self._build_cmd(QueryCmdId.REG_CAPABILITIES_UPDATE),
        )
        if (response := await self._communicator._send_ble_message(message)).ok:
            self._communicator.unregister_update(callback, self._identifier)
        return response

    async def unregister_capability_update(self, callback: UpdateCb) -> GoProResp[None]:
        """Stop receiving notifications when a given setting ID's capabilities change.

        Args:
            callback (UpdateCb): callback to be notified with

        Returns:
            GoProResp[None]: Status of unregister
        """
        message = BleSettingFacade.BleSettingMessageBase(
            BleSettingFacade.READER_UUID,
            QueryCmdId.UNREG_CAPABILITIES_UPDATE,
            self._identifier,
            lambda **_: self._build_cmd(QueryCmdId.UNREG_CAPABILITIES_UPDATE),
        )
        if (response := await self._communicator._send_ble_message(message)).ok:
            self._communicator.unregister_update(callback, self._identifier)
        return response

    def __str__(self) -> str:
        return str(self._identifier).lower().replace("_", " ").title()


class BleStatusFacade(Generic[ValueType]):
    """Wrapper around BleStatus since a BleStatus's message definition changes based on how it is being operated on.

    Args:
        communicator (GoProBle): BLE communicator that will operate on this object.
        identifier (StatusId): Status identifier
        parser (QueryParserType): Parser responses from bytes

    Raises:
        TypeError: Attempted to pass an invalid parser type
    """

    UUID: Final[BleUUID] = GoProUUIDs.CQ_QUERY

    class BleStatusMessageBase(BleMessage):
        """An individual camera status that is interacted with via BLE.

        Args:
            uuid (BleUUID): UUID to access this status.
            identifier (StatusId | QueryCmdId): How responses to operations on this message will be identified.
            status_id (StatusId): Status identifier. May match identifier in some cases.
            builder (Callable[[Any], bytearray]): Build request bytes from the current message.
        """

        def __init__(
            self,
            uuid: BleUUID,
            identifier: StatusId | QueryCmdId,
            status_id: StatusId,
            builder: Callable[[Any], bytearray],
        ) -> None:
            self._build = builder
            self._status_id = status_id
            super().__init__(uuid, identifier, None)  # type: ignore

        def _build_data(self, **kwargs: Any) -> bytearray:
            return self._build(self, **kwargs)

        def _as_dict(self, **kwargs: Any) -> JsonDict:
            return {"id": self._identifier, "status_id": self._status_id, **self._base_dict} | kwargs

    def __init__(self, communicator: GoProBle, identifier: StatusId, parser: QueryParserType) -> None:
        # TODO abstract this
        parser_builder = Parser[CameraState]()
        # Is it a protobuf enum?
        if isinstance(parser, construct.Construct):
            parser_builder.byte_json_adapter = ByteParserBuilders.Construct(parser)
        elif isinstance(parser, BytesParserBuilder):
            parser_builder.byte_json_adapter = parser
        elif issubclass(parser, GoProIntEnum):
            parser_builder.byte_json_adapter = ByteParserBuilders.GoProEnum(parser)
        else:
            raise TypeError(f"Unexpected {parser_builder=}")
        GlobalParsers.add(identifier, parser_builder)

        self._communicator = communicator
        self._identifier = identifier

    def __str__(self) -> str:
        return str(self._identifier).lower().replace("_", " ").title()

    async def get_value(self) -> GoProResp[ValueType]:
        """Get the current value of a status.

        Returns:
            GoProResp[ValueType]: current status value
        """
        message = BleStatusFacade.BleStatusMessageBase(
            BleStatusFacade.UUID,
            QueryCmdId.GET_STATUS_VAL,
            self._identifier,
            lambda *args: self._build_cmd(QueryCmdId.GET_STATUS_VAL),
        )
        return await self._communicator._send_ble_message(message)

    async def register_value_update(self, callback: UpdateCb) -> GoProResp[ValueType]:
        """Register for asynchronous notifications when a status changes.

        Args:
            callback (UpdateCb): callback to be notified with

        Returns:
            GoProResp[ValueType]: current status value
        """
        message = BleStatusFacade.BleStatusMessageBase(
            BleStatusFacade.UUID,
            QueryCmdId.REG_STATUS_VAL_UPDATE,
            self._identifier,
            lambda *args: self._build_cmd(QueryCmdId.REG_STATUS_VAL_UPDATE),
        )
        if (response := await self._communicator._send_ble_message(message)).ok:
            self._communicator.register_update(callback, self._identifier)
        return response

    async def unregister_value_update(self, callback: UpdateCb) -> GoProResp[None]:
        """Stop receiving notifications when status changes.

        Args:
            callback (UpdateCb): callback to be notified with

        Returns:
            GoProResp[None]: Status of unregister
        """
        message = BleStatusFacade.BleStatusMessageBase(
            BleStatusFacade.UUID,
            QueryCmdId.UNREG_STATUS_VAL_UPDATE,
            self._identifier,
            lambda *args: self._build_cmd(QueryCmdId.UNREG_STATUS_VAL_UPDATE),
        )
        if (response := await self._communicator._send_ble_message(message)).ok:
            self._communicator.register_update(callback, self._identifier)
        return response

    def _build_cmd(self, cmd: QueryCmdId) -> bytearray:
        """Build the data for a given status command.

        Args:
            cmd (QueryCmdId): command to build data for

        Returns:
            bytearray: data to send over-the-air
        """
        return bytearray([cmd.value, int(self._identifier)])


######################################################## HTTP #################################################


def http_get_json_command(
    endpoint: str,
    components: list[str] | None = None,
    arguments: list[str] | None = None,
    parser: Parser | None = None,
    identifier: str | None = None,
    rules: MessageRules = MessageRules(),
) -> Callable:
    """Decorator to build and encapsulate a an Http Message that performs a GET to return JSON.

    Args:
        endpoint (str): base endpoint
        components (list[str] | None): Additional path components (i.e. endpoint/{COMPONENT}). Defaults to None.
        arguments (list[str] | None): Any arguments to be appended after endpoint (i.e. endpoint?{ARGUMENT}). Defaults to None.
        parser (Parser | None): Parser to handle received JSON. Defaults to None.
        identifier (str | None): explicit message identifier. If None, will be generated from endpoint.
        rules (MessageRules): rules this Message must obey. Defaults to MessageRules().

    Returns:
        Callable: built callable to perform operation
    """
    message = HttpMessage(
        endpoint=endpoint, identifier=identifier, components=components, arguments=arguments, parser=parser
    )

    @wrapt.decorator
    async def wrapper(wrapped: Callable, instance: HttpMessages, _: Any, kwargs: Any) -> GoProResp:
        return await instance._communicator._get_json(message, rules=rules, **(await wrapped(**kwargs) or kwargs))

    return wrapper


def http_get_binary_command(
    endpoint: str,
    components: list[str] | None = None,
    arguments: list[str] | None = None,
    parser: Parser | None = None,
    identifier: str | None = None,
    rules: MessageRules = MessageRules(),
) -> Callable:
    """Decorator to build and encapsulate a an Http Message that performs a GET to return a binary.

    Args:
        endpoint (str): base endpoint
        components (list[str] | None): Additional path components (i.e. endpoint/{COMPONENT}). Defaults to None.
        arguments (list[str] | None): Any arguments to be appended after endpoint (i.e. endpoint?{ARGUMENT}). Defaults to None.
        parser (Parser | None): Parser to handle received JSON. Defaults to None.
        identifier (str | None): explicit message identifier. If None, will be generated from endpoint.
        rules (MessageRules): rules this Message must obey. Defaults to MessageRules().

    Returns:
        Callable: built callable to perform operation
    """
    message = HttpMessage(
        endpoint=endpoint, identifier=identifier, components=components, arguments=arguments, parser=parser
    )

    @wrapt.decorator
    async def wrapper(wrapped: Callable, instance: HttpMessages, _: Any, kwargs: Any) -> GoProResp:
        kwargs = await wrapped(**kwargs) or kwargs
        # If no local file was passed, used the file name of the camera file
        kwargs["local_file"] = (
            kwargs.pop("local_file") if "local_file" in kwargs else Path(kwargs["camera_file"].split("/")[-1])
        )
        return await instance._communicator._get_stream(message, rules=rules, **kwargs)

    return wrapper


def http_put_json_command(
    endpoint: str,
    components: list[str] | None = None,
    arguments: list[str] | None = None,
    body_args: list[str] | None = None,
    parser: Parser | None = None,
    identifier: str | None = None,
    rules: MessageRules = MessageRules(),
) -> Callable:
    """Decorator to build and encapsulate a an Http Message that performs a PUT to return JSON.

    Args:
        endpoint (str): base endpoint
        components (list[str] | None): Additional path components (i.e. endpoint/{COMPONENT}). Defaults to None.
        arguments (list[str] | None): Any arguments to be appended after endpoint (i.e. endpoint?{ARGUMENT}). Defaults to None.
        body_args (list[str] | None, optional): Arguments to be added to the body JSON. Defaults to None.
        parser (Parser | None): Parser to handle received JSON. Defaults to None.
        identifier (str | None): explicit message identifier. If None, will be generated from endpoint.
        rules (MessageRules): rules this Message must obey. Defaults to MessageRules().

    Returns:
        Callable: built callable to perform operation
    """
    message = HttpMessage(
        endpoint=endpoint,
        identifier=identifier,
        body_args=body_args,
        arguments=arguments,
        components=components,
        parser=parser,
    )

    @wrapt.decorator
    async def wrapper(wrapped: Callable, instance: HttpMessages, _: Any, kwargs: Any) -> GoProResp:
        return await instance._communicator._put_json(message, rules=rules, **(await wrapped(**kwargs) or kwargs))

    return wrapper


class HttpSetting(HttpMessage, Generic[ValueType]):
    """An individual camera setting that is interacted with via Wifi."""

    def __init__(self, communicator: GoProHttp, identifier: SettingId) -> None:
        super().__init__("gopro/camera/setting?setting={setting}&option={option}", identifier)
        self._communicator = communicator
        # Note! It is assumed that BLE and HTTP settings are symmetric so we only add to the communicator's
        # parser in the BLE Setting.

    def __str__(self) -> str:
        return str(self._identifier).lower().replace("_", " ").title()

    def build_url(self, **kwargs: Any) -> str:
        """Build the endpoint from the current arguments

        Args:
            **kwargs (Any): run-time arguments

        Returns:
            str: built URL
        """
        return self._endpoint.format(setting=int(self._identifier), option=int(kwargs["value"]))

    async def set(self, value: ValueType) -> GoProResp:
        """Set the value of the setting.

        Args:
            value (ValueType): value to set setting

        Returns:
            GoProResp: Status of set
        """
        response = await self._communicator._get_json(self, value=value)
        response.identifier = self._identifier
        logger.info(Logger.build_log_rx_str(response))
        return response

================
File: demos/python/sdk_wireless_camera_control/open_gopro/api/http_commands.py
================
# http_commands.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http:/gopro.com/OpenGoPro).
# This copyright was auto-generated on Tue Sep  7 21:35:52 UTC 2021

"""HTTP API for Open GoPro version 2.0"""

# mypy: disable-error-code=empty-body

from __future__ import annotations

import datetime
import logging
from pathlib import Path

from open_gopro import proto
from open_gopro.api.builders import (
    HttpSetting,
    http_get_binary_command,
    http_get_json_command,
    http_put_json_command,
)
from open_gopro.api.parsers import JsonParsers
from open_gopro.communicator_interface import (
    GoProHttp,
    HttpMessage,
    HttpMessages,
    MessageRules,
)
from open_gopro.constants import SettingId
from open_gopro.models import CameraInfo, MediaList, MediaMetadata, MediaPath
from open_gopro.models.general import WebcamResponse
from open_gopro.models.response import GoProResp
from open_gopro.parser_interface import Parser
from open_gopro.types import CameraState, JsonDict

from . import params as Params

logger = logging.getLogger(__name__)


class HttpCommands(HttpMessages[HttpMessage]):
    """All of the HTTP commands.

    To be used as a delegate for a GoProHttp to build commands
    """

    @http_get_json_command(endpoint="/gp/gpControl/command/storage/delete/all")
    async def delete_all(self) -> GoProResp[None]:
        """Delete all files on the SD card.

        Returns:
            GoProResp[None]: command status
        """

    @http_get_json_command(endpoint="gopro/media/delete/file", arguments=["path"])
    async def delete_file(self, *, path: str) -> GoProResp[None]:
        """Delete a single file including single files that are part of a group.

        Args:
            path (str): path to file to delete

        Returns:
            GoProResp[None]: command status
        """

    @http_get_json_command(endpoint="/gp/gpControl/command/storage/delete/group", arguments=["p"])
    async def delete_group(self, *, path: str) -> GoProResp[None]:
        """Delete all contents of a group. Should not be used on non-group files.

        Args:
            path (str): path to first file in the group.

        Returns:
            GoProResp[None]: command status
        """
        return {"p": path}  # type: ignore

    @http_get_json_command(
        endpoint="gopro/media/last_captured",
        parser=Parser(json_parser=JsonParsers.PydanticAdapter(MediaPath)),
    )
    async def get_last_captured_media(self) -> GoProResp[MediaPath]:
        """Get the last captured media file.

        Returns:
            GoProResp[MediaPath]: path of last captured media file
        """

    @http_put_json_command(
        endpoint="gopro/camera/presets/update_custom",
        body_args=["custom_name", "icon_id", "title_id"],
    )
    async def update_custom_preset(
        self,
        *,
        icon_id: proto.EnumPresetIcon.ValueType | None = None,
        title_id: str | proto.EnumPresetTitle.ValueType | None = None,
        custom_name: str | None = None,
    ) -> GoProResp[None]:
        """For a custom preset, update the Icon and / or the Title

        Args:
            icon_id (proto.EnumPresetIcon.ValueType | None): Icon to use. Defaults to None.
            title_id (str | proto.EnumPresetTitle.ValueType | None): Title to use. Defaults to None.
            custom_name (str | None): Custom name to use if title_id is set to
                `proto.EnumPresetTitle.PRESET_TITLE_USER_DEFINED_CUSTOM_NAME`. Defaults to None.

        Returns:
            GoProResp[None]: command status
        """

    @http_get_json_command(endpoint="gopro/camera/digital_zoom", arguments=["percent"])
    async def set_digital_zoom(self, *, percent: int) -> GoProResp[None]:
        """Set digital zoom in percent.

        Args:
            percent (int): Desired zoom as a percentage

        Returns:
            GoProResp[None]: command status
        """

    @http_get_json_command(
        endpoint="gopro/camera/state",
        parser=Parser(json_parser=JsonParsers.CameraStateParser()),
        rules=MessageRules(fastpass_analyzer=MessageRules.always_true),
    )
    async def get_camera_state(self) -> GoProResp[CameraState]:
        """Get all camera statuses and settings

        Returns:
            GoProResp[CameraState]: status and settings as JSON
        """

    @http_get_json_command(
        endpoint="gopro/camera/info", parser=Parser(json_parser=JsonParsers.PydanticAdapter(CameraInfo))
    )
    async def get_camera_info(self) -> GoProResp[CameraInfo]:
        """Get general information about the camera such as firmware version

        Returns:
            GoProResp[CameraInfo]: status and settings as JSON
        """

    @http_get_json_command(endpoint="gopro/camera/keep_alive")
    async def set_keep_alive(self) -> GoProResp[None]:
        """Send the keep alive signal to maintain the connection.

        Returns:
            GoProResp[None]: command status
        """

    @http_get_json_command(
        endpoint="gopro/media/info",
        arguments=["path"],
        parser=Parser(json_parser=JsonParsers.PydanticAdapter(MediaMetadata)),
    )
    async def get_media_metadata(self, *, path: str) -> GoProResp[MediaMetadata]:
        """Get media metadata for a file.

        Args:
            path (str): Path on camera of media file to get metadata for

        Returns:
            GoProResp[MediaMetadata]: Media metadata JSON structure
        """

    @http_get_json_command(
        endpoint="gopro/media/list",
        parser=Parser(json_parser=JsonParsers.PydanticAdapter(MediaList)),
    )
    async def get_media_list(self) -> GoProResp[MediaList]:
        """Get a list of media on the camera.

        Returns:
            GoProResp[MediaList]: Media list JSON structure
        """

    @http_get_json_command(endpoint="gopro/media/turbo_transfer", arguments=["p"])
    async def set_turbo_mode(self, *, mode: Params.Toggle) -> GoProResp[None]:
        """Enable or disable Turbo transfer mode.

        Args:
            mode (Params.Toggle): enable / disable turbo mode

        Returns:
            GoProResp[None]: Status
        """
        return {"p": mode}  # type: ignore

    @http_get_json_command(
        endpoint="gopro/version",
        parser=Parser(json_parser=JsonParsers.LambdaParser(lambda data: f"{data['version']}")),
    )
    async def get_open_gopro_api_version(self) -> GoProResp[str]:
        """Get Open GoPro API version

        Returns:
            GoProResp[str]: Open GoPro Version
        """

    # TODO make pydantic model of preset status
    @http_get_json_command(endpoint="gopro/camera/presets/get")
    async def get_preset_status(self) -> GoProResp[JsonDict]:
        """Get status of current presets

        Returns:
            GoProResp[JsonDict]: JSON describing currently available presets and preset groups
        """

    @http_get_json_command(endpoint="gopro/camera/presets/load", arguments=["id"])
    async def load_preset(self, *, preset: int) -> GoProResp[None]:
        """Set camera to a given preset

        The preset ID can be found from :py:class:`open_gopro.api.http_commands.HttpCommands.get_preset_status`

        Args:
            preset (int): preset to load

        Returns:
            GoProResp[None]: command status
        """
        return {"id": preset}  # type: ignore

    @http_get_json_command(endpoint="gopro/camera/presets/set_group", arguments=["id"])
    async def load_preset_group(self, *, group: proto.EnumPresetGroup.ValueType) -> GoProResp[None]:
        """Set the active preset group.

        The most recently used Preset in this group will be set.

        Args:
            group (proto.EnumPresetGroup.ValueType): desired Preset Group

        Returns:
            GoProResp[None]: command status
        """
        return {"id": group}  # type: ignore

    @http_get_json_command(
        endpoint="gopro/camera/stream", arguments=["port"], components=["mode"], identifier="Preview Stream"
    )
    async def set_preview_stream(self, *, mode: Params.Toggle, port: int | None = None) -> GoProResp[None]:
        """Start or stop the preview stream

        Args:
            mode (Params.Toggle): enable to start or disable to stop
            port (int | None): Port to use for Preview Stream. Defaults to 8554 if None.
                Only relevant when starting the stream.

        Returns:
            GoProResp[None]: command status
        """
        return {"mode": "start" if mode is Params.Toggle.ENABLE else "stop", "port": port}  # type: ignore

    @http_get_json_command(endpoint="gopro/camera/analytics/set_client_info")
    async def set_third_party_client_info(self) -> GoProResp[None]:
        """Flag as third party app

        Returns:
            GoProResp[None]: command status
        """

    @http_get_json_command(
        endpoint="gopro/camera/shutter",
        components=["mode"],
        rules=MessageRules(
            fastpass_analyzer=lambda **kwargs: kwargs["mode"] == "stop",
            wait_for_encoding_analyzer=lambda **kwargs: kwargs["mode"] == "start",
        ),
    )
    async def set_shutter(self, *, shutter: Params.Toggle) -> GoProResp[None]:
        """Set the shutter on or off

        Args:
            shutter (Params.Toggle): on or off (i.e. start or stop encoding)

        Returns:
            GoProResp[None]: command status
        """
        return {"mode": "start" if shutter is Params.Toggle.ENABLE else "stop"}  # type: ignore

    @http_get_json_command(endpoint="gopro/camera/control/set_ui_controller", arguments=["p"])
    async def set_camera_control(self, *, mode: Params.CameraControl) -> GoProResp[None]:
        """Configure global behaviors by setting camera control (to i.e. Idle, External)

        Args:
            mode (Params.CameraControl): desired camera control value

        Returns:
            GoProResp[None]: command status
        """
        return {"p": mode}  # type: ignore

    @http_get_json_command(endpoint="gopro/camera/set_date_time", arguments=["date", "time", "tzone", "dst"])
    async def set_date_time(
        self,
        *,
        date_time: datetime.datetime,
        tz_offset: int = 0,
        is_dst: bool = False,
    ) -> GoProResp[None]:
        """Update the date and time of the camera

        Args:
            date_time (datetime.datetime): date and time
            tz_offset (int): timezone (as UTC offset). Defaults to 0.
            is_dst (bool): is daylight savings time?. Defaults to False.

        Returns:
            GoProResp[None]: command status
        """
        return {  # type: ignore
            "date": f"{date_time.year}_{date_time.month}_{date_time.day}",
            "time": f"{date_time.hour}_{date_time.minute}_{date_time.second}",
            "tzone": tz_offset,
            "dst": int(is_dst),
        }

    @http_get_json_command(endpoint="gopro/camera/get_date_time")
    async def get_date_time(self) -> GoProResp[datetime.datetime]:
        """Get the date and time of the camera (Non timezone / DST aware)

        Returns:
            GoProResp[datetime.datetime]: current date and time on camera
        """

    @http_get_json_command(endpoint="gopro/webcam/version")
    async def get_webcam_version(self) -> GoProResp[str]:
        """Get the version of the webcam implementation

        Returns:
            GoProResp[str]: version
        """

    @http_get_json_command(
        endpoint="gopro/media/hilight/file",
        arguments=["path", "ms"],
    )
    async def add_file_hilight(
        self,
        *,
        file: str,
        offset: int | None = None,
    ) -> GoProResp[None]:
        """Add a hilight to a media file (.mp4)

        Args:
            file (str):  the media to add the hilight to
            offset (int | None): offset in ms from start of media

        Returns:
            GoProResp[None]: command status
        """
        return {"path": file, "ms": offset or None}  # type: ignore

    @http_get_json_command(
        endpoint="gopro/media/hilight/remove",
        arguments=["path", "ms"],
    )
    async def remove_file_hilight(
        self,
        *,
        file: str,
        offset: int | None = None,
    ) -> GoProResp[None]:
        """Remove a hilight from a media file (.mp4)

        Args:
            file (str):  the media to remove the hilight from
            offset (int | None): offset in ms from start of media

        Returns:
            GoProResp[None]: command status
        """
        return {"path": file, "ms": offset}  # type: ignore

    @http_get_json_command(
        endpoint="gopro/webcam/exit",
        parser=Parser(json_parser=JsonParsers.PydanticAdapter(WebcamResponse)),
        rules=MessageRules(fastpass_analyzer=MessageRules.always_true),
    )
    async def webcam_exit(self) -> GoProResp[WebcamResponse]:
        """Exit the webcam.

        Returns:
            GoProResp[WebcamResponse]: command status
        """

    @http_get_json_command(
        endpoint="gopro/webcam/preview",
        parser=Parser(json_parser=JsonParsers.PydanticAdapter(WebcamResponse)),
        rules=MessageRules(fastpass_analyzer=MessageRules.always_true),
    )
    async def webcam_preview(self) -> GoProResp[WebcamResponse]:
        """Start the webcam preview.

        Returns:
            GoProResp[WebcamResponse]: command status
        """

    @http_get_json_command(
        endpoint="gopro/webcam/start",
        arguments=["res", "fov", "port", "protocol"],
        parser=Parser(json_parser=JsonParsers.PydanticAdapter(WebcamResponse)),
        rules=MessageRules(fastpass_analyzer=MessageRules.always_true),
    )
    async def webcam_start(
        self,
        *,
        resolution: Params.WebcamResolution | None = None,
        fov: Params.WebcamFOV | None = None,
        port: int | None = None,
        protocol: Params.WebcamProtocol | None = None,
    ) -> GoProResp[WebcamResponse]:
        """Start the webcam.

        Args:
            resolution (Params.WebcamResolution | None): resolution to use. If not set, camera default will be used.
            fov (Params.WebcamFOV | None): field of view to use. If not set, camera default will be used.
            port (int | None): port to use for streaming. If not set, camera default of 8554 will be used.
            protocol (Params.WebcamProtocol | None): streaming protocol to use. If not set, camera default of TS will
                be used.

        Returns:
            GoProResp[WebcamResponse]: command status
        """
        return {"res": resolution, "fov": fov, "port": port, "protocol": protocol}  # type: ignore

    @http_get_json_command(
        endpoint="gopro/webcam/stop",
        rules=MessageRules(fastpass_analyzer=MessageRules.always_true),
        parser=Parser(json_parser=JsonParsers.PydanticAdapter(WebcamResponse)),
    )
    async def webcam_stop(self) -> GoProResp[WebcamResponse]:
        """Stop the webcam.

        Returns:
            GoProResp[WebcamResponse]: command status
        """

    @http_get_json_command(
        endpoint="gopro/webcam/status",
        parser=Parser(json_parser=JsonParsers.PydanticAdapter(WebcamResponse)),
        rules=MessageRules(fastpass_analyzer=MessageRules.always_true),
    )
    async def webcam_status(self) -> GoProResp[WebcamResponse]:
        """Get the current status of the webcam

        Returns:
            GoProResp[WebcamResponse]: command status including the webcam status
        """

    @http_get_json_command(
        endpoint="gopro/camera/control/wired_usb",
        arguments=["p"],
    )
    async def wired_usb_control(self, *, control: Params.Toggle) -> GoProResp[None]:
        """Enable / disable wired usb control

        Args:
            control (Params.Toggle): enable or disable

        Returns:
            GoProResp[None]: command status
        """
        return {"p": control}  # type: ignore

    @http_get_binary_command(endpoint="gopro/media/gpmf", arguments=["path"])
    async def get_gpmf_data(self, *, camera_file: str, local_file: Path | None = None) -> GoProResp[Path]:
        """Get GPMF data for a file.

        If local_file is none, the output location will be the same name as the camera_file.

        Args:
            camera_file (str): filename on camera to operate on
            local_file (Path | None): Location on computer to write output. Defaults to None.

        Returns:
            GoProResp[Path]: Path to local_file that output was written to
        """

    @http_get_binary_command(endpoint="gopro/media/screennail", arguments=["path"])
    async def get_screennail__call__(self, *, camera_file: str, local_file: Path | None = None) -> GoProResp[Path]:
        """Get screennail for a file.

        If local_file is none, the output location will be the same name as the camera_file.

        Args:
            camera_file (str): filename on camera to operate on
            local_file (Path | None): Location on computer to write output. Defaults to None.

        Returns:
            GoProResp[Path]: Path to local_file that output was written to
        """

    @http_get_binary_command(endpoint="gopro/media/thumbnail", arguments=["path"])
    async def get_thumbnail(self, *, camera_file: str, local_file: Path | None = None) -> GoProResp[Path]:
        """Get thumbnail for a file.

        If local_file is none, the output location will be the same name as the camera_file.

        Args:
            camera_file (str): filename on camera to operate on
            local_file (Path | None): Location on computer to write output. Defaults to None.

        Returns:
            GoProResp[Path]: Path to local_file that output was written to
        """

    @http_get_binary_command(endpoint="gopro/media/telemetry", arguments=["path"])
    async def get_telemetry(self, *, camera_file: str, local_file: Path | None = None) -> GoProResp[Path]:
        """Download the telemetry data for a camera file and store in a local file.

        If local_file is none, the output location will be the same name as the camera_file.

        Args:
            camera_file (str): filename on camera to operate on
            local_file (Path | None): Location on computer to write output. Defaults to None.

        Returns:
            GoProResp[Path]: Path to local_file that output was written to
        """

    @http_get_binary_command(endpoint="videos/DCIM", components=["path"], identifier="Download File")
    async def download_file(self, *, camera_file: str, local_file: Path | None = None) -> GoProResp[Path]:
        """Download a video from the camera to a local file.

        If local_file is none, the output location will be the same name as the camera_file.

        Args:
            camera_file (str): filename on camera to operate on
            local_file (Path | None): Location on computer to write output. Defaults to None.

        Returns:
            GoProResp[Path]: Path to local_file that output was written to
        """


class HttpSettings(HttpMessages[HttpSetting]):
    # pylint: disable=missing-class-docstring, unused-argument
    """The collection of all HTTP Settings

    Args:
        communicator (GoProHttp): Adapter to read / write settings
    """

    def __init__(self, communicator: GoProHttp):
        self.resolution: HttpSetting[Params.Resolution] = HttpSetting[Params.Resolution](
            communicator, SettingId.RESOLUTION
        )
        """Resolution."""

        self.fps: HttpSetting[Params.FPS] = HttpSetting[Params.FPS](communicator, SettingId.FPS)
        """Frames per second."""

        self.auto_off: HttpSetting[Params.AutoOff] = HttpSetting[Params.AutoOff](communicator, SettingId.AUTO_OFF)
        """Set the auto off time."""

        self.video_field_of_view: HttpSetting[Params.VideoFOV] = HttpSetting[Params.VideoFOV](
            communicator, SettingId.VIDEO_FOV
        )
        """Video FOV."""

        self.photo_field_of_view: HttpSetting[Params.PhotoFOV] = HttpSetting[Params.PhotoFOV](
            communicator, SettingId.PHOTO_FOV
        )
        """Photo FOV."""

        self.multi_shot_field_of_view: HttpSetting[Params.MultishotFOV] = HttpSetting[Params.MultishotFOV](
            communicator, SettingId.MULTI_SHOT_FOV
        )
        """Multi-shot FOV."""

        self.max_lens_mode: HttpSetting[Params.MaxLensMode] = HttpSetting[Params.MaxLensMode](
            communicator, SettingId.MAX_LENS_MOD
        )
        """Enable / disable max lens mod."""

        self.hypersmooth: HttpSetting[Params.HypersmoothMode] = HttpSetting[Params.HypersmoothMode](
            communicator, SettingId.HYPERSMOOTH
        )
        """Set / disable hypersmooth."""

        self.video_performance_mode: HttpSetting[Params.PerformanceMode] = HttpSetting[Params.PerformanceMode](
            communicator, SettingId.VIDEO_PERFORMANCE_MODE
        )
        """Video Performance Mode (extended battery, tripod, etc)."""

        self.media_format: HttpSetting[Params.MediaFormat] = HttpSetting[Params.MediaFormat](
            communicator, SettingId.MEDIA_FORMAT
        )
        """Set the media format."""

        self.anti_flicker: HttpSetting[Params.AntiFlicker] = HttpSetting[Params.AntiFlicker](
            communicator, SettingId.ANTI_FLICKER
        )
        """Anti Flicker frequency."""

        self.camera_ux_mode: HttpSetting[Params.CameraUxMode] = HttpSetting[Params.CameraUxMode](
            communicator, SettingId.CAMERA_UX_MODE
        )
        """Camera controls configuration."""

        self.video_easy_mode: HttpSetting[int] = HttpSetting[int](communicator, SettingId.VIDEO_EASY_MODE)
        """Video easy mode speed."""

        self.photo_easy_mode: HttpSetting[Params.PhotoEasyMode] = HttpSetting[Params.PhotoEasyMode](
            communicator, SettingId.PHOTO_EASY_MODE
        )
        """Night Photo easy mode."""

        self.wifi_band: HttpSetting[Params.WifiBand] = HttpSetting[Params.WifiBand](communicator, SettingId.WIFI_BAND)
        """Current WiFi band being used."""

        self.star_trail_length: HttpSetting[Params.StarTrailLength] = HttpSetting[Params.StarTrailLength](
            communicator, SettingId.STAR_TRAIL_LENGTH
        )
        """Multi shot star trail length."""

        self.system_video_mode: HttpSetting[Params.SystemVideoMode] = HttpSetting[Params.SystemVideoMode](
            communicator, SettingId.SYSTEM_VIDEO_MODE
        )
        """System video mode."""

        self.video_horizon_leveling: HttpSetting[Params.HorizonLeveling] = HttpSetting[Params.HorizonLeveling](
            communicator, SettingId.VIDEO_HORIZON_LEVELING
        )
        """Lock / unlock horizon leveling for video."""

        self.photo_horizon_leveling: HttpSetting[Params.HorizonLeveling] = HttpSetting[Params.HorizonLeveling](
            communicator, SettingId.PHOTO_HORIZON_LEVELING
        )
        """Lock / unlock horizon leveling for photo."""

        self.bit_rate: HttpSetting[Params.BitRate] = HttpSetting[Params.BitRate](
            communicator,
            SettingId.BIT_RATE,
        )
        """System Video Bit Rate."""

        self.bit_depth: HttpSetting[Params.BitDepth] = HttpSetting[Params.BitDepth](
            communicator,
            SettingId.BIT_DEPTH,
        )
        """System Video Bit depth."""

        self.video_profile: HttpSetting[Params.VideoProfile] = HttpSetting[Params.VideoProfile](
            communicator,
            SettingId.VIDEO_PROFILE,
        )
        """Video Profile (hdr, etc.)"""

        self.video_aspect_ratio: HttpSetting[Params.VideoAspectRatio] = HttpSetting[Params.VideoAspectRatio](
            communicator,
            SettingId.VIDEO_ASPECT_RATIO,
        )
        """Video aspect ratio"""

        self.video_easy_aspect_ratio: HttpSetting[Params.EasyAspectRatio] = HttpSetting[Params.EasyAspectRatio](
            communicator,
            SettingId.VIDEO_EASY_ASPECT_RATIO,
        )
        """Video easy aspect ratio"""

        self.multi_shot_easy_aspect_ratio: HttpSetting[Params.EasyAspectRatio] = HttpSetting[Params.EasyAspectRatio](
            communicator,
            SettingId.MULTI_SHOT_EASY_ASPECT_RATIO,
        )
        """Multi shot easy aspect ratio"""

        self.multi_shot_nlv_aspect_ratio: HttpSetting[Params.EasyAspectRatio] = HttpSetting[Params.EasyAspectRatio](
            communicator,
            SettingId.MULTI_SHOT_NLV_ASPECT_RATIO,
        )
        """Multi shot NLV aspect ratio"""

        self.video_mode: HttpSetting[Params.VideoMode] = HttpSetting[Params.VideoMode](
            communicator,
            SettingId.VIDEO_MODE,
        )
        """Video Mode (i.e. quality)"""

        self.timelapse_mode: HttpSetting[Params.TimelapseMode] = HttpSetting[Params.TimelapseMode](
            communicator,
            SettingId.TIMELAPSE_MODE,
        )
        """Timelapse Mode"""

        self.maxlens_mod_type: HttpSetting[Params.MaxLensModType] = HttpSetting[Params.MaxLensModType](
            communicator,
            SettingId.ADDON_MAX_LENS_MOD,
        )
        """Max lens mod? If so, what type?"""

        self.maxlens_status: HttpSetting[Params.Toggle] = HttpSetting[Params.Toggle](
            communicator,
            SettingId.ADDON_MAX_LENS_MOD_ENABLE,
        )
        """Enable / disable max lens mod"""

        self.photo_mode: HttpSetting[Params.PhotoMode] = HttpSetting[Params.PhotoMode](
            communicator,
            SettingId.PHOTO_MODE,
        )
        """Photo Mode"""

        self.framing: HttpSetting[Params.Framing] = HttpSetting[Params.Framing](
            communicator,
            SettingId.FRAMING,
        )
        """Video Framing Mode"""

        self.hindsight: HttpSetting[Params.Hindsight] = HttpSetting[Params.Hindsight](
            communicator,
            SettingId.HINDSIGHT,
        )
        """Hindsight time / disable"""

        self.photo_interval: HttpSetting[Params.PhotoInterval] = HttpSetting[Params.PhotoInterval](
            communicator,
            SettingId.PHOTO_INTERVAL,
        )
        """Interval between photo captures"""

        self.photo_duration: HttpSetting[Params.PhotoDuration] = HttpSetting[Params.PhotoDuration](
            communicator,
            SettingId.PHOTO_INTERVAL_DURATION,
        )
        """Interval between photo captures"""

        self.photo_output: HttpSetting[Params.PhotoOutput] = HttpSetting[Params.PhotoOutput](
            communicator,
            SettingId.PHOTO_OUTPUT,
        )
        """File type of photo output"""

        self.video_duration: HttpSetting[Params.VideoDuration] = HttpSetting[Params.VideoDuration](
            communicator, SettingId.VIDEO_DURATION
        )
        """If set, a video will automatically be stopped after recording for this long."""

        self.regional_format: HttpSetting[Params.RegionalFormat] = HttpSetting[Params.RegionalFormat](
            communicator, SettingId.REGIONAL_FORMAT
        )

        self.quality_control: HttpSetting[Params.QualityControl] = HttpSetting[Params.QualityControl](
            communicator, SettingId.QUALITY_CONTROL
        )

        self.camera_volume: HttpSetting[Params.Volume] = HttpSetting[Params.Volume](
            communicator, SettingId.CAMERA_VOLUME
        )

        self.lens_attachment: HttpSetting[Params.LensAttachment] = HttpSetting[Params.LensAttachment](
            communicator, SettingId.LENS_ATTACHMENT
        )

        self.setup_screensaver: HttpSetting[Params.ScreenSaverTimeout] = HttpSetting[Params.ScreenSaverTimeout](
            communicator, SettingId.SETUP_SCREEN_SAVER
        )

        self.setup_language: HttpSetting[Params.SetupLanguage] = HttpSetting[Params.SetupLanguage](
            communicator, SettingId.SETUP_LANGUAGE
        )

        self.auto_power_off: HttpSetting[Params.AutoPowerOff] = HttpSetting[Params.AutoPowerOff](
            communicator, SettingId.AUTO_POWER_OFF
        )

        self.photo_mode_v2: HttpSetting[Params.PhotoModeV2] = HttpSetting[Params.PhotoModeV2](
            communicator, SettingId.PHOTO_MODE_V2
        )

        self.video_digital_lens_v2: HttpSetting[Params.VideoLensV2] = HttpSetting[Params.VideoLensV2](
            communicator, SettingId.VIDEO_DIGITAL_LENSES_V2
        )

        self.photo_digital_lens_v2: HttpSetting[Params.PhotoLensV2] = HttpSetting[Params.PhotoLensV2](
            communicator, SettingId.PHOTO_DIGITAL_LENSES_V2
        )

        self.timelapse_digital_lens_v2: HttpSetting[Params.TimelapseLensV2] = HttpSetting[Params.TimelapseLensV2](
            communicator, SettingId.TIMELAPSE_DIGITAL_LENSES_V2
        )

        self.video_framing: HttpSetting[Params.VideoFraming] = HttpSetting[Params.VideoFraming](
            communicator, SettingId.VIDEO_FRAMING
        )

        self.multi_shot_framing: HttpSetting[Params.MultishotFraming] = HttpSetting[Params.MultishotFraming](
            communicator, SettingId.MULTI_SHOT_FRAMING
        )

        self.frame_rate: HttpSetting[Params.FrameRate] = HttpSetting[Params.FrameRate](
            communicator, SettingId.FRAME_RATE
        )

        super().__init__(communicator)

================
File: demos/python/sdk_wireless_camera_control/open_gopro/api/params.py
================
# params.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Fri Sep  6 19:25:51 UTC 2024

# pylint: disable=missing-class-docstring, no-member

"""Parameter definitions for GoPro BLE and WiFi commands for Open GoPro version 2_0"""

from __future__ import annotations

from open_gopro.enum import GoProEnum, GoProIntEnum


class Resolution(GoProIntEnum):
    NOT_APPLICABLE = 0
    RES_4K = 1
    RES_2_7K = 4
    RES_2_7K_4_3 = 6
    RES_1440 = 7
    RES_1080 = 9
    RES_4K_4_3 = 18
    RES_5K = 24
    RES_5K_4_3 = 25
    RES_5_3K_8_7_LEGACY = 26
    RES_5_3K_4_3 = 27
    RES_4K_8_7_LEGACY = 28
    RES_4K_9_16 = 29
    RES_1080_9_16 = 30
    RES_5_3K = 100
    RES_5_3K_16_9 = 101
    RES_4K_16_9 = 102
    RES_4K_4_3_TODO = 103
    RES_2_7K_16_9 = 104
    RES_2_7K_4_3_TODO = 105
    RES_1080_16_9 = 106
    RES_5_3K_8_7 = 107
    RES_4K_8_7 = 108
    RES_4K_8_7_ = 109
    RES_1080_8_7 = 110
    RES_2_7_K_8_7 = 11


class WebcamResolution(GoProIntEnum):
    NOT_APPLICABLE = 0
    RES_480 = 4
    RES_720 = 7
    RES_1080 = 12


class FPS(GoProIntEnum):
    FPS_240 = 0
    FPS_120 = 1
    FPS_100 = 2
    FPS_60 = 5
    FPS_50 = 6
    FPS_30 = 8
    FPS_25 = 9
    FPS_24 = 10
    FPS_200 = 13


class AutoOff(GoProIntEnum):
    NEVER = 0
    MIN_1 = 1
    MIN_5 = 4
    MIN_15 = 6
    MIN_30 = 7
    SEC_8 = 11
    SEC_30 = 12


class LensMode(GoProIntEnum):
    SINGLE = 0
    DUAL = 5


class VideoFOV(GoProIntEnum):
    WIDE = 0
    NARROW = 2
    SUPERVIEW = 3
    LINEAR = 4
    MAX_SUPERVIEW = 7
    LINEAR_HORIZON_LEVELING = 8
    HYPERVIEW = 9
    LINEAR_HORIZON_LOCK = 10
    MAX_HYPERVIEW = 11


class WebcamFOV(GoProIntEnum):
    WIDE = 0
    NARROW = 2
    SUPERVIEW = 3
    LINEAR = 4


class WebcamProtocol(GoProEnum):
    TS = "TS"
    RTSP = "RTSP"


class PhotoFOV(GoProIntEnum):
    NOT_APPLICABLE = 0
    HYPERVIEW = 9
    NARROW = 19
    WIDE = 101
    LINEAR = 102
    MAX_SUPERVIEW = 100
    LINEAR_HORIZON = 121


class MultishotFOV(GoProIntEnum):
    NOT_APPLICABLE = 0
    NARROW = 19
    MAX_SUPERVIEW = 100
    WIDE = 101
    LINEAR = 102


class LED(GoProIntEnum):
    LED_2 = 2
    ALL_ON = 3
    ALL_OFF = 4
    FRONT_OFF_ONLY = 5
    BLE_KEEP_ALIVE = 66


class PairState(GoProIntEnum):
    NOT_STARTED = 0
    IN_PROGRESS = 1
    FAILED = 2
    STOPPED = 3
    COMPLETED = 4


class PairType(GoProIntEnum):
    NOT_PAIRING = 0
    PAIRING_APP = 1
    PAIRING_REMOTE_CONTROL = 2
    PAIRING_BLUETOOTH = 3


class WAPState(GoProIntEnum):
    NEVER_STARTED = 0
    STARTED = 1
    ABORTED = 2
    CANCELED = 3
    COMPLETED = 4


class SDStatus(GoProIntEnum):
    OK = 0
    FULL = 1
    REMOVED = 2
    FORMAT_ERROR = 3
    BUSY = 4
    SWAPPED = 8
    UNKNOWN = 0xFF


class OTAStatus(GoProIntEnum):
    IDLE = 0
    DOWNLOADING = 1
    VERIFYING = 2
    DOWNLOAD_FAILED = 3
    VERIFY_FAILED = 4
    READY = 5
    GOPRO_APP_DOWNLOADING = 6
    GOPRO_APP_VERIFYING = 7
    GOPRO_APP_DOWNLOAD_FAILED = 8
    GOPRO_APP_VERIFY_FAILED = 9
    GOPRO_APP_READY = 10


class AnalyticsState(GoProIntEnum):
    NOT_READY = 0
    READY = 1
    ON_CONNECT = 2


class ExposureMode(GoProIntEnum):
    DISABLED = 0
    AUTO = 1
    ISO_LOCK = 2
    HEMISPHERE = 3


class AccMicStatus(GoProIntEnum):
    NOT_CONNECTED = 0
    CONNECTED = 1
    CONNECTED_AND_PLUGGED_IN = 2


class WifiBand(GoProIntEnum):
    BAND_2_4_GHZ = 0
    BAND_5_GHZ = 1
    BAND_MAX = 2


class Orientation(GoProIntEnum):
    UPRIGHT = 0
    UPSIDE_DOWN = 1
    ON_RIGHT_SIDE = 2
    ON_LEFT_SIDE = 3


class MediaModMicStatus(GoProIntEnum):
    REMOVED = 0
    ONLY = 1
    WITH_EXTERNAL = 2


class TimeWarpSpeed(GoProIntEnum):
    SPEED_15X = 0
    SPEED_30X = 1
    SPEED_60X = 2
    SPEED_150X = 3
    SPEED_300X = 4
    SPEED_900X = 5
    SPEED_1800X = 6
    SPEED_2X = 7
    SPEED_5X = 8
    SPEED_10X = 9
    SPEED_AUTO = 10
    SPEED_1X = 11
    SPEED_HALF = 12


class MaxLensMode(GoProIntEnum):
    DEFAULT = 0
    MAX_LENS = 1


class MediaModStatus(GoProIntEnum):
    SELFIE_0_HDMI_0_MEDIAMODCONNECTED_FALSE = 0
    SELFIE_0_HDMI_0_MEDIAMODCONNECTED_TRUE = 1
    SELFIE_0_HDMI_1_MEDIAMODCONNECTED_FALSE = 2
    SELFIE_0_HDMI_1_MEDIAMODCONNECTED_TRUE = 3
    SELFIE_1_HDMI_0_MEDIAMODCONNECTED_FALSE = 4
    SELFIE_1_HDMI_0_MEDIAMODCONNECTED_TRUE = 5
    SELFIE_1_HDMI_1_MEDIAMODCONNECTED_FALSE = 6
    SELFIE_1_HDMI_1_MEDIAMODCONNECTED_TRUE = 7


class Flatmode(GoProIntEnum):
    NOT_APPLICABLE = 0
    VIDEO = 12
    LOOPING = 15
    SINGLE_PHOTO = 16
    NIGHT_PHOTO = 18
    BURST_PHOTO = 19
    TIME_LAPSE_VIDEO = 13
    TIME_LAPSE_PHOTO = 20
    NIGHT_LAPSE_PHOTO = 21
    WEBCAM = 23
    TIME_WARP_VIDEO = 24
    LIVE_BURST = 25
    NIGHT_LAPSE_VIDEO = 26
    SLO_MO = 27
    UNKNOWN = 28


class Toggle(GoProIntEnum):
    ENABLE = 1
    DISABLE = 0


class HypersmoothMode(GoProIntEnum):
    OFF = 0
    ON = 1
    HIGH = 2
    BOOST = 3
    AUTO_BOOST = 4
    STANDARD = 100


class CameraControl(GoProIntEnum):
    IDLE = 0
    CAMERA = 1
    EXTERNAL = 2


class PerformanceMode(GoProIntEnum):
    MAX_PERFORMANCE = 0
    EXTENDED_BATTERY = 1
    STATIONARY = 2


class MediaFormat(GoProIntEnum):
    TIME_LAPSE_VIDEO = 13
    TIME_LAPSE_PHOTO = 20
    NIGHT_LAPSE_PHOTO = 21
    NIGHT_LAPSE_VIDEO = 26


class AntiFlicker(GoProIntEnum):
    HZ_60 = 2
    HZ_50 = 3


class CameraUxMode(GoProIntEnum):
    EASY = 0
    PRO = 1


class HorizonLeveling(GoProIntEnum):
    OFF = 0
    ON = 1
    LOCKED = 2


class PhotoEasyMode(GoProIntEnum):
    OFF = 0
    ON = 1
    SUPER_PHOTO = 100
    NIGHT_PHOTO = 101


class StarTrailLength(GoProIntEnum):
    NOT_APPLICABLE = 0
    SHORT = 1
    LONG = 2
    MAX = 3


class SystemVideoMode(GoProIntEnum):
    HIGHEST_QUALITY = 0
    EXTENDED_BATTERY = 1
    EXTENDED_BATTERY_GREEN_ICON = 101
    LONGEST_BATTERY_GREEN_ICON = 102


class BitRate(GoProIntEnum):
    STANDARD = 0
    HIGH = 1


class BitDepth(GoProIntEnum):
    BIT_8 = 0
    BIT_10 = 2


class VideoProfile(GoProIntEnum):
    STANDARD = 0
    HDR = 1
    LOG = 2


class VideoAspectRatio(GoProIntEnum):
    RATIO_4_3 = 0
    RATIO_16_9 = 1
    RATIO_8_7 = 3
    RATIO_9_16 = 4


class EasyAspectRatio(GoProIntEnum):
    WIDESCREEN = 0
    MOBILE = 1
    UNIVERSAL = 2


class VideoMode(GoProIntEnum):
    HIGHEST = 0
    STANDARD = 1
    BASIC = 2


class TimelapseMode(GoProIntEnum):
    TIMEWARP = 0
    STAR_TRAILS = 1
    LIGHT_PAINTING = 2
    VEHICLE_LIGHTS = 3
    MAX_TIMEWARP = 4
    MAX_STAR_TRAILS = 5
    MAX_LIGHT_PAINTING = 6
    MAX_VEHICLE_LIGHTS = 7


class PhotoMode(GoProIntEnum):
    SUPER = 0
    NIGHT = 1


class Framing(GoProIntEnum):
    WIDESCREEN = 0
    VERTICAL = 1
    FULL = 2


class MaxLensModType(GoProIntEnum):
    NONE = 0
    V1 = 1
    V2 = 2


class Hindsight(GoProIntEnum):
    SEC_15 = 2
    SEC_30 = 3
    OFF = 4


class PhotoInterval(GoProIntEnum):
    OFF = 0
    SEC_0_5 = 2
    SEC_1 = 3
    SEC_2 = 4
    SEC_5 = 5
    SEC_10 = 6
    SEC_30 = 7
    SEC_60 = 8
    SEC_120 = 9
    SEC_3 = 10


class PhotoDuration(GoProIntEnum):
    OFF = 0
    SEC_15 = 1
    SEC_30 = 2
    MIN_1 = 3
    MIN_5 = 4
    MIN_15 = 5
    MIN_30 = 6
    HOUR_1 = 7

    HOUR_2 = 8
    HOUR_3 = 9


class PhotoOutput(GoProIntEnum):
    STANDARD = 0
    RAW = 1
    HDR = 2
    SUPERPHOTO = 3


class PresetGroup(GoProIntEnum):
    VIDEO = 1000
    PHOTO = 1001
    TIMELAPSE = 1002


class VideoDuration(GoProIntEnum):
    DUR_15_SECONDS = 1
    DUR_30_SECONDS = 2
    DUR_1_MINUTE = 3
    DUR_5_MINUTES = 4
    DUR_15_MINUTES = 5
    DUR_30_MINUTES = 6
    DUR_1_HOUR = 7
    DUR_2_HOURS = 8
    DUR_3_HOURS = 9
    DUR_5_SECONDS = 10
    DUR_NO_LIMIT = 100


class AutoPowerOff(GoProIntEnum):
    NEVER = 0
    MIN_1 = 1
    MIN_5 = 4
    MIN_15 = 6
    MIN_30 = 7


class RegionalFormat(GoProIntEnum):
    HZ_60 = 0
    HZ_50 = 1


class QualityControl(GoProIntEnum):
    HIGHEST = 0
    STANDARD = 1
    BASIC = 2


class Volume(GoProIntEnum):
    LOW = 70
    MEDIUM = 85
    HIGH = 100


class LensModStatus(GoProIntEnum):
    INVALID = -1
    DEFAULT = 0
    MAX_LENS = 1
    MAX_LENS_2_0 = 2
    MAX_LENS_2_5 = 3
    MACRO = 4
    ANAMORPHIC = 5
    ND_4 = 6
    ND_8 = 7
    ND_16 = 8
    ND_32 = 9
    NONE = 10


class LensAttachment(GoProIntEnum):
    MAX_LENS_2_0 = 2
    MAX_LENS_2_5 = 3
    MACRO = 4
    ND_4 = 6
    ND_8 = 7
    ND_16 = 8
    ND_32 = 9
    STANDARD_LENS = 10
    AUTO_DETECT = 100


class ScreenSaverTimeout(GoProIntEnum):
    NEVER = 0
    MIN_1 = 1
    MIN_2 = 2
    MIN_3 = 3
    MIN_5 = 4


class SetupLanguage(GoProIntEnum):
    ENGLISH_US = 0
    ENGLISH_UK = 1
    ENGLISH_AUS = 2
    GERMAN = 3
    FRENCH = 4
    ITALIAN = 5
    SPANISH = 6
    SPANISH_NA = 7
    CHINESE = 8
    JAPANESE = 9
    KOREAN = 10
    PORTUGUESE = 11
    RUSSIAN = 12
    ENGLISH_IND = 13
    SWEDISH = 14


class PhotoModeV2(GoProIntEnum):
    SUPER = 0
    NIGHT = 1
    BURST = 2


class VideoLensV2(GoProIntEnum):
    WIDE = 0
    NARROW = 2
    SUPERVIEW = 3
    LINEAR = 4
    LINEAR_HORIZON_LEVELING = 8
    HYPERVIEW = 9
    LINEAR_HORIZON_LOCK = 10
    MAX_HYPERVIEW = 11
    ULTRA_SUPERVIEW = 12
    ULTRA_WIDE = 13
    ULTRA_HYPERVIEW = 100


class PhotoLensV2(GoProIntEnum):
    MP_12_WIDE = 0
    MP_12_LINEAR = 10
    MP_9_WIDE = 15
    MP_23_WIDE = 27
    MP_23_LINEAR = 28
    MP_27_WIDE = 31
    MP_27_LINEAR = 32
    MP_9_LINEAR = 37
    MP_13_LINEAR = 38
    MP_13_WIDE = 39
    MP_13_ULTRA_WIDE = 40
    MP_12_ULTRA_WIDE = 41


class TimelapseLensV2(GoProIntEnum):
    MP_27_WIDE = 31
    MP_27_LINEAR = 32


class VideoFraming(GoProIntEnum):
    FRAMING_4_3 = 0
    FRAMING_16_9 = 1
    FRAMING_8_7 = 3
    FRAMING_9_16 = 4
    FRAMING_1_1 = 6


class MultishotFraming(GoProIntEnum):
    FRAMING_4_3 = 0
    FRAMING_16_9 = 1
    FRAMING_8_7 = 3
    FRAMING_9_16 = 4


class FrameRate(GoProIntEnum):
    FRAME_RATE_240_0 = 0
    FRAME_RATE_120_0 = 1
    FRAME_RATE_100_0 = 2
    FRAME_RATE_90_0 = 3
    FRAME_RATE_60_0 = 5
    FRAME_RATE_50_0 = 6
    FRAME_RATE_30_0 = 8
    FRAME_RATE_25_0 = 9
    FRAME_RATE_24_0 = 10
    FRAME_RATE_200_0 = 13
    FRAME_RATE_400_0 = 15
    FRAME_RATE_360_0 = 16
    FRAME_RATE_300_0 = 17

================
File: demos/python/sdk_wireless_camera_control/open_gopro/api/parsers.py
================
# parsers.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Mon Jul 31 17:04:07 UTC 2023

"""Parser implementations"""

from __future__ import annotations

import datetime
import logging
from typing import Any, Callable, TypeVar, cast

import google.protobuf.json_format
from construct import Construct, Flag, Int16sb, Int16ub
from google.protobuf import descriptor
from google.protobuf.json_format import MessageToDict as ProtobufToDict
from pydantic import BaseModel

from open_gopro.constants import SettingId, StatusId
from open_gopro.enum import GoProIntEnum, enum_factory
from open_gopro.parser_interface import (
    BytesBuilder,
    BytesParser,
    BytesParserBuilder,
    GlobalParsers,
    JsonParser,
    JsonTransformer,
)
from open_gopro.types import CameraState, JsonDict, Protobuf, ResponseType
from open_gopro.util import map_keys, pretty_print

logger = logging.getLogger(__name__)

ProtobufPrinter = google.protobuf.json_format._Printer  # type: ignore # noqa
original_field_to_json = ProtobufPrinter._FieldToJsonObject

T = TypeVar("T")


class JsonParsers:
    """The collection of parsers used for additional JSON parsing"""

    class PydanticAdapter(JsonParser[BaseModel]):
        """Parse Json using a Pydantic model

        Args:
            model (type[BaseModel]): model to use for parsing
        """

        def __init__(self, model: type[BaseModel]) -> None:
            self.model = model

        def parse(self, data: JsonDict) -> BaseModel:
            """Parse json dict into model

            Args:
                data (JsonDict): data to parse

            Returns:
                BaseModel: parsed model
            """
            return self.model(**data)

    class LambdaParser(JsonParser[T]):
        """Helper class to allow parser definition using a lambda

        Args:
            parser (Callable[[JsonDict], T]): lambda to parse input
        """

        def __init__(self, parser: Callable[[JsonDict], T]) -> None:
            self._parser = parser

        def parse(self, data: JsonDict) -> T:
            """Use stored lambda parse for parsing

            Args:
                data (JsonDict): input dict to parse

            Returns:
                T: parsed output
            """
            return self._parser(data)

    class CameraStateParser(JsonParser):
        """Parse integer numbers into Enums"""

        def parse(self, data: JsonDict) -> CameraState:
            """Parse dict of integer values into human readable (i.e. enum'ed) setting / status map

            Args:
                data (JsonDict): input dict to parse

            Returns:
                CameraState: output human readable dict
            """
            parsed: dict = {}
            # Parse status and settings values into nice human readable things
            for name, id_map in [("status", StatusId), ("settings", SettingId)]:
                for k, v in data[name].items():
                    identifier = cast(ResponseType, id_map(int(k)))
                    try:
                        if not (parser_builder := GlobalParsers.get_query_container(identifier)):
                            parsed[identifier] = v
                        else:
                            parsed[identifier] = parser_builder(v)
                    except ValueError:
                        # This is the case where we receive a value that is not defined in our params.
                        # This shouldn't happen and is either a firmware bug or means the documentation needs to
                        # be updated. However, it isn't functionally critical.
                        logger.warning(f"{str(identifier)} does not contain a value {v}")
                        parsed[identifier] = v
            return parsed


class JsonTransformers:
    """Collection of Json-to-Json transformers"""

    class MapKey(JsonTransformer):
        """Map all matching keys using the input function"""

        def __init__(self, key: str, func: Callable) -> None:
            self.key = key
            self.func = func
            super().__init__()

        def transform(self, data: JsonDict) -> JsonDict:
            """Transform json, mapping keys

            Args:
                data (JsonDict): json data to transform

            Returns:
                JsonDict: transformed json data
            """
            map_keys(data, self.key, self.func)
            return data


class ProtobufDictProxy(dict):
    """Proxy a dict to appear as an object by giving its keys attribute access"""

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.__dict__ = self

    def __str__(self) -> str:
        return pretty_print(self.__dict__)

    @classmethod
    def from_proto(cls, proto_dict: dict) -> ProtobufDictProxy:
        """Build a proxy from a dictionary attr-name to value

        Args:
            proto_dict (dict): dict to build from

        Returns:
            ProtobufDictProxy: built proxy
        """

        def recurse(obj: Any) -> Any:
            # Recursion Cases
            if isinstance(obj, list):
                return [recurse(item) for item in obj]
            if isinstance(obj, dict):
                nested_dict = {}
                for key, value in obj.items():
                    nested_dict[key] = recurse(value)
                return ProtobufDictProxy(nested_dict)
            # Base Case
            return obj

        return ProtobufDictProxy(recurse(proto_dict))


class ByteParserBuilders:
    """Collection byte-to-output type parse (and optionally builders)"""

    class GoProEnum(BytesParserBuilder):
        """Parse into a GoProEnum

        Args:
            target (type[GoProIntEnum]): enum type to parse into
        """

        def __init__(self, target: type[GoProIntEnum]) -> None:
            self._container = target

        def parse(self, data: bytes) -> GoProIntEnum:
            """Parse bytes into GoPro enum

            Args:
                data (bytes): bytes to parse

            Returns:
                GoProIntEnum: parsed enum
            """
            return self._container(data[0])

        def build(self, *args: Any, **_: Any) -> bytes:
            """Build bytes from GoPro Enum

            Args:
                *args (Any): enum to use for building
                **_ (Any): not used

            Returns:
                bytes: built bytes
            """
            return bytes([int(args[0])])

    class Protobuf(BytesParser):
        """Parse into a protobuf object

        The actual returned type is a proxy to a protobuf object but it's attributes can be accessed
        using the protobuf definition

        Args:
            proto (type[Protobuf]): protobuf definition to parse (a proxy) into
        """

        def __init__(self, proto: type[Protobuf]) -> None:
            class ProtobufByteParser(BytesParser[dict]):
                """Parse bytes into a dict using the protobuf"""

                protobuf = proto

                # pylint: disable=not-callable
                def parse(self, data: bytes) -> Any:
                    response: Protobuf = self.protobuf().FromString(bytes(data))

                    # TODO can translate from Protobuf enums without relying on Protobuf internal implementation?
                    # Monkey patch the field-to-json function to use our enum translation
                    ProtobufPrinter._FieldToJsonObject = lambda self, field, value: (
                        enum_factory(field.enum_type)(value)
                        if field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_ENUM
                        else original_field_to_json(self, field, value)
                    )
                    as_dict = ProtobufToDict(response, preserving_proto_field_name=True)
                    # For any unset fields, use None
                    for key in response.DESCRIPTOR.fields_by_name:
                        if key not in as_dict:
                            as_dict[key] = None
                    # Proxy as an object
                    return ProtobufDictProxy.from_proto(as_dict)

            self._proto_parser = ProtobufByteParser()

        def parse(self, data: bytes) -> dict:
            """Parse the bytes into a Protobuf Proxy

            Args:
                data (bytes): bytes to parse

            Returns:
                dict: protobuf proxy dict which provides attribute access
            """
            return self._proto_parser.parse(data)

    class DateTime(BytesParser, BytesBuilder):
        """Handle local and non-local datetime parsing / building"""

        def build(self, obj: datetime.datetime, tzone: int | None = None, is_dst: bool | None = None) -> bytes:
            """Build bytestream from datetime and optional local arguments

            Args:
                obj (datetime.datetime): date and time
                tzone (int | None, optional): timezone (as UTC offset). Defaults to None.
                is_dst (bool | None, optional): is daylight savings time?. Defaults to None.

            Returns:
                bytes: bytestream built from datetime
            """
            byte_data = [*Int16ub.build(obj.year), obj.month, obj.day, obj.hour, obj.minute, obj.second]
            if tzone is not None and is_dst is not None:
                byte_data.extend([*Int16sb.build(tzone), *Flag.build(is_dst)])
            return bytes(byte_data)

        def parse(self, data: bytes) -> dict:
            """Parse bytestream into dict of datetime and potential timezone / dst

            Args:
                data (bytes): bytestream to parse

            Returns:
                dict: dict containing datetime
            """
            is_dst_tz = len(data) == 9
            buf = data[1:]
            year = Int16ub.parse(buf[0:2])

            dt = datetime.datetime(year, *[int(x) for x in buf[2:7]])  # type: ignore
            return (
                {"datetime": dt}
                if is_dst_tz
                else {"datetime": dt, "tzone": Int16sb.parse(buf[7:9]), "dst": bool(buf[9])}
            )

    class Construct(BytesParserBuilder):
        """Parse bytes into a construct object

        Args:
            construct (Construct): construct definition
        """

        def __init__(self, construct: Construct) -> None:
            self._construct = self._construct_adapter_factory(construct)

        @classmethod
        def _construct_adapter_factory(cls, target: Construct) -> BytesParserBuilder:
            """Build a construct parser adapter from a construct

            Args:
                target (Construct): construct to use for parsing and building

            Returns:
                BytesParserBuilder: instance of generated class
            """

            class ParserBuilder(BytesParserBuilder):
                """Adapt the construct for our interface"""

                container = target

                def parse(self, data: bytes) -> Any:
                    return self.container.parse(data)

                def build(self, *args: Any, **kwargs: Any) -> bytes:
                    return self.container.build(*args, **kwargs)

            return ParserBuilder()

        def parse(self, data: bytes) -> Construct:
            """Parse bytes into construct container

            Args:
                data (bytes): bytes to parse

            Returns:
                Construct: construct container
            """
            return self._construct.parse(data)

        def build(self, obj: Construct) -> bytes:
            """Built bytes from filled out construct container

            Args:
                obj (Construct): construct container

            Returns:
                bytes: built bytes
            """
            return self._construct.build(obj)

    class DeprecatedMarker(BytesParserBuilder[str]):
        """Used to return "DEPRECATED" when a deprecated setting / status is attempted to be parsed / built"""

        def parse(self, data: bytes) -> str:
            """Return string indicating this ID is deprecated

            Args:
                data (bytes): ignored

            Returns:
                str: "DEPRECATED"
            """
            return "DEPRECATED"

        def build(self, obj: Any) -> bytes:
            """Return empty bytes since this ID is deprecated

            Args:
                obj (Any): ignored

            Returns:
                bytes: empty
            """
            return bytes()

================
File: demos/python/sdk_wireless_camera_control/open_gopro/ble/adapters/__init__.py
================
# __init__.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Tue Sep  7 21:35:53 UTC 2021

"""Adapter Implementations for the Open GoPro BLE Interface"""

from .bleak_wrapper import BleakWrapperController

================
File: demos/python/sdk_wireless_camera_control/open_gopro/ble/adapters/bleak_wrapper.py
================
# bleak_wrapper.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Tue Sep  7 21:35:53 UTC 2021

"""Manage a Bluetooth connection using bleak."""

from __future__ import annotations

import asyncio
import logging
import platform
import tempfile
from pathlib import Path
from typing import Any, Callable, Optional, Pattern

import bleak
import pexpect
from bleak.backends.characteristic import BleakGATTCharacteristic
from bleak.backends.device import BLEDevice as BleakDevice
from bleak.backends.scanner import AdvertisementData
from packaging.version import Version

from open_gopro.ble import (
    BLEController,
    BleUUID,
    Characteristic,
    CharProps,
    Descriptor,
    FailedToFindDevice,
    GattDB,
    NotiHandlerType,
    Service,
    UUIDs,
)
from open_gopro.exceptions import ConnectFailed
from open_gopro.util import Singleton

logger = logging.getLogger(__name__)

bleak_props_to_enum = {
    "broadcast": CharProps.BROADCAST,
    "read": CharProps.READ,
    "write-without-response": CharProps.WRITE_NO_RSP,
    "write": CharProps.WRITE_YES_RSP,
    "notify": CharProps.NOTIFY,
    "indicate": CharProps.INDICATE,
    "authenticated-signed-writes": CharProps.AUTH_SIGN_WRITE,
    "extended-properties": CharProps.EXTENDED,
}


def uuid2bleak_string(uuid: BleUUID) -> str:
    """Convert a BleUUID object to a string representation to appease bleak

    Bleak identifies UUID's by str(). Since BleUUID has overridden that method, we manually convert to the
    string representation that bleak expects.

    Args:
        uuid (BleUUID): uuid to convert

    Returns:
        str: bleakful string representation
    """
    return f"{uuid.hex[:8]}-{uuid.hex[8:12]}-{uuid.hex[12:16]}-{uuid.hex[16:20]}-{uuid.hex[20:]}"


class BleakWrapperController(BLEController[BleakDevice, bleak.BleakClient], Singleton):
    """Wrapper around bleak to manage a Bluetooth connection.

    Note, this is a singleton.

    Args:
        exception_handler (Callable | None): Used to catch asyncio exceptions from other tasks. Defaults to None.
    """

    def __init__(self, exception_handler: Callable | None = None) -> None:
        BLEController.__init__(self, exception_handler)

    async def read(self, handle: bleak.BleakClient, uuid: BleUUID) -> bytearray:
        """Read data from a BleUUID.

        Args:
            handle (bleak.BleakClient): client to read from
            uuid (BleUUID): uuid to read

        Returns:
            bytearray: read data
        """
        logger.debug(f"Reading from {uuid}")
        response = await handle.read_gatt_char(uuid2bleak_string(uuid))
        logger.debug(f'Received response on BleUUID [{uuid}]: {response.hex( ":")}')
        return response

    async def write(self, handle: bleak.BleakClient, uuid: BleUUID, data: bytes) -> None:
        """Write data to a BleUUID.

        Args:
            handle (bleak.BleakClient): Device to write to
            uuid (BleUUID): characteristic BleUUID to write to
            data (bytes): data to write
        """
        logger.debug(f"Writing to {uuid}: {uuid.hex}")
        await handle.write_gatt_char(uuid2bleak_string(uuid), data, response=True)

    async def scan(
        self, token: Pattern, timeout: int = 5, service_uuids: Optional[list[BleUUID]] = None
    ) -> BleakDevice:
        """Scan for a regex in advertising data strings, optionally filtering on service BleUUID's

        Args:
            token (Pattern): Regex to look for when scanning.
            timeout (int): Time to scan. Defaults to 5.
            service_uuids (Optional[list[BleUUID]]): The list of BleUUID's to filter on. Defaults to None.

        Raises:
            FailedToFindDevice: scan timed out without finding device

        Returns:
            BleakDevice: The first matched device that was discovered
        """
        stop_event = asyncio.Event()
        logger.info(f"Scanning for {token.pattern} bluetooth devices...")
        devices: dict[str, BleakDevice] = {}
        uuids = [] if service_uuids is None else [uuid2bleak_string(uuid) for uuid in service_uuids]

        def scan_callback(device: BleakDevice, adv_data: AdvertisementData) -> None:
            """Only keep devices that have a device name token

            Args:
                device (BleakDevice): discovered device
                adv_data (AdvertisementData): advertisement (and / or scan response) data
            """
            if (name := adv_data.local_name or device.name) and name not in devices:
                devices[name] = device
                logger.info(f"\tDiscovered: {device}")
                stop_event.set()

        # Now get list of connectable advertisements
        async with bleak.BleakScanner(timeout=timeout, detection_callback=scan_callback, service_uuids=uuids):
            # The bleak scan timeout appears to not be used at least in some versions of bleak
            try:
                await asyncio.wait_for(stop_event.wait(), timeout)
            except asyncio.TimeoutError as e:
                raise FailedToFindDevice from e
        # Now look for our matching device(s)
        if not (matched_devices := [device for name, device in devices.items() if token.match(name)]):
            raise FailedToFindDevice
        logger.info(f"Found {len(matched_devices)} matching devices.")
        # If there's more than 1, the first one gets lucky.
        return matched_devices[0]

    async def connect(self, disconnect_cb: Callable, device: BleakDevice, timeout: int = 15) -> bleak.BleakClient:
        """Connect to a device.

        Args:
            disconnect_cb (Callable): function called when a disconnect is received
            device (BleakDevice): Device to connect to
            timeout (int): How long to try connecting before timing out and raising exception. Defaults to 15.

        Raises:
            ConnectFailed: Connection was not established

        Returns:
            bleak.BleakClient: Connected device
        """

        class ConnectSession:
            """Catch connection failures and multiplex disconnect handler callback

            Args:
                client_cb (Callable): client's disconnect callback
            """

            def __init__(self, client_cb: Callable) -> None:
                self._disconnected = asyncio.Event()
                self._disconnected.clear()
                self._client_cb = client_cb
                self._should_use_client_cb = False

            def disconnect_cb(self, *args: Any) -> None:
                """Multiplex between client and during-connection disconnect handler callback

                Args:
                    *args (Any): passed through
                """
                # pylint: disable=expression-not-assigned
                self._client_cb(args) if self._should_use_client_cb else self._connecting_cb(args)

            @property
            def did_fail(self) -> bool:
                """Did the connection fail during establishment?

                Returns:
                    bool: True if it failed, False otherwise
                """
                return self._disconnected.is_set()

            def _connecting_cb(self, _: Any) -> None:
                """Disconnect handler which is only used while connection is being established.

                Will be set to App's passed-in disconnect handler once connection is established
                """
                # From sniffer capture analysis, this is always due to the slave not receiving the master's
                # connection request. This is (potentially) normal BLE behavior.
                self._disconnected.set()

            def use_client_cb(self) -> None:
                """Use the client's requested connection handler callback when a disconnection is caught"""
                self._should_use_client_cb = True

            async def catch_connection_failure(self) -> None:
                """Disconnection callback to be used during connection establishment"""
                await self._disconnected.wait()

        logger.info(f"Establishing BLE connection to {device}...")

        connect_session = ConnectSession(disconnect_cb)
        client = bleak.BleakClient(
            device, disconnected_callback=connect_session.disconnect_cb, use_cached=False, timeout=timeout
        )
        exception = None
        try:
            task_connect: asyncio.Task = asyncio.create_task(client.connect(timeout=timeout), name="connect")
            task_disconnected: asyncio.Task = asyncio.create_task(
                connect_session.catch_connection_failure(), name="disconnect"
            )
            finished, unfinished = await asyncio.wait(
                [task_connect, task_disconnected], return_when=asyncio.FIRST_COMPLETED
            )
            for task in finished:
                if exception := task.exception():
                    if isinstance(task.exception(), asyncio.exceptions.TimeoutError):
                        exception = Exception("Connection request timed out")
                    # Completion of these is tasks mutually exclusive so safe to stop now
                    break
            for task in unfinished:
                task.cancel()
            if connect_session.did_fail:
                exception = Exception("Connection failed during establishment..")
            else:
                connect_session.use_client_cb()
        except Exception as e:  # pylint: disable=broad-except
            exception = e

        if exception:
            logger.warning(exception)
            raise ConnectFailed("BLE", 1, 1) from exception
        return client

    async def pair(self, handle: bleak.BleakClient) -> None:
        """Pair to a device after connection.

        This is required for Windows and not allowed on Mac.
        Linux requires a separate process to interact with bluetoothctl to accept pairing.

        Args:
            handle (bleak.BleakClient): Device to pair to
        """
        logger.debug("Attempting to pair...")

        if (OS := platform.system()) == "Linux":
            temp_file = Path(tempfile.gettempdir()) / "pexpect.log"
            with open(temp_file, "wb") as fp:
                logger.info("Pairing with bluetoothctl")
                # Manually control bluetoothctl on Linux
                bluetoothctl = pexpect.spawn("bluetoothctl")
                bluetoothctl.logfile = fp
                bluetoothctl.expect("Agent registered")
                # Get the version
                bluetoothctl.sendline("version")
                bluetoothctl.expect(r"Version")
                bluetoothctl.expect(r"\n")
                version = Version(bluetoothctl.before.decode("utf-8").strip())
                # First see if we are already paired
                if version >= Version("5.66"):
                    bluetoothctl.sendline("devices Paired")
                    bluetoothctl.expect("devices Paired")
                else:
                    bluetoothctl.sendline("paired-devices")
                    bluetoothctl.expect("paired-devices")
                bluetoothctl.expect(r"#")
                for device in bluetoothctl.before.decode("utf-8").splitlines():
                    if "Device" in device and device.split()[1] == handle.address:
                        break  # The device is already paired
                else:
                    # We're not paired so do it now
                    bluetoothctl.sendline(f"pair {handle.address}")
                    if (match := bluetoothctl.expect(["Accept pairing", "Pairing successful"])) == 0:
                        bluetoothctl.sendline("yes")
                        bluetoothctl.expect("Pairing successful")
                    elif match == 1:  # We received pairing successful so nothing else to do
                        pass

            logger.debug(temp_file.read_bytes().decode("utf-8"))

        elif OS == "Darwin":
            # No pairing on Mac
            pass
        else:
            await handle.pair()

        logger.debug("Pairing complete!")

    async def enable_notifications(self, handle: bleak.BleakClient, handler: NotiHandlerType) -> None:
        """Enable all notifications.

        Search through all characteristics and enable any that have notification property.

        Args:
            handle (bleak.BleakClient): Device to enable notifications for
            handler (NotiHandlerType): Notification callback handler
        """

        def bleak_notification_cb_adapter(characteristic: BleakGATTCharacteristic, data: bytearray) -> None:
            """Adapt bleak notification callback signature to our interface signature

            Args:
                characteristic (BleakGATTCharacteristic): characteristic that notification was received on
                data (bytearray): data received as part of notification
            """
            handler(characteristic.handle, data)

        logger.info("Enabling notifications...")
        for service in handle.services:
            for char in service.characteristics:
                if "notify" in char.properties:
                    logger.debug(f"Enabling notification on char {char.uuid}")
                    await handle.start_notify(char, bleak_notification_cb_adapter)
        logger.info("Done enabling notifications")

    async def discover_chars(self, handle: bleak.BleakClient, uuids: type[UUIDs] | None = None) -> GattDB:
        """Discover all characteristics for a connected handle.

        By default, the BLE controller only knows Spec-Defined BleUUID's so any additional BleUUID's should
        be passed in with the uuids argument

        Args:
            handle (bleak.BleakClient): BLE handle to discover for
            uuids (type[UUIDs] | None): Additional BleUUID information to use when building the
                Gatt Database. Defaults to None.

        Returns:
            GattDB: Gatt Database
        """

        def bleak_props_adapter(bleak_props: list[str]) -> CharProps:
            """Convert a list of bleak string properties into a CharProps

            Args:
                bleak_props (list[str]): bleak strings to convert

            Returns:
                CharProps: converted Enum
            """
            props = CharProps.NONE
            for prop in bleak_props:
                props |= bleak_props_to_enum[prop]
            return props

        logger.info("Discovering characteristics...")
        services: list[Service] = []
        for service in handle.services:
            service_uuid = (
                uuids[service.uuid]
                if uuids and service.uuid in uuids
                else BleUUID(service.description, hex=service.uuid)
            )
            logger.debug(f"[Service] {service_uuid}")

            # Loop over all chars in service
            chars: list[Characteristic] = []
            for char in service.characteristics:
                # Get any descriptors if they exist
                descriptors: list[Descriptor] = []
                for descriptor in char.descriptors:
                    descriptors.append(
                        Descriptor(
                            handle=descriptor.handle,
                            uuid=(
                                uuids[descriptor.uuid]
                                if uuids and descriptor.uuid in uuids
                                else BleUUID(descriptor.description, hex=descriptor.uuid)
                            ),
                            value=await handle.read_gatt_descriptor(descriptor.handle),
                        )
                    )
                # Create new characteristic
                chars.append(
                    Characteristic(
                        handle=char.handle,
                        uuid=(
                            uuids[char.uuid]
                            if uuids and char.uuid in uuids
                            else BleUUID(char.description, hex=char.uuid)
                        ),
                        props=bleak_props_adapter(char.properties),
                        init_descriptors=descriptors,
                    )
                )
                logger.debug(f"\t[Characteristic] {chars[-1]}")

            # Create new service
            services.append(Service(uuid=service_uuid, start_handle=service.handle, init_chars=chars))

        logger.info("Done discovering characteristics!")
        return GattDB(services)

    async def disconnect(self, handle: bleak.BleakClient) -> None:
        """Terminate a BLE connection.

        Args:
            handle (bleak.BleakClient): client to disconnect from
        """
        if handle.is_connected:
            logger.info("Disconnecting...")
            await handle.disconnect()
            # Disconnect handler registered during connect will be asynchronously called
        logger.info("Device disconnected!")

================
File: demos/python/sdk_wireless_camera_control/open_gopro/ble/__init__.py
================
# __init__.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Tue Sep  7 21:35:53 UTC 2021

"""Open GoPro BLE Interface interface and implementation

isort:skip_file
"""

from open_gopro.exceptions import FailedToFindDevice, ConnectFailed, ConnectionTerminated, ResponseTimeout
from .services import GattDB, Characteristic, Descriptor, Service, BleUUID, UUIDs, CharProps
from .controller import BleDevice, BleHandle, NotiHandlerType, DisconnectHandlerType, BLEController
from .client import BleClient
from .adapters import BleakWrapperController

================
File: demos/python/sdk_wireless_camera_control/open_gopro/ble/client.py
================
# client.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Tue Sep  7 21:35:53 UTC 2021

"""Generic BLE Client definition that is composed of a BLE Controller."""

from __future__ import annotations

import logging
import re
from pathlib import Path
from typing import Generic, Optional, Pattern

from open_gopro.ble import BleUUID
from open_gopro.exceptions import ConnectFailed, FailedToFindDevice

from .controller import (
    BLEController,
    BleDevice,
    BleHandle,
    DisconnectHandlerType,
    NotiHandlerType,
)
from .services import BleUUID, GattDB, UUIDs

logger = logging.getLogger(__name__)


class BleClient(Generic[BleHandle, BleDevice]):
    """A BLE device that is to be connected to.

    Args:
        controller (BLEController): controller implementation to use for this client
        disconnected_cb (DisconnectHandlerType): disconnected callback
        notification_cb (NotiHandlerType): notification callback
        target (tuple[Pattern | BleDevice, list[BleUUID] | None]): Tuple of:
            (device, service_uuids) where device is the BLE device (or regex) to connect to and
            service_uuids is a list of service uuid's to filter for
        uuids (type[UUIDs] | None): Additional UUIDs that will be used when discovering characteristic.
            Defaults to None in which case any unknown UUIDs will be set to "unknown".

    Raises:
        ValueError: Must pass a valid target
    """

    def __init__(
        self,
        controller: BLEController,
        disconnected_cb: DisconnectHandlerType,
        notification_cb: NotiHandlerType,
        target: tuple[Pattern | BleDevice, list[BleUUID] | None],
        uuids: type[UUIDs] | None = None,
    ) -> None:
        if target is None:
            raise ValueError("Target can not be None!")
        if isinstance(target[0], str):
            self._target = re.compile(target[0])
        else:
            self._target = target[0]  # type: ignore
        self._service_uuids: list[BleUUID] = target[1] or []
        self._controller = controller
        self._disconnected_cb = disconnected_cb
        self._notification_cb = notification_cb
        self._gatt_table: Optional[GattDB] = None
        self._device: Optional[BleDevice] = None
        self._handle: Optional[BleHandle] = None
        self._identifier: Optional[str] = None if isinstance(self._target, Pattern) else str(self._target)
        self.uuids = uuids

    async def _find_device(self, timeout: int = 5, retries: int = 30) -> None:
        """Scan for the target device.

        Args:
            timeout (int): how long (seconds) to scan before considering the attempt a failure. Defaults to 5.
            retries (int): How many attempts before giving up. Defaults to 30.

        Raises:
            FailedToFindDevice: No matching device was found
        """
        self._device = None
        assert isinstance(self._target, Pattern)
        for retry in range(1, retries):
            try:
                self._device = await self._controller.scan(self._target, timeout, self._service_uuids)
                return
            except FailedToFindDevice:
                logger.warning(f"Failed to find a device in {timeout} seconds. Retrying #{retry}")
        raise FailedToFindDevice

    async def open(self, timeout: int = 10, retries: int = 5) -> None:
        """Open the client resource so that it is ready to send and receive data.

        Args:
            timeout (int): How long to try connecting (in seconds) before retrying. Defaults to 10.
            retries(int): How many retries to attempt before giving up. Defaults to 5

        Raises:
            ConnectFailed: The BLE connection was not able to establish
        """
        # If we need we need to find the device to connect
        if isinstance(self._target, Pattern):
            await self._find_device(timeout, retries)
        # Otherwise we already have it
        else:
            self._device = self._target
        self._identifier = str(self._device)

        logger.info("Establishing the BLE connection")
        for retry in range(1, retries):
            try:
                self._handle = await self._controller.connect(self._disconnected_cb, self._device, timeout=timeout)
                break
            except ConnectFailed as e:
                logger.warning(f"Failed to connect. Retrying #{retry}")
                if retry == retries - 1:
                    raise ConnectFailed("BLE", timeout, retries) from e

        assert self._handle is not None
        # Attempt to pair
        await self._controller.pair(self._handle)
        # Discover characteristics
        self._gatt_table = await self._controller.discover_chars(self._handle, self.uuids)
        # Enable all GATT notifications
        await self._controller.enable_notifications(self._handle, self._notification_cb)

    async def close(self) -> None:
        """Close the client resource.

        This should always be called before exiting.
        """
        if self.is_connected:
            logger.info("Terminating the BLE connection")
            await self._controller.disconnect(self._handle)
            self._handle = None
        else:
            logger.debug("BLE already disconnected")

    async def read(self, uuid: BleUUID) -> bytes:
        """Read byte data from a characteristic (identified by BleUUID)

        Args:
            uuid (BleUUID): characteristic to read

        Returns:
            bytes: byte data that was read
        """
        return await self._controller.read(self._handle, uuid)

    async def write(self, uuid: BleUUID, data: bytes) -> None:
        """Write byte data to a characteristic (identified by BleUUID)

        Args:
            uuid (BleUUID): characteristic to write to
            data (bytes): byte data to write
        """
        await self._controller.write(self._handle, uuid, data)

    @property
    def gatt_db(self) -> GattDB:
        """Return the attribute table

        Raises:
            RuntimeError: GATT table hasn't been discovered

        Returns:
            GattDB: table of BLE attributes
        """
        if not self._gatt_table:
            raise RuntimeError("GATT table has not yet been discovered")
        return self._gatt_table

    @property
    def identifier(self) -> Optional[str]:
        """A string that identifies the GoPro

        Returns:
            Optional[str]: identifier or None if client has not yet been discovered
        """
        return self._identifier

    @property
    def is_connected(self) -> bool:
        """Is BLE currently connected?

        Returns:
            bool: True if yes, False if no
        """
        return self._handle is not None

    @property
    def is_discovered(self) -> bool:
        """Has the target been discovered (via BLE scanning)?

        Returns:
            bool: True if yes, False if no
        """
        return self._device is not None

    def services_as_csv(self, file: Path = Path("services.csv")) -> None:
        """Dump the services as a .csv

        Args:
            file (Path): Where to dump the csv. Defaults to Path("services.csv").
        """
        assert self.gatt_db is not None
        self.gatt_db.dump_to_csv(file)

================
File: demos/python/sdk_wireless_camera_control/open_gopro/ble/controller.py
================
# controller.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Tue Sep  7 21:35:53 UTC 2021

"""BLE Controller Interface Definition."""

from __future__ import annotations

import logging
from abc import ABC, abstractmethod
from typing import Callable, Generic, Optional, Pattern, TypeVar

from .services import BleUUID, GattDB, UUIDs

logger = logging.getLogger(__name__)

BleDevice = TypeVar("BleDevice")
BleHandle = TypeVar("BleHandle")
NotiHandlerType = Callable[[int, bytearray], None]
DisconnectHandlerType = Callable[[BleDevice], None]


class BLEController(ABC, Generic[BleDevice, BleHandle]):
    """Interface definition for a BLE driver to be used by GoPro."""

    def __init__(self, exception_handler: Optional[Callable] = None) -> None:
        self._exception_handler = exception_handler

    @abstractmethod
    async def read(self, handle: BleHandle, uuid: BleUUID) -> bytes:
        """Read a bytestream response from a BleUUID.

        Args:
            handle (BleHandle): handle to pair to
            uuid (BleUUID): BleUUID to read from

        Returns:
            bytes: response
        """

    @abstractmethod
    async def write(self, handle: BleHandle, uuid: BleUUID, data: bytes) -> None:
        """Write a bytestream to a BleUUID.

        Args:
            handle (BleHandle): handle to pair to
            uuid (BleUUID): BleUUID to write to
            data (bytes): bytestream to write
        """

    @abstractmethod
    async def scan(self, token: Pattern, timeout: int = 5, service_uuids: list[BleUUID] | None = None) -> BleDevice:
        """Scan BLE device with a regex in it's device name.

        Args:
            token (Pattern): Regex to scan for
            timeout (int): Time to scan (in seconds) before considering scanning as failed. Defaults to 5.
            service_uuids (list[BleUUID] | None): The list of BleUUID's to filter on. Defaults to None.

        Returns:
            BleDevice: discovered device (shall not be multiple devices)
        """

    @abstractmethod
    async def connect(self, disconnect_cb: DisconnectHandlerType, device: BleDevice, timeout: int = 15) -> BleHandle:
        """Connect to a BLE device.

        Args:
            disconnect_cb (DisconnectHandlerType): function to call when disconnect is received
            device (BleDevice): device to connect to
            timeout (int): How long to attempt connecting before giving up. Defaults to 15.

        Returns:
            BleHandle: handle that has been connected to
        """

    @abstractmethod
    async def pair(self, handle: BleHandle) -> None:
        """Pair to an already connected handle.

        Args:
            handle (BleHandle): handle to pair to
        """

    @abstractmethod
    async def enable_notifications(self, handle: BleHandle, handler: NotiHandlerType) -> None:
        """Enable notifications for all notifiable characteristics.

        The handler is used to register for notifications. It will be called when a a notification
        is received.

        Args:
            handle (BleHandle): handle to enable notifications on
            handler (NotiHandlerType): notification handler
        """

    @abstractmethod
    async def discover_chars(self, handle: BleHandle, uuids: type[UUIDs] | None = None) -> GattDB:
        """Discover all characteristics for a connected handle.

        By default, the BLE controller only knows Spec-Defined BleUUID's so any additional BleUUID's should
        be passed in with the uuids argument

        Args:
            handle (BleHandle): BLE handle to discover for
            uuids (type[UUIDs] | None): Additional BleUUID information to use when building the Gatt Database.
                Defaults to None.

        Returns:
            GattDB: Gatt Database
        """

    @abstractmethod
    async def disconnect(self, handle: BleHandle) -> None:
        """Terminate the BLE connection.

        Args:
            handle (BleHandle): handle to disconnect from
        """

================
File: demos/python/sdk_wireless_camera_control/open_gopro/ble/services.py
================
# services.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Wed, Sep  1, 2021  5:05:50 PM

"""Objects to nicely interact with BLE services, characteristics, and attributes."""

from __future__ import annotations

import csv
import json
import logging
import uuid
from dataclasses import InitVar, asdict, dataclass
from enum import IntEnum, IntFlag
from pathlib import Path
from typing import (
    Any,
    Final,
    Generator,
    Iterator,
    Mapping,
    Optional,
    Union,
    no_type_check,
)

logger = logging.getLogger(__name__)

BLE_BASE_UUID: Final = "0000{}-0000-1000-8000-00805F9B34FB"


class CharProps(IntFlag):
    """BLE Spec-Defined Characteristic Property bitmask values"""

    NONE = 0x00
    BROADCAST = 0x01
    READ = 0x02
    WRITE_NO_RSP = 0x04
    WRITE_YES_RSP = 0x08
    NOTIFY = 0x10
    INDICATE = 0x20
    AUTH_SIGN_WRITE = 0x40
    EXTENDED = 0x80
    NOTIFY_ENCRYPTION_REQ = 0x100
    INDICATE_ENCRYPTION_REQ = 0x200


class SpecUuidNumber(IntEnum):
    """BLE Spec-Defined BleUUID Number values as ints"""

    PRIMARY_SERVICE = 0x2800
    SECONDARY_SERVICE = 0x2801
    INCLUDE = 0x2802
    CHAR_DECLARATION = 0x2803
    CHAR_EXTENDED_PROPS = 0x2900
    CHAR_USER_DESCR = 0x2901
    CLIENT_CHAR_CONFIG = 0x2902
    SERVER_CHAR_CONFIG = 0x2903
    CHAR_FORMAT = 0x2904
    CHAR_AGGREGATE_FORMAT = 0x2905


class BleUUID(uuid.UUID):
    """An extension of the standard UUID to associate a string name with the UUID and allow 8-bit UUID input

    Can only be initialized with one of [hex, bytes, bytes_le, int]

    Args:
        name (str): human readable name
        format (BleUUID.Format): 16 or 128 bit format. Defaults to BleUUID.Format.BIT_128.
        hex (str | None): build from hex string. Defaults to None.
        bytes (bytes | None): build from big-endian bytes. Defaults to None.
        bytes_le (bytes | None): build from little-endian bytes. Defaults to None.
        int (int | None): build from int. Defaults to None.

    Raises:
        ValueError: Attempt to initialize with more than one option
        ValueError: Badly formed input
    """

    class Format(IntEnum):
        """Used to specify 8-bit or 128-bit UUIDs"""

        BIT_16 = 2
        BIT_128 = 16

    # pylint: disable=redefined-builtin
    def __init__(
        self,
        name: str,
        format: BleUUID.Format = Format.BIT_128,
        hex: str | None = None,
        bytes: bytes | None = None,
        bytes_le: bytes | None = None,
        int: int | None = None,
    ) -> None:
        self.name: str
        if format is BleUUID.Format.BIT_16:
            if [hex, bytes, bytes_le, int].count(None) != 3:
                raise ValueError("Only one of [hex, bytes, bytes_le, int] can be set.")
            if hex:
                if len(hex) != 4:
                    raise ValueError("badly formed 8-bit hexadecimal UUID string")
                hex = BLE_BASE_UUID.format(hex)
            elif bytes:
                if len(bytes) != 2:
                    raise ValueError("badly formed 8-bit byte input")
                bytes = uuid.UUID(hex=BLE_BASE_UUID.format(bytes.hex())).bytes
            elif bytes_le:
                raise ValueError("byte_le not possible with 8-bit UUID")
            elif int:
                int = uuid.UUID(hex=BLE_BASE_UUID.format(int.to_bytes(2, "big").hex())).int

        object.__setattr__(self, "name", name)  # needed to work around immutability in base class
        super().__init__(hex=hex, bytes=bytes, bytes_le=bytes_le, int=int)

    @property
    def format(self) -> BleUUID.Format:
        """Is this a 16 bit or 128 bit UUID?

        Returns:
            BleUUID.Format: format of UUID
        """
        return BleUUID.Format.BIT_16 if len(self.hex) == BleUUID.Format.BIT_16 else BleUUID.Format.BIT_128

    def __str__(self) -> str:  # pylint: disable=missing-return-doc
        return self.name if self.name else self.hex

    def __repr__(self) -> str:
        return self.__str__()


@dataclass
class Descriptor:
    """A characteristic descriptor.

    Args:
        handle (int) : the handle of the attribute table that the descriptor resides at
        uuid (BleUUID): BleUUID of this descriptor
        value (bytes) : the byte stream value of the descriptor
    """

    handle: int
    uuid: BleUUID
    value: Optional[bytes] = None

    def __str__(self) -> str:
        return json.dumps(asdict(self), indent=4, default=str)

    @property
    def name(self) -> str:
        """What is the human-readable name of this characteristic?

        Returns:
            str: characteristic's name
        """
        return self.uuid.name


@dataclass
class Characteristic:
    """A BLE characteristic.

    Args:
        handle (int) : the handle of the attribute table that the characteristic resides at
        uuid (BleUUID) : the BleUUID of the characteristic
        props (CharProps) : the characteristic's properties (READ, WRITE, NOTIFY, etc)
        value (bytes | None) : the current byte stream value of the characteristic value
        init_descriptors (list[Descriptor] | None) : Descriptors known at initialization (can also be
            set later using the descriptors property)
        descriptor_handle (int | None) : handle of this characteristic's declaration descriptor. If not
            passed, defaults to handle + 1
    """

    handle: int
    uuid: BleUUID
    props: CharProps
    value: bytes | None = None
    init_descriptors: InitVar[list[Descriptor] | None] = None
    descriptor_handle: int | None = None

    def __post_init__(self, init_descriptors: Optional[list[Descriptor]]) -> None:
        self._descriptors: dict[BleUUID, Descriptor] = {}
        # Mypy should eventually support this: see https://github.com/python/mypy/issues/3004
        self.descriptors = init_descriptors or []  # type: ignore
        if self.descriptor_handle is None:
            self.descriptor_handle = self.handle + 1

    def __str__(self) -> str:
        return f"{self.name} @ handle {self.handle}: {self.props.name}"

    @property
    def descriptors(self) -> dict[BleUUID, Descriptor]:
        """Return uuid-to-descriptor mapping

        Returns:
            dict[BleUUID, Descriptor]: dictionary of descriptors indexed by BleUUID
        """
        return self._descriptors

    @descriptors.setter
    def descriptors(self, descriptors: list[Descriptor]) -> None:
        for descriptor in descriptors:
            self._descriptors[descriptor.uuid] = descriptor

    @property
    def name(self) -> str:
        """What is the human-readable name of this characteristic?

        Returns:
            str: characteristic's name
        """
        return self.uuid.name

    @property
    def is_readable(self) -> bool:
        """Does this characteristic have readable property?

        Returns:
            bool: True if readable, False if not
        """
        return CharProps.READ in self.props

    @property
    def is_writeable_with_response(self) -> bool:
        """Does this characteristic have writeable-with-response property?

        Returns:
            bool: True if writeable-with-response, False if not
        """
        return CharProps.WRITE_YES_RSP in self.props

    @property
    def is_writeable_without_response(self) -> bool:
        """Does this characteristic have writeable-without-response property?

        Returns:
            bool: True if writeable-without-response, False if not
        """
        return CharProps.WRITE_NO_RSP in self.props

    @property
    def is_writeable(self) -> bool:
        """Does this characteristic have writeable property?

        That is, does it have writeable-with-response or writeable-without-response property

        Returns:
            bool: True if writeable, False if not
        """
        return self.is_writeable_with_response or self.is_writeable_without_response

    @property
    def is_notifiable(self) -> bool:
        """Does this characteristic have notifiable property?

        Returns:
            bool: True if notifiable, False if not
        """
        return CharProps.NOTIFY in self.props

    @property
    def is_indicatable(self) -> bool:
        """Does this characteristic have indicatable property?

        Returns:
            bool: True if indicatable, False if not
        """
        return CharProps.INDICATE in self.props

    @property
    def cccd_handle(self) -> int:
        """What is this characteristics CCCD (client characteristic configuration descriptor) handle

        Returns:
            int: the CCCD handle
        """
        return self._descriptors[UUIDs.CLIENT_CHAR_CONFIG].handle


@dataclass
class Service:
    """A BLE service or grouping of Characteristics.

    Args:
        uuid (BleUUID) : the service's BleUUID
        start_handle(int): the attribute handle where the service begins
        end_handle(int): the attribute handle where the service ends. Defaults to 0xFFFF.
        init_chars (list[Characteristic]) : list of characteristics known at service instantiation. Can be set
            later with the characteristics property
    """

    uuid: BleUUID
    start_handle: int
    end_handle: int = 0xFFFF
    init_chars: InitVar[Optional[list[Characteristic]]] = None

    def __post_init__(self, init_characteristics: Optional[list[Characteristic]]) -> None:
        self._characteristics: dict[BleUUID, Characteristic] = {}
        # Mypy should eventually support this: see https://github.com/python/mypy/issues/3004
        self.characteristics = init_characteristics or []  # type: ignore

    def __str__(self) -> str:
        return self.name

    @property
    def characteristics(self) -> dict[BleUUID, Characteristic]:
        """Return uuid-to-characteristic mapping

        Returns:
            dict[BleUUID, Characteristic]: Dict of characteristics indexed by uuid
        """
        return self._characteristics

    @characteristics.setter
    def characteristics(self, characteristics: list[Characteristic]) -> None:
        for characteristic in characteristics:
            self._characteristics[characteristic.uuid] = characteristic

    @property
    def name(self) -> str:
        """What is the human-readable name of this characteristic?

        Returns:
            str: characteristic's name
        """
        return self.uuid.name


class GattDB:
    """The attribute table to store / look up BLE services, characteristics, and attributes.

    Args:
        init_services (list[Service]): A list of services known at instantiation time. Can be updated later
            with the services property
    """

    class CharacteristicView(Mapping[BleUUID, Characteristic]):
        """Represent the GattDB mapping as characteristics indexed by BleUUID"""

        def __init__(self, db: "GattDB") -> None:
            self._db = db

        def __getitem__(self, key: BleUUID) -> Characteristic:
            for service in self._db.services.values():
                for char in service.characteristics.values():
                    if char.uuid == key:
                        return char
            raise KeyError

        def __contains__(self, key: object) -> bool:
            for service in self._db.services.values():
                for char in service.characteristics.values():
                    if char.uuid == key:
                        return True
            return False

        @no_type_check
        def __iter__(self) -> Iterator[Characteristic]:
            return iter(self.values())

        def __len__(self) -> int:
            return sum(len(service.characteristics) for service in self._db.services.values())

        @no_type_check
        def keys(self) -> Generator[BleUUID, None, None]:  # noqa: D102
            """Generate dict-like keys view

            Returns:
                Generator[BleUUID, None, None]: keys generator
            """

            def iter_keys():
                for service in self._db.services.values():
                    yield from service.characteristics.keys()

            return iter_keys()

        @no_type_check
        def values(self) -> Generator[Characteristic, None, None]:  # noqa: D102
            """Generate dict-like values view

            Returns:
                Generator[Characteristic, None, None]: values generator
            """

            def iter_values():
                for service in self._db.services.values():
                    yield from service.characteristics.values()

            return iter_values()

        @no_type_check
        def items(
            self,
        ) -> Generator[tuple[BleUUID, Characteristic], None, None]:  # noqa: D102
            """Generate dict-like items view

            Returns:
                Generator[tuple[BleUUID, Characteristic], None, None]: items generator
            """

            def iter_items():
                for service in self._db.services.values():
                    for ble_uuid, char in service.characteristics.items():
                        yield (ble_uuid, char)

            return iter_items()

    def __init__(self, init_services: list[Service]) -> None:
        self._services: dict[BleUUID, Service] = {}
        # Mypy should eventually support this: see https://github.com/python/mypy/issues/3004
        self.services = init_services  # type: ignore
        self.characteristics = self.CharacteristicView(self)

    @property
    def services(self) -> dict[BleUUID, Service]:
        """Return uuid-to-service mapping

        Returns:
            dict[BleUUID, Service]: Dict of services indexed by uuid
        """
        return self._services

    @services.setter
    def services(self, services: list[Service]) -> None:
        for service in services:
            self._services[service.uuid] = service

    def handle2uuid(self, handle: int) -> BleUUID:
        """Get a BleUUID from a handle.

        Args:
            handle (int): the handle to search for

        Raises:
            KeyError: No characteristic was found at this handle

        Returns:
            BleUUID: The found BleUUID
        """
        for s in self.services.values():
            for c in s.characteristics.values():
                if c.handle == handle:
                    return c.uuid
        raise KeyError(f"Matching BleUUID not found for handle {handle}")

    def uuid2handle(self, ble_uuid: BleUUID) -> int:
        """Convert a handle to a BleUUID

        Args:
            ble_uuid (BleUUID): BleUUID to translate

        Returns:
            int: the handle in the Gatt Database where this BleUUID resides
        """
        return self.characteristics[ble_uuid].handle

    def dump_to_csv(self, file: Path = Path("attributes.csv")) -> None:
        """Dump discovered services to a csv file.

        Args:
            file (Path): File to write to. Defaults to "./attributes.csv".
        """
        with open(file, mode="w") as f:
            logger.debug(f"Dumping discovered BLE characteristics to {file}")

            w = csv.writer(f, delimiter=",", quotechar='"', quoting=csv.QUOTE_MINIMAL)
            w.writerow(["handle", "description", BleUUID, "properties", "value"])

            # For each service in table
            for service in self.services.values():
                w.writerow(
                    [
                        service.start_handle,
                        SpecUuidNumber.PRIMARY_SERVICE,
                        service.uuid.hex,
                        service.name,
                        "SERVICE",
                    ]
                )
                # For each characteristic in service
                for char in service.characteristics.values():
                    w.writerow([char.descriptor_handle, SpecUuidNumber.CHAR_DECLARATION, "28:03", str(char.props), ""])
                    w.writerow([char.handle, char.name, char.uuid.hex, "", char.value])
                    # For each descriptor in characteristic
                    for descriptor in char.descriptors.values():
                        w.writerow([descriptor.handle, descriptor.name, descriptor.uuid.hex, "", descriptor.value])


class UUIDsMeta(type):
    """The metaclass used to build a UUIDs container

    Upon creation of a new UUIDs class, this will store the BleUUID names in an internal mapping indexed by UUID as int
    """

    @no_type_check
    def __new__(mcs, name, bases, dct) -> UUIDsMeta:  # noqa
        x = super().__new__(mcs, name, bases, dct)
        x._int2uuid = {}
        for db in [*[base.__dict__ for base in bases], dct]:
            for _, ble_uuid in [(k, v) for k, v in db.items() if not k.startswith("_")]:
                if not isinstance(ble_uuid, BleUUID):
                    raise TypeError("This class can only be composed of BleUUID attributes")
                x._int2uuid[ble_uuid.int] = ble_uuid
        return x

    @no_type_check
    def __getitem__(cls, key: Union[uuid.UUID, int, str]) -> BleUUID:
        if isinstance(key, uuid.UUID):
            return cls._int2uuid[key.int]
        if isinstance(key, int):
            return cls._int2uuid[key]
        if isinstance(key, str):
            return cls._int2uuid[uuid.UUID(hex=key).int]
        raise TypeError("Key must be of type Union[uuid.UUID, int, str]")

    @no_type_check
    def __contains__(cls, key: Union[uuid.UUID, int, str]) -> bool:
        if isinstance(key, uuid.UUID):
            return key.int in cls._int2uuid
        if isinstance(key, int):
            return key in cls._int2uuid
        if isinstance(key, str):
            # Built uuid.UUID to use it's normalizing
            return uuid.UUID(hex=key).int in cls._int2uuid
        raise TypeError("Key must be of type Union[uuid.UUID, int, str]")

    @no_type_check
    def __iter__(cls):
        yield from cls._int2uuid.items()


@dataclass(frozen=True)
class UUIDs(metaclass=UUIDsMeta):
    """BLE Spec-defined UUIDs that are common across all applications.

    Also functions as a dict to look up UUID's by str, int, or BleUUID
    """

    # pylint: disable=no-method-argument
    def __new__(cls, *_: Any) -> UUIDs:  # noqa
        raise RuntimeError("This class shall not be instantiated")

    # GATT Identifiers
    PRIMARY_SERVICE = BleUUID(
        "Primary Service",
        format=BleUUID.Format.BIT_16,
        int=SpecUuidNumber.PRIMARY_SERVICE,
    )
    SECONDARY_SERVICE = BleUUID(
        "Secondary Service",
        format=BleUUID.Format.BIT_16,
        int=SpecUuidNumber.SECONDARY_SERVICE,
    )
    INCLUDE = BleUUID(
        "Characteristic Include Descriptor",
        format=BleUUID.Format.BIT_16,
        int=SpecUuidNumber.INCLUDE,
    )
    CHAR_DECLARATION = BleUUID(
        "Characteristic Declaration",
        format=BleUUID.Format.BIT_16,
        int=SpecUuidNumber.CHAR_DECLARATION,
    )
    CHAR_EXTENDED_PROPS = BleUUID(
        "Characteristic Extended Properties",
        format=BleUUID.Format.BIT_16,
        int=SpecUuidNumber.CHAR_EXTENDED_PROPS,
    )
    CHAR_USER_DESCR = BleUUID(
        "Characteristic User Description",
        format=BleUUID.Format.BIT_16,
        int=SpecUuidNumber.CHAR_USER_DESCR,
    )
    CLIENT_CHAR_CONFIG = BleUUID(
        "Client Characteristic Configuration",
        format=BleUUID.Format.BIT_16,
        int=SpecUuidNumber.CLIENT_CHAR_CONFIG,
    )
    SERVER_CHAR_CONFIG = BleUUID(
        "Server Characteristic Configuration",
        format=BleUUID.Format.BIT_16,
        int=SpecUuidNumber.SERVER_CHAR_CONFIG,
    )
    CHAR_FORMAT = BleUUID(
        "Characteristic Format",
        format=BleUUID.Format.BIT_16,
        int=SpecUuidNumber.CHAR_FORMAT,
    )
    CHAR_AGGREGATE_FORMAT = BleUUID(
        "Characteristic Aggregate Format",
        format=BleUUID.Format.BIT_16,
        int=SpecUuidNumber.CHAR_AGGREGATE_FORMAT,
    )

    # Generic Attribute Service
    S_GENERIC_ATT = BleUUID("Generic Attribute Service", hex=BLE_BASE_UUID.format("1801"))

    # Generic Access Service
    S_GENERIC_ACCESS = BleUUID("Generic Access Service", hex=BLE_BASE_UUID.format("1800"))
    ACC_DEVICE_NAME = BleUUID("Device Name", hex=BLE_BASE_UUID.format("2a00"))
    ACC_APPEARANCE = BleUUID("Appearance", hex=BLE_BASE_UUID.format("2a01"))
    ACC_PREF_CONN_PARAMS = BleUUID("Preferred Connection Parameters", hex=BLE_BASE_UUID.format("2a04"))
    ACC_CENTRAL_ADDR_RES = BleUUID("Central Address Resolution", hex=BLE_BASE_UUID.format("2aa6"))

    # Tx Power
    S_TX_POWER = BleUUID("Tx Power Service", hex=BLE_BASE_UUID.format("1804"))
    TX_POWER_LEVEL = BleUUID("Tx Power Level", hex=BLE_BASE_UUID.format("2a07"))

    # Battery Service
    S_BATTERY = BleUUID("Battery Service", hex=BLE_BASE_UUID.format("180f"))
    BATT_LEVEL = BleUUID("Battery Level", hex=BLE_BASE_UUID.format("2a19"))

    # Device Information Service
    S_DEV_INFO = BleUUID("Device Information Service", hex=BLE_BASE_UUID.format("180a"))
    INF_MAN_NAME = BleUUID("Manufacturer Name", hex=BLE_BASE_UUID.format("2a29"))
    INF_MODEL_NUM = BleUUID("Model Number", hex=BLE_BASE_UUID.format("2a24"))
    INF_SERIAL_NUM = BleUUID("Serial Number", hex=BLE_BASE_UUID.format("2a25"))
    INF_FW_REV = BleUUID("Firmware Revision", hex=BLE_BASE_UUID.format("2a26"))
    INF_HW_REV = BleUUID("Hardware Revision", hex=BLE_BASE_UUID.format("2a27"))
    INF_SW_REV = BleUUID("Software Revision", hex=BLE_BASE_UUID.format("2a28"))
    INF_SYS_ID = BleUUID("System ID", hex=BLE_BASE_UUID.format("2a23"))
    INF_CERT_DATA = BleUUID("Certification Data", hex=BLE_BASE_UUID.format("2a2a"))
    INF_PNP_ID = BleUUID("PNP ID", hex=BLE_BASE_UUID.format("2a50"))

================
File: demos/python/sdk_wireless_camera_control/open_gopro/demos/gui/__init__.py
================
# __init__.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Thu Feb 23 22:43:52 UTC 2023

"""Common GUI demos. Ensure that additional GUI options were installed before continuing"""

import sys

try:
    import cv2
    import PIL

except ModuleNotFoundError:
    print(
        "Required GUI dependencies not found. See the installation steps: https://gopro.github.io/OpenGoPro/python_sdk/installation.html"
    )
    sys.exit(1)

================
File: demos/python/sdk_wireless_camera_control/open_gopro/demos/gui/livestream.py
================
# livestream.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Wed, Sep  1, 2021  5:05:45 PM

"""Example to start and view a livestream"""

import argparse
import asyncio
from typing import Any

from rich.console import Console

from open_gopro import Params, WirelessGoPro, constants, proto
from open_gopro.logger import setup_logging
from open_gopro.util import add_cli_args_and_parse, ainput

console = Console()  # rich consoler printer


async def main(args: argparse.Namespace) -> None:
    setup_logging(__name__, args.log)

    async with WirelessGoPro(args.identifier, enable_wifi=False) as gopro:
        await gopro.ble_command.set_shutter(shutter=Params.Toggle.DISABLE)
        await gopro.ble_command.register_livestream_status(
            register=[proto.EnumRegisterLiveStreamStatus.REGISTER_LIVE_STREAM_STATUS_STATUS]
        )

        console.print(f"[yellow]Connecting to {args.ssid}...")
        await gopro.connect_to_access_point(args.ssid, args.password)

        # Start livestream
        livestream_is_ready = asyncio.Event()

        async def wait_for_livestream_start(_: Any, update: proto.NotifyLiveStreamStatus) -> None:
            if update.live_stream_status == proto.EnumLiveStreamStatus.LIVE_STREAM_STATE_READY:
                livestream_is_ready.set()

        console.print("[yellow]Configuring livestream...")
        gopro.register_update(wait_for_livestream_start, constants.ActionId.LIVESTREAM_STATUS_NOTIF)
        await gopro.ble_command.set_livestream_mode(
            url=args.url,
            window_size=args.resolution,
            minimum_bitrate=args.min_bit,
            maximum_bitrate=args.max_bit,
            starting_bitrate=args.start_bit,
            lens=args.fov,
        )

        # Wait to receive livestream started status
        console.print("[yellow]Waiting for livestream to be ready...\n")
        await livestream_is_ready.wait()

        # TODO Is this still needed?
        await asyncio.sleep(2)

        console.print("[yellow]Starting livestream")
        assert (await gopro.ble_command.set_shutter(shutter=Params.Toggle.ENABLE)).ok

        console.print("[yellow]Livestream is now streaming and should be available for viewing.")
        await ainput("Press enter to stop livestreaming...\n")

        await gopro.ble_command.set_shutter(shutter=Params.Toggle.DISABLE)
        await gopro.ble_command.release_network()


def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Connect to the GoPro via BLE only, configure then start a Livestream, then display it with CV2."
    )
    parser.add_argument("ssid", type=str, help="WiFi SSID to connect to.")
    parser.add_argument("password", type=str, help="Password of WiFi SSID.")
    parser.add_argument("url", type=str, help="RTMP server URL to stream to.")
    parser.add_argument("--min_bit", type=int, help="Minimum bitrate.", default=1000)
    parser.add_argument("--max_bit", type=int, help="Maximum bitrate.", default=1000)
    parser.add_argument("--start_bit", type=int, help="Starting bitrate.", default=1000)
    parser.add_argument(
        "--resolution", help="Resolution.", choices=list(proto.EnumWindowSize.values()), default=None, type=int  # type: ignore
    )
    parser.add_argument(
        "--fov", help="Field of View.", choices=list(proto.EnumLens.values()), default=None, type=int  # type: ignore
    )
    return add_cli_args_and_parse(parser, wifi=False)


def entrypoint() -> None:
    asyncio.run(main(parse_arguments()))


if __name__ == "__main__":
    entrypoint()

================
File: demos/python/sdk_wireless_camera_control/open_gopro/demos/gui/preview_stream.py
================
# preview_stream.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Mon Jul 31 17:04:07 UTC 2023

"""Example to start and view a preview stream"""

import argparse
import asyncio

from rich.console import Console

from open_gopro import Params, WirelessGoPro
from open_gopro.demos.gui.util import display_video_blocking
from open_gopro.logger import setup_logging
from open_gopro.util import add_cli_args_and_parse

console = Console()


async def main(args: argparse.Namespace) -> None:
    setup_logging(__name__, args.log)

    async with WirelessGoPro(args.identifier) as gopro:
        await gopro.http_command.set_preview_stream(mode=Params.Toggle.DISABLE)
        await gopro.ble_command.set_shutter(shutter=Params.Toggle.DISABLE)
        assert (await gopro.http_command.set_preview_stream(mode=Params.Toggle.ENABLE, port=args.port)).ok

        console.print("Displaying the preview stream...")
        display_video_blocking(f"udp://127.0.0.1:{args.port}", printer=console.print)

        await gopro.http_command.set_preview_stream(mode=Params.Toggle.DISABLE)


def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Connect to the GoPro via BLE and Wifi, start a preview stream, then display it with CV2."
    )
    parser.add_argument(
        "--port", type=int, help="Port to use for livestream. Defaults to 8554 if not set", default=8554
    )
    return add_cli_args_and_parse(parser, wifi=False)


def entrypoint() -> None:
    asyncio.run(main(parse_arguments()))


if __name__ == "__main__":
    entrypoint()

================
File: demos/python/sdk_wireless_camera_control/open_gopro/demos/gui/util.py
================
# util.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Thu Feb 23 22:43:52 UTC 2023

"""Common GUI utilities"""

from __future__ import annotations

import logging
import queue
import threading
from typing import Any, Callable

import cv2

logger = logging.getLogger(__name__)


def display_video_blocking(source: str, printer: Callable = print) -> None:
    """Open a video source to display it, and block until the user stops it by sending 'q'

    Args:
        source (str): video source to display
        printer (Callable): used to display output message. Defaults to print.
    """
    BufferlessVideoCapture(source, printer)


class BufferlessVideoCapture(threading.Thread):
    """Buffer-less video capture to only display the most recent frame

    Open a video source to display it, and block until the user stops it by sending 'q'

    Args:
        source (str): video source to display
        printer (Callable): used to display output message. Defaults to print.
    """

    def __init__(self, source: str, printer: Callable = print) -> None:
        self.printer = printer
        self.printer("Starting viewer...")
        self.cap = cv2.VideoCapture(source + "?overrun_nonfatal=1&fifo_size=50000000", cv2.CAP_FFMPEG)
        self.q: queue.Queue[Any] = queue.Queue()
        super().__init__(daemon=True)
        self.start()
        self.printer("Viewer started")
        self.printer("Press 'q' in viewer to quit")
        while True:
            try:
                frame = self.q.get()
                cv2.imshow("frame", frame)
                if cv2.waitKey(1) & 0xFF == ord("q"):
                    break
            except Exception as e:  # pylint: disable=broad-exception-caught
                logger.warning(e)
                break
        self.cap.release()
        cv2.destroyAllWindows()

    def run(self) -> None:
        """Read frames as soon as they are available, keeping only most recent one"""
        while True:
            try:
                ret, frame = self.cap.read()
                if not ret:
                    self.printer("Received empty frame.")
                    continue
                if not self.q.empty():
                    self.q.get_nowait()  # discard previous (unprocessed) frame
                self.q.put(frame)
            except queue.Empty:
                pass
            except:  # pylint: disable=bare-except
                break

================
File: demos/python/sdk_wireless_camera_control/open_gopro/demos/gui/webcam.py
================
# usb.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Fri Nov 18 00:18:13 UTC 2022

"""USB / wireless webcam demo"""

import argparse
import asyncio
import sys
from typing import Final

from rich.console import Console

from open_gopro import Params, WiredGoPro, WirelessGoPro
from open_gopro.constants import WebcamError, WebcamStatus
from open_gopro.demos.gui.util import display_video_blocking
from open_gopro.gopro_base import GoProBase
from open_gopro.logger import setup_logging
from open_gopro.util import add_cli_args_and_parse

console = Console()

STREAM_URL: Final[str] = r"udp://0.0.0.0:8554"


async def wait_for_webcam_status(gopro: GoProBase, statuses: set[WebcamStatus], timeout: int = 10) -> bool:
    """Wait for specified webcam status(es) for a given timeout

    Args:
        gopro (GoProBase): gopro to communicate with
        statuses (set[WebcamStatus]): statuses to wait for
        timeout (int): timeout in seconds. Defaults to 10.

    Returns:
        bool: True if status was received before timing out, False if timed out or received error
    """

    async def poll_for_status() -> bool:
        # Poll until status is received
        while True:
            response = (await gopro.http_command.webcam_status()).data
            if response.error != WebcamError.SUCCESS:
                # Something bad happened
                console.print(f"[yellow]Received webcam error: {response.error}")
                return False
            if response.status in statuses:
                # We found the desired status
                return True

    # Wait for either status or timeout
    try:
        return await asyncio.wait_for(poll_for_status(), timeout)
    except TimeoutError:
        return False


async def main(args: argparse.Namespace) -> int:
    logger = setup_logging(__name__, args.log)
    gopro: GoProBase | None = None

    try:
        async with (
            WirelessGoPro(args.identifier, wifi_interface=args.wifi_interface, enable_wifi=not args.cohn)  # type: ignore
            if bool(args.cohn or args.wireless)
            else WiredGoPro(args.identifier)
        ) as gopro:
            assert gopro

            if args.cohn:
                assert await gopro.is_cohn_provisioned
                assert await gopro.configure_cohn()
            else:
                await gopro.http_command.wired_usb_control(control=Params.Toggle.DISABLE)

            await gopro.http_command.set_shutter(shutter=Params.Toggle.DISABLE)
            if (await gopro.http_command.webcam_status()).data.status not in {
                WebcamStatus.OFF,
                WebcamStatus.IDLE,
            }:
                console.print("[blue]Webcam is currently on. Turning if off.")
                assert (await gopro.http_command.webcam_stop()).ok
                await wait_for_webcam_status(gopro, {WebcamStatus.OFF})

            console.print("[blue]Starting webcam...")
            if (status := (await gopro.http_command.webcam_start()).data.error) != WebcamError.SUCCESS:
                console.print(f"[red]Couldn't start webcam: {status}")
                return -1
            await wait_for_webcam_status(gopro, {WebcamStatus.HIGH_POWER_PREVIEW})

            # Start player
            display_video_blocking(STREAM_URL, printer=console.print)  # blocks until user exists viewer
            console.print("[blue]Stopping webcam...")
            assert (await gopro.http_command.webcam_stop()).ok
            await wait_for_webcam_status(gopro, {WebcamStatus.OFF, WebcamStatus.IDLE})
            assert (await gopro.http_command.webcam_exit()).ok
            await wait_for_webcam_status(gopro, {WebcamStatus.OFF})
            console.print("Exiting...")

    except Exception as e:  # pylint: disable = broad-except
        logger.error(repr(e))

    if gopro:
        await gopro.close()

    return 0


def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Setup and view a GoPro webcam using TS protocol.")
    protocol = parser.add_argument_group("protocol", "Mutually exclusive Protocol option if not default wired USB.")
    group = protocol.add_mutually_exclusive_group()
    group.add_argument(
        "--wireless",
        action="store_true",
        help="Set to use wireless (BLE / WIFI) instead of wired (USB)) interface",
    )
    group.add_argument(
        "--cohn",
        action="store_true",
        help="Communicate via COHN. Assumes COHN is already provisioned.",
    )
    return add_cli_args_and_parse(parser)


# Needed for poetry scripts defined in pyproject.toml
def entrypoint() -> None:
    sys.exit(asyncio.run(main(parse_arguments())))


if __name__ == "__main__":
    entrypoint()

================
File: demos/python/sdk_wireless_camera_control/open_gopro/demos/__init__.py
================
# __init__.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Wed, Sep  1, 2021  5:05:46 PM

"""Demos to show how to use Open GoPro package"""

================
File: demos/python/sdk_wireless_camera_control/open_gopro/demos/cohn.py
================
# cohn.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Tue Oct 24 19:08:07 UTC 2023

"""Entrypoint for configuring and demonstrating Camera On the Home Network (COHN)."""

from __future__ import annotations

import argparse
import asyncio

from rich.console import Console

from open_gopro import WirelessGoPro
from open_gopro.logger import setup_logging
from open_gopro.util import add_cli_args_and_parse

console = Console()  # rich consoler printer

MDNS_SERVICE = "_gopro-web._tcp.local."


async def main(args: argparse.Namespace) -> None:
    logger = setup_logging(__name__, args.log)

    gopro: WirelessGoPro | None = None
    try:
        # Start with Wifi Disabled (i.e. don't allow camera in AP mode).
        async with WirelessGoPro(args.identifier, enable_wifi=False) as gopro:
            if await gopro.is_cohn_provisioned:
                console.print("[yellow]COHN is already provisioned")
            else:
                if not args.ssid or not args.password:
                    raise ValueError("COHN needs to be provisioned but you didn't pass SSID credentials.")
                assert await gopro.connect_to_access_point(args.ssid, args.password)
            assert await gopro.configure_cohn()

            console.print("[blue]COHN is ready for communication. Dropping the BLE connection.")

        # Prove we can communicate via the COHN HTTP channel without a BLE or Wifi connection
        assert (await gopro.http_command.get_camera_state()).ok
        console.print("Successfully communicated via COHN!!")

    except Exception as e:  # pylint: disable = broad-except
        logger.error(repr(e))

    if gopro:
        await gopro.close()


def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Provision / connect a camera for COHN. SSID and password must be passed if COHN is not currently provisioned."
    )
    parser.add_argument(
        "--ssid",
        type=str,
        help="WiFi SSID to connect to if not currently provisioned for COHN.",
        default=None,
    )
    parser.add_argument(
        "--password",
        type=str,
        help="Password of WiFi SSID.",
        default=None,
    )
    return add_cli_args_and_parse(parser, wifi=False)


# Needed for poetry scripts defined in pyproject.toml
def entrypoint() -> None:
    asyncio.run(main(parse_arguments()))


if __name__ == "__main__":
    entrypoint()

================
File: demos/python/sdk_wireless_camera_control/open_gopro/demos/connect_wifi.py
================
# connect_wifi.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Wed, Sep  1, 2021  5:05:44 PM

"""Connect to the Wifi AP of a GoPro camera."""

import argparse
import asyncio
import logging
from typing import Optional

from rich.console import Console

from open_gopro import WirelessGoPro
from open_gopro.logger import set_stream_logging_level, setup_logging
from open_gopro.util import add_cli_args_and_parse, ainput

console = Console()


def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Connect to a GoPro camera's Wifi Access Point.")
    return add_cli_args_and_parse(parser)


async def main(args: argparse.Namespace) -> None:
    setup_logging(__name__, args.log)
    gopro: Optional[WirelessGoPro] = None

    async with WirelessGoPro(args.identifier, wifi_interface=args.wifi_interface, sudo_password=args.password) as gopro:
        # Now we only want errors
        set_stream_logging_level(logging.ERROR)

        console.print("\n\n Success!! Wifi AP is connected \n")
        console.print("Send commands as per https://gopro.github.io/OpenGoPro/http")

        await ainput("[blue]Press enter to disconnect Wifi and exit...", console.print)
        console.print("Exiting...")

    if gopro:
        await gopro.close()


# Needed for poetry scripts defined in pyproject.toml
def entrypoint() -> None:
    asyncio.run(main(parse_arguments()))


if __name__ == "__main__":
    entrypoint()

================
File: demos/python/sdk_wireless_camera_control/open_gopro/demos/log_battery.py
================
# log_battery.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Wed, Sep  1, 2021  5:05:45 PM

"""Example to continuously read the battery (with no Wifi connection)"""

import argparse
import asyncio
import csv
import logging
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Optional

from rich.console import Console

from open_gopro import WirelessGoPro, types
from open_gopro.constants import StatusId
from open_gopro.logger import set_stream_logging_level, setup_logging
from open_gopro.util import add_cli_args_and_parse, ainput

console = Console()

last_percentage = 0
last_bars = 0


@dataclass
class Sample:
    """Simple class to store battery samples"""

    index: int
    percentage: int
    bars: int

    def __post_init__(self) -> None:
        self.time = datetime.now()

    def __str__(self) -> str:
        return f"Index {self.index} @ time {self.time.strftime('%H:%M:%S')} --> bars: {self.bars}, percentage: {self.percentage}"


SAMPLE_INDEX = 0
SAMPLES: list[Sample] = []


def dump_results_as_csv(location: Path) -> None:
    """Write all of the samples to a csv file

    Args:
        location (Path): File to write to
    """
    console.print(f"Dumping results as CSV to {location}")
    with open(location, mode="w") as f:
        w = csv.writer(f, delimiter=",", quotechar='"', quoting=csv.QUOTE_MINIMAL)
        w.writerow(["index", "time", "percentage", "bars"])
        initial_time = SAMPLES[0].time
        for s in SAMPLES:
            w.writerow([s.index, (s.time - initial_time).seconds, s.percentage, s.bars])


async def process_battery_notifications(update: types.UpdateType, value: int) -> None:
    """Handle asynchronous battery update notifications

    Args:
        update (types.UpdateType): type of update
        value (int): value of update
    """

    global last_percentage
    global last_bars

    if update == StatusId.INT_BATT_PER:
        last_percentage = value
    elif update == StatusId.BATT_LEVEL:
        last_bars = value

    # Append and print sample
    global SAMPLE_INDEX
    SAMPLES.append(Sample(index=SAMPLE_INDEX, percentage=last_percentage, bars=last_bars))
    console.print(str(SAMPLES[-1]))
    SAMPLE_INDEX += 1


async def main(args: argparse.Namespace) -> None:
    logger = setup_logging(__name__, args.log)

    gopro: Optional[WirelessGoPro] = None
    try:
        async with WirelessGoPro(args.identifier, enable_wifi=False) as gopro:
            set_stream_logging_level(logging.ERROR)

            async def log_battery() -> None:
                global SAMPLE_INDEX
                if args.poll:
                    with console.status("[bold green]Polling the battery until it dies..."):
                        while True:
                            SAMPLES.append(
                                Sample(
                                    index=SAMPLE_INDEX,
                                    percentage=(await gopro.ble_status.int_batt_per.get_value()).data,
                                    bars=(await gopro.ble_status.batt_level.get_value()).data,
                                )
                            )
                            console.print(str(SAMPLES[-1]))
                            SAMPLE_INDEX += 1
                            await asyncio.sleep(args.poll)
                else:  # Not polling. Set up notifications
                    global last_bars
                    global last_percentage

                    console.print("Configuring battery notifications...")
                    # Enable notifications of the relevant battery statuses. Also store initial values.
                    last_bars = (
                        await gopro.ble_status.batt_level.register_value_update(process_battery_notifications)
                    ).data
                    last_percentage = (
                        await gopro.ble_status.int_batt_per.register_value_update(process_battery_notifications)
                    ).data
                    # Append initial sample
                    SAMPLES.append(Sample(index=SAMPLE_INDEX, percentage=last_percentage, bars=last_bars))
                    SAMPLE_INDEX += 1
                    console.print(str(SAMPLES[-1]))
                    console.print("[bold green]Receiving battery notifications until it dies...")

            asyncio.create_task(log_battery())
            await ainput("[purple]Press enter to exit.", console.print)
            console.print("Exiting...")

    except KeyboardInterrupt:
        logger.warning("Received keyboard interrupt. Shutting down...")
    if SAMPLES:
        csv_location = Path(args.log.parent) / "battery_results.csv"
        dump_results_as_csv(csv_location)
    if gopro:
        await gopro.close()


def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Connect to the GoPro via BLE only and continuously read the battery (either by polling or notifications)."
    )
    parser.add_argument(
        "-p",
        "--poll",
        type=int,
        help="Set to poll the battery at a given interval. If not set, battery level will be notified instead. Defaults to notifications.",
        default=None,
    )
    return add_cli_args_and_parse(parser, wifi=False)


def entrypoint() -> None:
    asyncio.run(main(parse_arguments()))


if __name__ == "__main__":
    entrypoint()

================
File: demos/python/sdk_wireless_camera_control/open_gopro/demos/photo.py
================
# photo.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Wed, Sep  1, 2021  5:05:45 PM

"""Entrypoint for taking a picture demo."""

import argparse
import asyncio
from pathlib import Path

from rich.console import Console

from open_gopro import Params, WiredGoPro, WirelessGoPro, proto
from open_gopro.gopro_base import GoProBase
from open_gopro.logger import setup_logging
from open_gopro.util import add_cli_args_and_parse

console = Console()


async def main(args: argparse.Namespace) -> None:
    logger = setup_logging(__name__, args.log)

    gopro: GoProBase | None = None

    try:
        async with (
            WiredGoPro(args.identifier)  # type: ignore
            if args.wired
            else WirelessGoPro(args.identifier, wifi_interface=args.wifi_interface)
        ) as gopro:
            assert gopro
            assert (await gopro.http_command.load_preset_group(group=proto.EnumPresetGroup.PRESET_GROUP_ID_PHOTO)).ok

            # Get the media list before
            media_set_before = set((await gopro.http_command.get_media_list()).data.files)

            # Take a photo
            assert (await gopro.http_command.set_shutter(shutter=Params.Toggle.ENABLE)).ok

            # Get the media list after
            media_set_after = set((await gopro.http_command.get_media_list()).data.files)
            # The video (is most likely) the difference between the two sets
            photo = media_set_after.difference(media_set_before).pop()

            # Download the photo
            console.print(f"Downloading {photo.filename}...")
            await gopro.http_command.download_file(camera_file=photo.filename, local_file=args.output)
            console.print(f"Success!! :smiley: File has been downloaded to {Path(args.output).absolute()}")

    except Exception as e:  # pylint: disable = broad-except
        logger.error(repr(e))

    if gopro:
        await gopro.close()


def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Connect to a GoPro camera, take a photo, then download it.")
    parser.add_argument(
        "--output",
        type=Path,
        help="Where to write the photo to. If not set, write to 'photo.jpg'",
        default=Path("photo.jpg"),
    )
    parser.add_argument(
        "--wired",
        action="store_true",
        help="Set to use wired (USB) instead of wireless (BLE / WIFI) interface",
    )

    return add_cli_args_and_parse(parser)


# Needed for poetry scripts defined in pyproject.toml
def entrypoint() -> None:
    asyncio.run(main(parse_arguments()))


if __name__ == "__main__":
    entrypoint()

================
File: demos/python/sdk_wireless_camera_control/open_gopro/demos/video.py
================
# video.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Wed, Sep  1, 2021  5:05:46 PM

"""Entrypoint for taking a video demo."""

import argparse
import asyncio
from pathlib import Path

from rich.console import Console

from open_gopro import Params, WiredGoPro, WirelessGoPro, proto
from open_gopro.logger import setup_logging
from open_gopro.util import add_cli_args_and_parse

console = Console()


async def main(args: argparse.Namespace) -> None:
    logger = setup_logging(__name__, args.log)
    gopro: WirelessGoPro | WiredGoPro | None = None

    try:
        async with (
            WiredGoPro(args.identifier)  # type: ignore
            if args.wired
            else WirelessGoPro(args.identifier, wifi_interface=args.wifi_interface)
        ) as gopro:
            assert gopro
            assert (await gopro.http_command.load_preset_group(group=proto.EnumPresetGroup.PRESET_GROUP_ID_VIDEO)).ok

            # Get the media list before
            media_set_before = set((await gopro.http_command.get_media_list()).data.files)
            # Take a video
            console.print("Capturing a video...")
            assert (await gopro.http_command.set_shutter(shutter=Params.Toggle.ENABLE)).ok
            await asyncio.sleep(args.record_time)
            assert (await gopro.http_command.set_shutter(shutter=Params.Toggle.DISABLE)).ok

            # Get the media list after
            media_set_after = set((await gopro.http_command.get_media_list()).data.files)
            # The video (is most likely) the difference between the two sets
            video = media_set_after.difference(media_set_before).pop()

            # Download the video
            console.print(f"Downloading {video.filename}...")
            await gopro.http_command.download_file(camera_file=video.filename, local_file=args.output)
            console.print(f"Success!! :smiley: File has been downloaded to {args.output}")
    except Exception as e:  # pylint: disable = broad-except
        logger.error(repr(e))

    if gopro:
        await gopro.close()
    console.print("Exiting...")


def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Connect to a GoPro camera, take a video, then download it.")
    parser.add_argument("-r", "--record_time", type=float, help="How long to record for", default=2.0)
    parser.add_argument(
        "-o",
        "--output",
        type=Path,
        help="Where to write the video to. If not set, write to 'video.mp4'",
        default=Path("video.mp4"),
    )
    parser.add_argument(
        "--wired",
        action="store_true",
        help="Set to use wired (USB) instead of wireless (BLE / WIFI) interface",
    )
    return add_cli_args_and_parse(parser)


# Needed for poetry scripts defined in pyproject.toml
def entrypoint() -> None:
    asyncio.run(main(parse_arguments()))


if __name__ == "__main__":
    entrypoint()

================
File: demos/python/sdk_wireless_camera_control/open_gopro/models/__init__.py
================
# __init__.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Mon Jun 26 18:26:05 UTC 2023

"""Data models for use throughout this package"""

from .general import CameraInfo, TzDstDateTime
from .media_list import (
    GroupedMediaItem,
    MediaItem,
    MediaList,
    MediaMetadata,
    MediaPath,
    PhotoMetadata,
    VideoMetadata,
)
from .response import GoProResp

================
File: demos/python/sdk_wireless_camera_control/open_gopro/models/bases.py
================
# bases.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Mon Jul 31 17:04:07 UTC 2023

"""Base classes shared throughout models"""

import json

from pydantic import BaseModel

from open_gopro.util import pretty_print, scrub


class CustomBaseModel(BaseModel):
    """Additional functionality added to Pydantic BaseModel"""

    def __hash__(self) -> int:
        h = hash((type(self),))
        for v in self.__dict__.values():
            if isinstance(v, (dict, list)):
                h += hash(json.dumps(v))
            else:
                h += hash(v)
        return h

    def __str__(self) -> str:
        d = dict(self)
        scrub(d, bad_values=[None])
        return pretty_print(d)

================
File: demos/python/sdk_wireless_camera_control/open_gopro/models/general.py
================
# general.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Mon Jul 31 17:04:07 UTC 2023

"""Other models that don't deserve their own file"""

from __future__ import annotations

import datetime
from base64 import b64encode
from dataclasses import dataclass
from pathlib import Path
from typing import Optional

from pydantic import ConfigDict, Field

from open_gopro import constants
from open_gopro.models.bases import CustomBaseModel


class CameraInfo(CustomBaseModel):
    """General camera info"""

    model_config = ConfigDict(protected_namespaces=())
    model_number: int  #: Camera model number
    model_name: str  #: Camera model name as string
    firmware_version: str  #: Complete firmware version
    serial_number: str  #: Camera serial number
    ap_mac_addr: str  #: Camera access point MAC address
    ap_ssid: str  #: Camera access point SSID name


class TzDstDateTime(CustomBaseModel):
    """DST aware datetime"""

    datetime: datetime.datetime
    tzone: int
    dst: bool


class SupportedOption(CustomBaseModel):
    """A supported option in an invalid setting response"""

    display_name: str
    id: int


class WebcamResponse(CustomBaseModel):
    """Common Response from Webcam Commands"""

    status: Optional[constants.WebcamStatus] = Field(default=None)
    error: constants.WebcamError
    setting_id: Optional[str] = Field(default=None)
    supported_options: Optional[list[SupportedOption]] = Field(default=None)


class HttpInvalidSettingResponse(CustomBaseModel):
    """Invalid settings response with optional supported options"""

    error: int
    setting_id: constants.SettingId
    option_id: Optional[int] = Field(default=None)
    supported_options: Optional[list[SupportedOption]] = Field(default=None)


@dataclass
class CohnInfo:
    """Data model to store Camera on the Home Network connection info"""

    ip_address: str
    username: str
    password: str
    certificate: str
    cert_path: Path = Path("cohn.crt")

    def __post_init__(self) -> None:
        token = b64encode(f"{self.username}:{self.password}".encode("utf-8")).decode("ascii")
        self.auth_token = f"Basic {token}"
        with open(self.cert_path, "w") as fp:
            fp.write(self.certificate)

================
File: demos/python/sdk_wireless_camera_control/open_gopro/models/media_list.py
================
# media_list.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Mon Jun 26 18:26:05 UTC 2023

"""Media List and Metadata containers and helper methods"""

from __future__ import annotations

from abc import ABC
from typing import Any, Optional

from pydantic import Field, PrivateAttr, validator

from open_gopro.models.bases import CustomBaseModel
from open_gopro.types import JsonDict

##############################################################################################################
# Generic
##############################################################################################################


class MediaPath(ABC, CustomBaseModel):
    """Model to represent media path"""

    folder: str  #: directory that media lives in
    file: str  #: media file name (including file extension)

    @property
    def as_path(self) -> str:
        """Return the model as a camera path (folder/file)

        Returns:
            str: camera path
        """
        return f"{self.folder}/{self.file}"

    def __str__(self) -> str:
        return self.as_path


##############################################################################################################
# Metadata
##############################################################################################################


class MediaMetadata(ABC, CustomBaseModel):
    """Base Media Metadata class"""

    content_type: str = Field(alias="ct")  #: Media content type
    creation_timestamp: str = Field(alias="cre")  #: Creation time in seconds since epoch
    file_size: str = Field(alias="s")  #: File size in bytes
    gumi: str = Field(alias="gumi")  #: Globally Unique Media ID
    height: str = Field(alias="h")  #: Height of media in pixels
    width: str = Field(alias="w")  #: Width of media in pixels
    hilight_count: str = Field(alias="hc")  #: Number of hilights in media
    image_stabilization: str = Field(alias="eis")  #: 1 if stabilized, 0 otherwise
    metadata_present: str = Field(alias="mp")  #: 1 if metadata is present, 0 otherwise
    rotate: str = Field(alias="rot")  #: Media rotation
    transcoded: str = Field(alias="tr")  #: 1 if file is transcoded, 0 otherwise
    upload_status: str = Field(alias="us")  #: Whether or not the media file has been uploaded
    media_offload_state: Optional[list[str]] = Field(alias="mos", default=None)  #: List of offload states
    parent_gumi: Optional[str] = Field(alias="pgumi", default=None)  #: Only present if in a clip
    field_of_view: Optional[str] = Field(alias="fov", default=None)  #: Field of View
    lens_config: Optional[str] = Field(alias="lc", default=None)  #: Lens configuration
    lens_projection: Optional[str] = Field(alias="prjn", default=None)  #: Lens projection

    @classmethod
    def from_json(cls, json_str: JsonDict) -> MediaMetadata:
        """Build a metadata object given JSON input

        Args:
            json_str (JsonDict): raw JSON

        Returns:
            MediaMetadata: parsed metadata
        """
        # Choose a field that only exists in video to see if this is a video
        return (VideoMetadata if "ao" in json_str else PhotoMetadata)(**json_str)


class VideoMetadata(MediaMetadata):
    """Metadata for a video file"""

    audio_option: str = Field(alias="ao")  #: Auto, wind, or stereo
    avc_level: str = Field(alias="profile")  #: Advanced Video Codec Level
    avc_profile: str = Field(alias="avc_profile")  #: Advanced Video Code Profile
    clipped: str = Field(alias="cl")  #: 1 if clipped, 0 otherwise
    duration: str = Field(alias="dur")  #: Video duration in seconds
    frame_rate: str = Field(alias="fps")  # Video frame rate in frames / second
    frame_rate_divisor: str = Field(alias="fps_denom")  #: Used to modify frame rate
    hilight_list: list[str] = Field(alias="hi")  #: List of hlights in ms offset from start of video
    lrv_file_size: str = Field(alias="ls")  #: Low Resolution Video file size in bytes. -1 if there is no LRV
    max_auto_hilight_score: str = Field(alias="mahs")  #: Maximum auto-hilight score
    protune_audio: str = Field(alias="pta")  #: 1 if protune audio is present, 0 otherwise
    subsample: str = Field(alias="subsample")  #: 1 if subsampled from other video, 0 otherwise
    progressive: Optional[str] = Field(alias="progr", default=None)  #: 1 if progressive, 0 otherwise


class PhotoMetadata(MediaMetadata):
    """Metadata for a Photo file"""

    raw: Optional[str] = Field(default=None)  #: 1 if photo has raw version, 0 otherwise
    """1 if photo taken with wide dynamic range, 0 otherwise"""
    wide_dynamic_range: Optional[str] = Field(alias="wdr", default=None)
    """1 if photo taken with high dynamic range, 0 otherwise"""
    high_dynamic_range: Optional[str] = Field(alias="hdr", default=None)


##############################################################################################################
# Media List
##############################################################################################################


class MediaItem(CustomBaseModel):
    """Base Media Item class"""

    filename: str = Field(alias="n")  #: Name of media item
    creation_timestamp: str = Field(alias="cre")  #: Creation time in seconds since epoch
    modified_time: str = Field(alias="mod")  #: Time file was last modified in seconds since epoch
    low_res_video_size: Optional[str] = Field(alias="glrv", default=None)  #: Low resolution video size
    lrv_file_size: Optional[str] = Field(alias="ls", default=None)  #: Low resolution file size
    session_id: Optional[str] = Field(alias="id", default=None)  # Media list session identifier
    raw: Optional[str] = Field(default=None)  #: 1 if photo has raw version, 0 (or omitted) otherwise


class GroupedMediaItem(MediaItem):
    """Media Item that is also a grouped item.

    An example of a grouped item is a burst photo.
    """

    group_id: str = Field(alias="g", default=None)  #: Group Identifier
    group_size: str = Field(alias="s", default=None)  # Number of files in the group
    group_first_member_id: str = Field(alias="b", default=None)  # ID of first member in the group
    group_last_member_id: str = Field(alias="l", default=None)  #: ID of last member in the group
    group_missing_ids: list[str] = Field(alias="m", default=None)  #: File ID's that are missing or deleted
    """(b -> burst, c -> continuous shot, n -> night lapse, t -> time lapse)"""
    group_type: str = Field(alias="t", default=None)


class MediaFileSystem(CustomBaseModel):
    """Grouping of media items into filesystem(s)"""

    directory: str = Field(alias="d")  # Directory that the files are in
    file_system: list[MediaItem] = Field(alias="fs")  #: List of files

    @validator("file_system", pre=True, each_item=True)
    @classmethod
    def identify_item(cls, item: JsonDict) -> MediaItem:
        """Extent item into GroupedMediaItem if it such an item

        A group item is identified by the presence of a "g" field

        Args:
            item (JsonDict): input JSON

        Returns:
            MediaItem: parsed media item
        """
        return (GroupedMediaItem if "g" in item else MediaItem)(**item)


class MediaList(CustomBaseModel):
    """Top level media list object"""

    identifier: str = Field(alias="id")  #: String identifier of this media list
    media: list[MediaFileSystem]  #: Media filesystem(s)
    _files: list[MediaItem] = PrivateAttr(default_factory=list)

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        # Modify each file name to use full path
        for directory in self.media:
            for media in directory.file_system:
                media.filename = f"{directory.directory}/{media.filename}"
                self._files.append(media)

    def __contains__(self, key: MediaItem | MediaPath | str) -> bool:
        if isinstance(key, MediaItem):
            return key in self.files
        return str(key) in [m.filename for m in self.files]

    @property
    def files(self) -> list[MediaItem]:
        """Helper method to get list of media items

        Returns:
            list[MediaItem]: all media items in this media list
        """
        return self._files

================
File: demos/python/sdk_wireless_camera_control/open_gopro/models/response.py
================
# responses.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Wed, Sep  1, 2021  5:05:49 PM

"""Any responses that are returned from GoPro commands."""

from __future__ import annotations

import enum
import logging
from abc import ABC, abstractmethod
from collections import defaultdict
from dataclasses import dataclass
from typing import Any, Final, Generic, TypeVar

import requests

from open_gopro.api.parsers import JsonParsers
from open_gopro.ble import BleUUID
from open_gopro.constants import (
    ActionId,
    CmdId,
    ErrorCode,
    FeatureId,
    GoProIntEnum,
    GoProUUIDs,
    QueryCmdId,
    SettingId,
    StatusId,
)
from open_gopro.exceptions import ResponseParseError
from open_gopro.parser_interface import GlobalParsers, Parser
from open_gopro.proto import EnumResultGeneric
from open_gopro.types import CameraState, JsonDict, ResponseType
from open_gopro.util import pretty_print

logger = logging.getLogger(__name__)

CONT_MASK: Final = 0b10000000
HDR_MASK: Final = 0b01100000
GEN_LEN_MASK: Final = 0b00011111
EXT_13_BYTE0_MASK: Final = 0b00011111


class Header(enum.Enum):
    """Packet Headers."""

    GENERAL = 0b00
    EXT_13 = 0b01
    EXT_16 = 0b10
    RESERVED = 0b11
    CONT = enum.auto()


T = TypeVar("T")


@dataclass
class GoProResp(Generic[T]):
    """The object used to encapsulate all GoPro responses.

    It consists of several common properties / attribute and a data attribute that varies per response.

    >>> gopro = WirelessGoPro()
    >>> await gopro.open()
    >>> response = await (gopro.ble_setting.resolution).get_value()
    >>> print(response)

    Now let's inspect the responses various attributes / properties:

    >>> print(response.status)
    ErrorCode.SUCCESS
    >>> print(response.ok)
    True
    >>> print(response.identifier)
    QueryCmdId.GET_SETTING_VAL
    >>> print(response.protocol)
    Protocol.BLE

    Now let's print it's data as (as JSON):

    >>> print(response)
    {
        "id" : "QueryCmdId.GET_SETTING_VAL",
        "status" : "ErrorCode.SUCCESS",
        "protocol" : "Protocol.BLE",
        "data" : {
            "SettingId.RESOLUTION" : "Resolution.RES_4K_16_9",
        },
    }

    Attributes:
        protocol (GoProResp.Protocol): protocol response was received on
        status (ErrorCode): status of response
        data (T): parsed response data
        identifier (ResponseType): response identifier, the type of which will vary depending on the response
    """

    class Protocol(enum.Enum):
        """Protocol that Command will be sent on."""

        BLE = "BLE"
        HTTP = "HTTP"

    protocol: GoProResp.Protocol
    status: ErrorCode
    data: T
    identifier: ResponseType

    def _as_dict(self) -> dict:
        """Represent the response as dictionary, merging it's data and meta information

        Returns:
            dict: dict representation
        """
        d = {
            "id": self.identifier,
            "status": self.status,
            "protocol": self.protocol,
        }
        if self.data:
            d["data"] = self.data  # type: ignore
        return d

    def __eq__(self, obj: object) -> bool:
        if isinstance(obj, GoProIntEnum):
            return self.identifier == obj
        if isinstance(obj, GoProResp):
            return self.identifier == obj.identifier
        raise TypeError("Equal can only compare GoProResp and ResponseType")

    def __str__(self) -> str:
        return pretty_print(self._as_dict())

    def __repr__(self) -> str:
        return f"GoProResp <{str(self.identifier)}>"

    @property
    def ok(self) -> bool:
        """Are there any errors in this response?

        Returns:
            bool: True if the response is ok (i.e. there are no errors), False otherwise
        """
        return self.status in [ErrorCode.SUCCESS, ErrorCode.UNKNOWN]

    @property
    def _is_push(self) -> bool:
        """Was this response an asynchronous push?

        Returns:
            bool: True if yes, False otherwise
        """
        return self.identifier in [
            QueryCmdId.STATUS_VAL_PUSH,
            QueryCmdId.SETTING_VAL_PUSH,
            QueryCmdId.SETTING_CAPABILITY_PUSH,
        ]

    @property
    def _is_query(self) -> bool:
        """Is this response to a settings / status query?

        Returns:
            bool: True if yes, False otherwise
        """
        return isinstance(self.identifier, QueryCmdId)


class RespBuilder(ABC, Generic[T]):
    """Common Response Builder Interface"""

    class _State(enum.Enum):
        """Describes the state of building the response."""

        INITIALIZED = enum.auto()
        ACCUMULATED = enum.auto()
        PARSED = enum.auto()
        ERROR = enum.auto()

    def __init__(self) -> None:
        self._packet: T
        self._status: ErrorCode = ErrorCode.UNKNOWN
        self._state: RespBuilder._State = RespBuilder._State.INITIALIZED
        self._parser: Parser | None = None

    @abstractmethod
    def build(self) -> GoProResp[T]:
        """Build a response

        Returns:
            GoProResp[T]: built response
        """


class HttpRespBuilder(RespBuilder[JsonDict]):
    """HTTP Response Builder

    This is not intended to be fool proof to use as the user must understand which fields are needed.
    Directors should be created if this needs to be simplified.
    """

    def __init__(self) -> None:
        super().__init__()
        self._endpoint: str
        self._response: JsonDict

    def set_response(self, response: JsonDict) -> None:
        """Store the JSON data. This is mandatory.

        Args:
            response (JsonDict): json data_
        """
        self._response = response

    def set_status(self, status: ErrorCode) -> None:
        """Store the status. This is mandatory.

        Args:
            status (ErrorCode): status of response
        """
        self._status = status

    def set_parser(self, parser: Parser) -> None:
        """Store a parser. This is optional.

        Args:
            parser (Parser): monolithic parser
        """
        self._parser = parser

    def set_endpoint(self, endpoint: str) -> None:
        """Store the endpoint. This is mandatory.

        Args:
            endpoint (str): endpoint of response.
        """
        self._endpoint = endpoint

    def build(self) -> GoProResp:
        """Build the GoPro response from the information accumulated about the HTTP response

        Returns:
            GoProResp: built response
        """
        # Is there a parser for this? Most of them do not have one yet.
        data = self._parser.parse(self._response) if self._parser else self._response
        return GoProResp(
            protocol=GoProResp.Protocol.HTTP,
            status=self._status,
            identifier=self._endpoint,
            data=data,
        )


class RequestsHttpRespBuilderDirector:
    """An abstraction to help simplify using the HTTP Response Builder for requests

    Args:
        response (requests.models.Response): direct response from requests
        parser (Parser | None): parsers to use on the requests response
    """

    def __init__(self, response: requests.models.Response, parser: Parser | None) -> None:

        self.response = response
        self.parser = parser or Parser(json_parser=JsonParsers.LambdaParser(lambda data: data))

    def __call__(self) -> GoProResp:
        """Build the response

        Returns:
            GoProResp: built response
        """
        builder = HttpRespBuilder()
        builder.set_endpoint(self.response.url)
        builder.set_status(ErrorCode.SUCCESS if self.response.ok else ErrorCode.ERROR)
        builder.set_parser(self.parser)
        builder.set_response(self.response.json() if self.response.text else {})
        return builder.build()


class BleRespBuilder(RespBuilder[bytearray]):
    """BLE Response Builder

    This is not intended to be fool proof to use as the user must understand which fields are needed.
    Directors should be created if this needs to be simplified.
    """

    def __init__(self) -> None:
        self._bytes_remaining = 0
        self._uuid: BleUUID
        self._identifier: ResponseType
        self._feature_id: FeatureId | None = None
        self._action_id: ActionId | None = None
        super().__init__()

    @property
    def is_response_protobuf(self) -> bool:
        """Is this a protobuf response?

        Returns:
            bool: True if protobuf, False otherwise
        """
        return isinstance(self._identifier, (ActionId, FeatureId))

    @classmethod
    def get_response_identifier(cls, uuid: BleUUID, packet: bytearray) -> ResponseType:
        """Get the identifier based on what is currently known about the packet

        Args:
            uuid (BleUUID): UUID packet was received on
            packet (bytearray): raw bytes contained in packet

        Returns:
            ResponseType: identifier of this response
        """
        # If it's a protobuf command
        identifier = packet[0]
        try:
            FeatureId(identifier)
            return ActionId(packet[1])
        # Otherwise it's a TLV command
        except ValueError:
            if uuid is GoProUUIDs.CQ_SETTINGS_RESP:
                return SettingId(identifier)
            if uuid is GoProUUIDs.CQ_QUERY_RESP:
                return QueryCmdId(identifier)
            if uuid in [GoProUUIDs.CQ_COMMAND_RESP, GoProUUIDs.CN_NET_MGMT_RESP]:
                return CmdId(identifier)
            return uuid

    def set_parser(self, parser: Parser) -> None:
        """Store a parser. This is optional.

        Args:
            parser (Parser): monolithic parser
        """
        self._parser = parser

    def set_packet(self, packet: bytes) -> None:
        """Store the complete data that comprises the response.

        This is mutually exclusive with accumulate. It is only for responses (such as direct UUID reads) that
        do not follow the packet fragmentation scheme.

        Args:
            packet (bytes): packet to store
        """
        self._packet = bytearray(packet)

    def accumulate(self, data: bytes) -> None:
        """Accumulate BLE byte data.

        This is mutually exclusive with accumulate. It should be used in any case where the response follows
        the packet fragmentation scheme.

        Args:
            data (bytes): byte level BLE data
        """
        buf = bytearray(data)
        if buf[0] & CONT_MASK:
            buf.pop(0)
        else:
            # This is a new packet so start with an empty byte array
            self._packet = bytearray([])
            hdr = Header((buf[0] & HDR_MASK) >> 5)
            if hdr is Header.GENERAL:
                self._bytes_remaining = buf[0] & GEN_LEN_MASK
                buf = buf[1:]
            elif hdr is Header.EXT_13:
                self._bytes_remaining = ((buf[0] & EXT_13_BYTE0_MASK) << 8) + buf[1]
                buf = buf[2:]
            elif hdr is Header.EXT_16:
                self._bytes_remaining = (buf[1] << 8) + buf[2]
                buf = buf[3:]

        # Append payload to buffer and update remaining / complete
        self._packet.extend(buf)
        self._bytes_remaining -= len(buf)

        if self._bytes_remaining < 0:
            logger.error("received too much data. parsing is in unknown state")
        elif self._bytes_remaining == 0:
            self._state = RespBuilder._State.ACCUMULATED

    def set_status(self, status: ErrorCode) -> None:
        """Store the status. This is sometimes optional.

        Args:
            status (ErrorCode): status
        """
        self._status = status

    def set_uuid(self, uuid: BleUUID) -> None:
        """Store the UUID. This is mandatory.

        Args:
            uuid (BleUUID): uuid
        """
        self._uuid = uuid

    @property
    def is_finished_accumulating(self) -> bool:
        """Has the response been completely received?

        Returns:
            bool: True if completely received, False if not
        """
        return self._state is not RespBuilder._State.INITIALIZED

    @property
    def _is_protobuf(self) -> bool:
        """Is this response a protobuf response

        Returns:
            bool: Yes if true, No otherwise
        """
        return isinstance(self._identifier, (ActionId, FeatureId))

    @property
    def _is_direct_read(self) -> bool:
        """Is this response a direct read of a BLE characteristic

        Returns:
            bool: Yes if true, No otherwise
        """
        return isinstance(self._identifier, BleUUID)

    def build(self) -> GoProResp:
        """Parse the accumulated response (either from a BLE bytestream or an HTTP JSON dict).

        Raises:
            NotImplementedError: Parsing for this id is not yet supported
            ResponseParseError: Error when parsing data

        Returns:
            GoProResp: built response
        """
        try:
            self._identifier = self.get_response_identifier(self._uuid, self._packet)
            buf = self._packet

            if not self._is_direct_read:  # length byte
                buf.pop(0)
            if self._is_protobuf:  # feature ID byte
                buf.pop(0)

            parsed: Any = None
            query_type: type[StatusId] | type[SettingId] | StatusId | SettingId | None = None
            # Need to delineate QueryCmd responses between settings and status
            if not self._is_protobuf:
                if isinstance(self._identifier, (SettingId, StatusId)):
                    query_type = self._identifier
                elif isinstance(self._identifier, QueryCmdId):
                    if self._identifier in [
                        QueryCmdId.GET_STATUS_VAL,
                        QueryCmdId.REG_STATUS_VAL_UPDATE,
                        QueryCmdId.UNREG_STATUS_VAL_UPDATE,
                        QueryCmdId.STATUS_VAL_PUSH,
                    ]:
                        query_type = StatusId
                    elif self._identifier is QueryCmdId.GET_SETTING_NAME:
                        raise NotImplementedError
                    else:
                        query_type = SettingId

            # Query (setting get value, status get value, etc.)
            if query_type:
                camera_state: CameraState = defaultdict(list)
                self._status = ErrorCode(buf[0])
                buf = buf[1:]
                # Parse all parameters
                while len(buf) != 0:
                    param_id = query_type(buf[0])  # type: ignore
                    param_len = buf[1]
                    buf = buf[2:]
                    # Special case where we register for a push notification for something that does not yet
                    # have a value
                    if param_len == 0:
                        camera_state[param_id] = []
                        continue
                    param_val = buf[:param_len]
                    buf = buf[param_len:]

                    # Add parsed value to response's data dict
                    try:
                        if not (parser := GlobalParsers.get_parser(param_id)):
                            # We don't have defined params for all ID's yet. Just store raw bytes
                            logger.warning(f"No parser defined for {param_id}")
                            camera_state[param_id] = param_val.hex(":")
                            continue
                        # These can be more than 1 value so use a list
                        if self._identifier in [
                            QueryCmdId.GET_CAPABILITIES_VAL,
                            QueryCmdId.REG_CAPABILITIES_UPDATE,
                            QueryCmdId.SETTING_CAPABILITY_PUSH,
                        ]:
                            # Parse using parser from global map and append
                            camera_state[param_id].append(parser.parse(param_val))
                        else:
                            # Parse using parser from map and set
                            camera_state[param_id] = parser.parse(param_val)
                    except ValueError:
                        # This is the case where we receive a value that is not defined in our params.
                        # This shouldn't happen and means the documentation needs to be updated. However, it
                        # isn't functionally critical
                        logger.warning(f"{param_id} does not contain a value {param_val}")
                        camera_state[param_id] = param_val
                parsed = camera_state

            else:  # Commands,  Protobuf, and direct Reads
                if is_cmd := isinstance(self._identifier, CmdId):
                    # All (non-protobuf) commands have a status
                    self._status = ErrorCode(buf[0])
                    buf = buf[1:]
                # Use parser if explicitly passed otherwise get global parser
                if not (parser := self._parser or GlobalParsers.get_parser(self._identifier)) and not is_cmd:
                    error_msg = f"No parser exists for {self._identifier}"
                    logger.error(error_msg)
                    raise ResponseParseError(str(self._identifier), self._packet, msg=error_msg)
                # Parse payload if a parser was found.
                if parser:
                    parsed = parser.parse(buf)

                # TODO make status checking an abstract method of a shared base class
                # Attempt to determine and / or extract status (we already got command status above)
                if self._is_direct_read and len(self._packet):
                    # Assume success on direct reads if there was any data
                    self._status = ErrorCode.SUCCESS
                # Check for result field in protobuf's
                elif self._is_protobuf and "result" in parsed:
                    self._status = (
                        ErrorCode.SUCCESS
                        if parsed.get("result") == EnumResultGeneric.RESULT_SUCCESS
                        else ErrorCode.ERROR
                    )
        except Exception as e:
            self._state = RespBuilder._State.ERROR
            raise ResponseParseError(str(self._identifier), buf) from e

        # Recursively scrub away parsing artifacts
        self._state = RespBuilder._State.PARSED

        return GoProResp(protocol=GoProResp.Protocol.BLE, status=self._status, data=parsed, identifier=self._identifier)

================
File: demos/python/sdk_wireless_camera_control/open_gopro/proto/__init__.py
================
# __init__.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Wed, Sep  1, 2021  5:05:49 PM

"""Protobufs that will be needed by the user.

They are imported here so they can be imported from open_gopro.proto
"""
from open_gopro.proto.cohn_pb2 import (
    EnumCOHNNetworkState,
    EnumCOHNStatus,
    NotifyCOHNStatus,
    RequestClearCOHNCert,
    RequestCOHNCert,
    RequestCreateCOHNCert,
    RequestGetCOHNStatus,
    RequestSetCOHNSetting,
    ResponseCOHNCert,
)
from open_gopro.proto.live_streaming_pb2 import (
    EnumLens,
    EnumLiveStreamStatus,
    EnumRegisterLiveStreamStatus,
    EnumWindowSize,
    NotifyLiveStreamStatus,
    RequestGetLiveStreamStatus,
    RequestSetLiveStreamMode,
)
from open_gopro.proto.media_pb2 import (
    RequestGetLastCapturedMedia,
    ResponseLastCapturedMedia,
)
from open_gopro.proto.network_management_pb2 import (
    EnumProvisioning,
    EnumScanEntryFlags,
    EnumScanning,
    NotifProvisioningState,
    NotifStartScanning,
    RequestConnect,
    RequestConnectNew,
    RequestGetApEntries,
    RequestReleaseNetwork,
    RequestStartScan,
    ResponseConnect,
    ResponseConnectNew,
    ResponseGetApEntries,
    ResponseStartScanning,
)
from open_gopro.proto.preset_status_pb2 import (
    EnumPresetGroup,
    EnumPresetIcon,
    EnumPresetTitle,
    NotifyPresetStatus,
    Preset,
    PresetGroup,
    PresetSetting,
    RequestCustomPresetUpdate,
)
from open_gopro.proto.request_get_preset_status_pb2 import (
    EnumRegisterPresetStatus,
    RequestGetPresetStatus,
)
from open_gopro.proto.response_generic_pb2 import (
    EnumResultGeneric,
    Media,
    ResponseGeneric,
)
from open_gopro.proto.set_camera_control_status_pb2 import (
    EnumCameraControlStatus,
    RequestSetCameraControlStatus,
)
from open_gopro.proto.turbo_transfer_pb2 import RequestSetTurboActive

================
File: demos/python/sdk_wireless_camera_control/open_gopro/proto/cohn_pb2.py
================
# cohn_pb2.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Mon Sep  9 19:50:27 UTC 2024

"""Generated protocol buffer code."""

from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder

_sym_db = _symbol_database.Default()
from . import response_generic_pb2 as response__generic__pb2

DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(
    b'\n\ncohn.proto\x12\nopen_gopro\x1a\x16response_generic.proto"4\n\x14RequestGetCOHNStatus\x12\x1c\n\x14register_cohn_status\x18\x01 \x01(\x08"\xd9\x01\n\x10NotifyCOHNStatus\x12*\n\x06status\x18\x01 \x01(\x0e2\x1a.open_gopro.EnumCOHNStatus\x12/\n\x05state\x18\x02 \x01(\x0e2 .open_gopro.EnumCOHNNetworkState\x12\x10\n\x08username\x18\x03 \x01(\t\x12\x10\n\x08password\x18\x04 \x01(\t\x12\x11\n\tipaddress\x18\x05 \x01(\t\x12\x0f\n\x07enabled\x18\x06 \x01(\x08\x12\x0c\n\x04ssid\x18\x07 \x01(\t\x12\x12\n\nmacaddress\x18\x08 \x01(\t")\n\x15RequestCreateCOHNCert\x12\x10\n\x08override\x18\x01 \x01(\x08"\x16\n\x14RequestClearCOHNCert"\x11\n\x0fRequestCOHNCert"O\n\x10ResponseCOHNCert\x12-\n\x06result\x18\x01 \x01(\x0e2\x1d.open_gopro.EnumResultGeneric\x12\x0c\n\x04cert\x18\x02 \x01(\t",\n\x15RequestSetCOHNSetting\x12\x13\n\x0bcohn_active\x18\x01 \x01(\x08*>\n\x0eEnumCOHNStatus\x12\x16\n\x12COHN_UNPROVISIONED\x10\x00\x12\x14\n\x10COHN_PROVISIONED\x10\x01*\xec\x01\n\x14EnumCOHNNetworkState\x12\x13\n\x0fCOHN_STATE_Init\x10\x00\x12\x14\n\x10COHN_STATE_Error\x10\x01\x12\x13\n\x0fCOHN_STATE_Exit\x10\x02\x12\x13\n\x0fCOHN_STATE_Idle\x10\x05\x12\x1f\n\x1bCOHN_STATE_NetworkConnected\x10\x1b\x12"\n\x1eCOHN_STATE_NetworkDisconnected\x10\x1c\x12"\n\x1eCOHN_STATE_ConnectingToNetwork\x10\x1d\x12\x16\n\x12COHN_STATE_Invalid\x10\x1e'
)
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, globals())
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, "cohn_pb2", globals())
if _descriptor._USE_C_DESCRIPTORS == False:
    DESCRIPTOR._options = None
    _ENUMCOHNSTATUS._serialized_start = 537
    _ENUMCOHNSTATUS._serialized_end = 599
    _ENUMCOHNNETWORKSTATE._serialized_start = 602
    _ENUMCOHNNETWORKSTATE._serialized_end = 838
    _REQUESTGETCOHNSTATUS._serialized_start = 50
    _REQUESTGETCOHNSTATUS._serialized_end = 102
    _NOTIFYCOHNSTATUS._serialized_start = 105
    _NOTIFYCOHNSTATUS._serialized_end = 322
    _REQUESTCREATECOHNCERT._serialized_start = 324
    _REQUESTCREATECOHNCERT._serialized_end = 365
    _REQUESTCLEARCOHNCERT._serialized_start = 367
    _REQUESTCLEARCOHNCERT._serialized_end = 389
    _REQUESTCOHNCERT._serialized_start = 391
    _REQUESTCOHNCERT._serialized_end = 408
    _RESPONSECOHNCERT._serialized_start = 410
    _RESPONSECOHNCERT._serialized_end = 489
    _REQUESTSETCOHNSETTING._serialized_start = 491
    _REQUESTSETCOHNSETTING._serialized_end = 535

================
File: demos/python/sdk_wireless_camera_control/open_gopro/proto/cohn_pb2.pyi
================
"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
*
Defines the structure of protobuf messages for Camera On the Home Network
"""

import builtins
import google.protobuf.descriptor
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
from . import response_generic_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _EnumCOHNStatus:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EnumCOHNStatusEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnumCOHNStatus.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    COHN_UNPROVISIONED: _EnumCOHNStatus.ValueType
    COHN_PROVISIONED: _EnumCOHNStatus.ValueType

class EnumCOHNStatus(_EnumCOHNStatus, metaclass=_EnumCOHNStatusEnumTypeWrapper): ...

COHN_UNPROVISIONED: EnumCOHNStatus.ValueType
COHN_PROVISIONED: EnumCOHNStatus.ValueType
global___EnumCOHNStatus = EnumCOHNStatus

class _EnumCOHNNetworkState:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EnumCOHNNetworkStateEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnumCOHNNetworkState.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    COHN_STATE_Init: _EnumCOHNNetworkState.ValueType
    COHN_STATE_Error: _EnumCOHNNetworkState.ValueType
    COHN_STATE_Exit: _EnumCOHNNetworkState.ValueType
    COHN_STATE_Idle: _EnumCOHNNetworkState.ValueType
    COHN_STATE_NetworkConnected: _EnumCOHNNetworkState.ValueType
    COHN_STATE_NetworkDisconnected: _EnumCOHNNetworkState.ValueType
    COHN_STATE_ConnectingToNetwork: _EnumCOHNNetworkState.ValueType
    COHN_STATE_Invalid: _EnumCOHNNetworkState.ValueType

class EnumCOHNNetworkState(_EnumCOHNNetworkState, metaclass=_EnumCOHNNetworkStateEnumTypeWrapper): ...

COHN_STATE_Init: EnumCOHNNetworkState.ValueType
COHN_STATE_Error: EnumCOHNNetworkState.ValueType
COHN_STATE_Exit: EnumCOHNNetworkState.ValueType
COHN_STATE_Idle: EnumCOHNNetworkState.ValueType
COHN_STATE_NetworkConnected: EnumCOHNNetworkState.ValueType
COHN_STATE_NetworkDisconnected: EnumCOHNNetworkState.ValueType
COHN_STATE_ConnectingToNetwork: EnumCOHNNetworkState.ValueType
COHN_STATE_Invalid: EnumCOHNNetworkState.ValueType
global___EnumCOHNNetworkState = EnumCOHNNetworkState

@typing_extensions.final
class RequestGetCOHNStatus(google.protobuf.message.Message):
    """*
    Get the current COHN status.

    Response: @ref NotifyCOHNStatus

    Additionally, asynchronous updates can also be registered to return more @ref NotifyCOHNStatus when a value
    changes.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    REGISTER_COHN_STATUS_FIELD_NUMBER: builtins.int
    register_cohn_status: builtins.bool
    "1 to register, 0 to unregister"

    def __init__(self, *, register_cohn_status: builtins.bool | None = ...) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal["register_cohn_status", b"register_cohn_status"],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal["register_cohn_status", b"register_cohn_status"],
    ) -> None: ...

global___RequestGetCOHNStatus = RequestGetCOHNStatus

@typing_extensions.final
class NotifyCOHNStatus(google.protobuf.message.Message):
    """
    Current COHN status triggered by a @ref RequestGetCOHNStatus
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    STATUS_FIELD_NUMBER: builtins.int
    STATE_FIELD_NUMBER: builtins.int
    USERNAME_FIELD_NUMBER: builtins.int
    PASSWORD_FIELD_NUMBER: builtins.int
    IPADDRESS_FIELD_NUMBER: builtins.int
    ENABLED_FIELD_NUMBER: builtins.int
    SSID_FIELD_NUMBER: builtins.int
    MACADDRESS_FIELD_NUMBER: builtins.int
    status: global___EnumCOHNStatus.ValueType
    "Current COHN status"
    state: global___EnumCOHNNetworkState.ValueType
    "Current COHN network state"
    username: builtins.str
    "Username used for http basic auth header"
    password: builtins.str
    "Password used for http basic auth header"
    ipaddress: builtins.str
    "Camera's IP address on the local network"
    enabled: builtins.bool
    "Is COHN currently enabled?"
    ssid: builtins.str
    "Currently connected SSID"
    macaddress: builtins.str
    "MAC address of the wifi adapter"

    def __init__(
        self,
        *,
        status: global___EnumCOHNStatus.ValueType | None = ...,
        state: global___EnumCOHNNetworkState.ValueType | None = ...,
        username: builtins.str | None = ...,
        password: builtins.str | None = ...,
        ipaddress: builtins.str | None = ...,
        enabled: builtins.bool | None = ...,
        ssid: builtins.str | None = ...,
        macaddress: builtins.str | None = ...
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "enabled",
            b"enabled",
            "ipaddress",
            b"ipaddress",
            "macaddress",
            b"macaddress",
            "password",
            b"password",
            "ssid",
            b"ssid",
            "state",
            b"state",
            "status",
            b"status",
            "username",
            b"username",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "enabled",
            b"enabled",
            "ipaddress",
            b"ipaddress",
            "macaddress",
            b"macaddress",
            "password",
            b"password",
            "ssid",
            b"ssid",
            "state",
            b"state",
            "status",
            b"status",
            "username",
            b"username",
        ],
    ) -> None: ...

global___NotifyCOHNStatus = NotifyCOHNStatus

@typing_extensions.final
class RequestCreateCOHNCert(google.protobuf.message.Message):
    """*
    Create the Camera On the Home Network SSL/TLS certificate.

    Returns a @ref ResponseGeneric with the status of the creation
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    OVERRIDE_FIELD_NUMBER: builtins.int
    override: builtins.bool
    "Override current provisioning and create new cert"

    def __init__(self, *, override: builtins.bool | None = ...) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["override", b"override"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["override", b"override"]) -> None: ...

global___RequestCreateCOHNCert = RequestCreateCOHNCert

@typing_extensions.final
class RequestClearCOHNCert(google.protobuf.message.Message):
    """*
    Clear the COHN certificate.

    Returns a @ref ResponseGeneric with the status of the clear
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(self) -> None: ...

global___RequestClearCOHNCert = RequestClearCOHNCert

@typing_extensions.final
class RequestCOHNCert(google.protobuf.message.Message):
    """*
    Get the COHN certificate.

    Returns a @ref ResponseCOHNCert
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(self) -> None: ...

global___RequestCOHNCert = RequestCOHNCert

@typing_extensions.final
class ResponseCOHNCert(google.protobuf.message.Message):
    """
    COHN Certificate response triggered by @ref RequestCOHNCert
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    RESULT_FIELD_NUMBER: builtins.int
    CERT_FIELD_NUMBER: builtins.int
    result: response_generic_pb2.EnumResultGeneric.ValueType
    "Was request successful?"
    cert: builtins.str
    "Root CA cert (ASCII text)"

    def __init__(
        self, *, result: response_generic_pb2.EnumResultGeneric.ValueType | None = ..., cert: builtins.str | None = ...
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal["cert", b"cert", "result", b"result"],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal["cert", b"cert", "result", b"result"],
    ) -> None: ...

global___ResponseCOHNCert = ResponseCOHNCert

@typing_extensions.final
class RequestSetCOHNSetting(google.protobuf.message.Message):
    """*
    Configure a COHN Setting

    Returns a @ref ResponseGeneric
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    COHN_ACTIVE_FIELD_NUMBER: builtins.int
    cohn_active: builtins.bool
    "*\n    1 to enable COHN, 0 to disable COHN\n\n    When set to 1, STA Mode connection will be dropped and camera will not automatically re-connect for COHN.\n    "

    def __init__(self, *, cohn_active: builtins.bool | None = ...) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["cohn_active", b"cohn_active"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["cohn_active", b"cohn_active"]) -> None: ...

global___RequestSetCOHNSetting = RequestSetCOHNSetting

================
File: demos/python/sdk_wireless_camera_control/open_gopro/proto/live_streaming_pb2.py
================
# live_streaming_pb2.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Mon Sep  9 19:50:27 UTC 2024

"""Generated protocol buffer code."""

from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder

_sym_db = _symbol_database.Default()
DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(
    b'\n\x14live_streaming.proto\x12\nopen_gopro"\xcb\x04\n\x16NotifyLiveStreamStatus\x12<\n\x12live_stream_status\x18\x01 \x01(\x0e2 .open_gopro.EnumLiveStreamStatus\x12:\n\x11live_stream_error\x18\x02 \x01(\x0e2\x1f.open_gopro.EnumLiveStreamError\x12\x1a\n\x12live_stream_encode\x18\x03 \x01(\x08\x12\x1b\n\x13live_stream_bitrate\x18\x04 \x01(\x05\x12K\n\'live_stream_window_size_supported_array\x18\x05 \x03(\x0e2\x1a.open_gopro.EnumWindowSize\x12$\n\x1clive_stream_encode_supported\x18\x06 \x01(\x08\x12(\n live_stream_max_lens_unsupported\x18\x07 \x01(\x08\x12*\n"live_stream_minimum_stream_bitrate\x18\x08 \x01(\x05\x12*\n"live_stream_maximum_stream_bitrate\x18\t \x01(\x05\x12"\n\x1alive_stream_lens_supported\x18\n \x01(\x08\x12>\n live_stream_lens_supported_array\x18\x0b \x03(\x0e2\x14.open_gopro.EnumLens\x12%\n\x1dlive_stream_protune_supported\x18\r \x01(\x08"\xbc\x01\n\x1aRequestGetLiveStreamStatus\x12M\n\x1bregister_live_stream_status\x18\x01 \x03(\x0e2(.open_gopro.EnumRegisterLiveStreamStatus\x12O\n\x1dunregister_live_stream_status\x18\x02 \x03(\x0e2(.open_gopro.EnumRegisterLiveStreamStatus"\xe6\x01\n\x18RequestSetLiveStreamMode\x12\x0b\n\x03url\x18\x01 \x01(\t\x12\x0e\n\x06encode\x18\x02 \x01(\x08\x12/\n\x0bwindow_size\x18\x03 \x01(\x0e2\x1a.open_gopro.EnumWindowSize\x12\x0c\n\x04cert\x18\x06 \x01(\x0c\x12\x17\n\x0fminimum_bitrate\x18\x07 \x01(\x05\x12\x17\n\x0fmaximum_bitrate\x18\x08 \x01(\x05\x12\x18\n\x10starting_bitrate\x18\t \x01(\x05\x12"\n\x04lens\x18\n \x01(\x0e2\x14.open_gopro.EnumLens*>\n\x08EnumLens\x12\r\n\tLENS_WIDE\x10\x00\x12\x0f\n\x0bLENS_LINEAR\x10\x04\x12\x12\n\x0eLENS_SUPERVIEW\x10\x03*\xde\x03\n\x13EnumLiveStreamError\x12\x1a\n\x16LIVE_STREAM_ERROR_NONE\x10\x00\x12\x1d\n\x19LIVE_STREAM_ERROR_NETWORK\x10\x01\x12"\n\x1eLIVE_STREAM_ERROR_CREATESTREAM\x10\x02\x12!\n\x1dLIVE_STREAM_ERROR_OUTOFMEMORY\x10\x03\x12!\n\x1dLIVE_STREAM_ERROR_INPUTSTREAM\x10\x04\x12\x1e\n\x1aLIVE_STREAM_ERROR_INTERNET\x10\x05\x12\x1f\n\x1bLIVE_STREAM_ERROR_OSNETWORK\x10\x06\x12,\n(LIVE_STREAM_ERROR_SELECTEDNETWORKTIMEOUT\x10\x07\x12#\n\x1fLIVE_STREAM_ERROR_SSL_HANDSHAKE\x10\x08\x12$\n LIVE_STREAM_ERROR_CAMERA_BLOCKED\x10\t\x12\x1d\n\x19LIVE_STREAM_ERROR_UNKNOWN\x10\n\x12"\n\x1eLIVE_STREAM_ERROR_SD_CARD_FULL\x10(\x12%\n!LIVE_STREAM_ERROR_SD_CARD_REMOVED\x10)*\xa3\x02\n\x14EnumLiveStreamStatus\x12\x1a\n\x16LIVE_STREAM_STATE_IDLE\x10\x00\x12\x1c\n\x18LIVE_STREAM_STATE_CONFIG\x10\x01\x12\x1b\n\x17LIVE_STREAM_STATE_READY\x10\x02\x12\x1f\n\x1bLIVE_STREAM_STATE_STREAMING\x10\x03\x12&\n"LIVE_STREAM_STATE_COMPLETE_STAY_ON\x10\x04\x12$\n LIVE_STREAM_STATE_FAILED_STAY_ON\x10\x05\x12"\n\x1eLIVE_STREAM_STATE_RECONNECTING\x10\x06\x12!\n\x1dLIVE_STREAM_STATE_UNAVAILABLE\x10\x07*\xbc\x01\n\x1cEnumRegisterLiveStreamStatus\x12&\n"REGISTER_LIVE_STREAM_STATUS_STATUS\x10\x01\x12%\n!REGISTER_LIVE_STREAM_STATUS_ERROR\x10\x02\x12$\n REGISTER_LIVE_STREAM_STATUS_MODE\x10\x03\x12\'\n#REGISTER_LIVE_STREAM_STATUS_BITRATE\x10\x04*P\n\x0eEnumWindowSize\x12\x13\n\x0fWINDOW_SIZE_480\x10\x04\x12\x13\n\x0fWINDOW_SIZE_720\x10\x07\x12\x14\n\x10WINDOW_SIZE_1080\x10\x0c'
)
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, globals())
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, "live_streaming_pb2", globals())
if _descriptor._USE_C_DESCRIPTORS == False:
    DESCRIPTOR._options = None
    _ENUMLENS._serialized_start = 1050
    _ENUMLENS._serialized_end = 1112
    _ENUMLIVESTREAMERROR._serialized_start = 1115
    _ENUMLIVESTREAMERROR._serialized_end = 1593
    _ENUMLIVESTREAMSTATUS._serialized_start = 1596
    _ENUMLIVESTREAMSTATUS._serialized_end = 1887
    _ENUMREGISTERLIVESTREAMSTATUS._serialized_start = 1890
    _ENUMREGISTERLIVESTREAMSTATUS._serialized_end = 2078
    _ENUMWINDOWSIZE._serialized_start = 2080
    _ENUMWINDOWSIZE._serialized_end = 2160
    _NOTIFYLIVESTREAMSTATUS._serialized_start = 37
    _NOTIFYLIVESTREAMSTATUS._serialized_end = 624
    _REQUESTGETLIVESTREAMSTATUS._serialized_start = 627
    _REQUESTGETLIVESTREAMSTATUS._serialized_end = 815
    _REQUESTSETLIVESTREAMMODE._serialized_start = 818
    _REQUESTSETLIVESTREAMMODE._serialized_end = 1048

================
File: demos/python/sdk_wireless_camera_control/open_gopro/proto/live_streaming_pb2.pyi
================
"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
*
Defines the structure of protobuf messages for working with Live Streams
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _EnumLens:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EnumLensEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnumLens.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    LENS_WIDE: _EnumLens.ValueType
    LENS_LINEAR: _EnumLens.ValueType
    LENS_SUPERVIEW: _EnumLens.ValueType

class EnumLens(_EnumLens, metaclass=_EnumLensEnumTypeWrapper): ...

LENS_WIDE: EnumLens.ValueType
LENS_LINEAR: EnumLens.ValueType
LENS_SUPERVIEW: EnumLens.ValueType
global___EnumLens = EnumLens

class _EnumLiveStreamError:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EnumLiveStreamErrorEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnumLiveStreamError.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    LIVE_STREAM_ERROR_NONE: _EnumLiveStreamError.ValueType
    "No error (success)"
    LIVE_STREAM_ERROR_NETWORK: _EnumLiveStreamError.ValueType
    "General network error during the stream"
    LIVE_STREAM_ERROR_CREATESTREAM: _EnumLiveStreamError.ValueType
    "Startup error: bad URL or valid with live stream server"
    LIVE_STREAM_ERROR_OUTOFMEMORY: _EnumLiveStreamError.ValueType
    "Not enough memory on camera to complete task"
    LIVE_STREAM_ERROR_INPUTSTREAM: _EnumLiveStreamError.ValueType
    "Failed to get stream from low level camera system"
    LIVE_STREAM_ERROR_INTERNET: _EnumLiveStreamError.ValueType
    "No internet access detected on startup of streamer"
    LIVE_STREAM_ERROR_OSNETWORK: _EnumLiveStreamError.ValueType
    "Error occured in linux networking stack. Usually means the server closed the connection"
    LIVE_STREAM_ERROR_SELECTEDNETWORKTIMEOUT: _EnumLiveStreamError.ValueType
    "Timed out attemping to connect to the wifi network when attemping live stream"
    LIVE_STREAM_ERROR_SSL_HANDSHAKE: _EnumLiveStreamError.ValueType
    "SSL handshake failed (commonly caused due to incorrect time / time zone)"
    LIVE_STREAM_ERROR_CAMERA_BLOCKED: _EnumLiveStreamError.ValueType
    "Low level camera system rejected attempt to start live stream"
    LIVE_STREAM_ERROR_UNKNOWN: _EnumLiveStreamError.ValueType
    "Unknown"
    LIVE_STREAM_ERROR_SD_CARD_FULL: _EnumLiveStreamError.ValueType
    "Can not perform livestream because sd card is full"
    LIVE_STREAM_ERROR_SD_CARD_REMOVED: _EnumLiveStreamError.ValueType
    "Livestream stopped because sd card was removed"

class EnumLiveStreamError(_EnumLiveStreamError, metaclass=_EnumLiveStreamErrorEnumTypeWrapper): ...

LIVE_STREAM_ERROR_NONE: EnumLiveStreamError.ValueType
"No error (success)"
LIVE_STREAM_ERROR_NETWORK: EnumLiveStreamError.ValueType
"General network error during the stream"
LIVE_STREAM_ERROR_CREATESTREAM: EnumLiveStreamError.ValueType
"Startup error: bad URL or valid with live stream server"
LIVE_STREAM_ERROR_OUTOFMEMORY: EnumLiveStreamError.ValueType
"Not enough memory on camera to complete task"
LIVE_STREAM_ERROR_INPUTSTREAM: EnumLiveStreamError.ValueType
"Failed to get stream from low level camera system"
LIVE_STREAM_ERROR_INTERNET: EnumLiveStreamError.ValueType
"No internet access detected on startup of streamer"
LIVE_STREAM_ERROR_OSNETWORK: EnumLiveStreamError.ValueType
"Error occured in linux networking stack. Usually means the server closed the connection"
LIVE_STREAM_ERROR_SELECTEDNETWORKTIMEOUT: EnumLiveStreamError.ValueType
"Timed out attemping to connect to the wifi network when attemping live stream"
LIVE_STREAM_ERROR_SSL_HANDSHAKE: EnumLiveStreamError.ValueType
"SSL handshake failed (commonly caused due to incorrect time / time zone)"
LIVE_STREAM_ERROR_CAMERA_BLOCKED: EnumLiveStreamError.ValueType
"Low level camera system rejected attempt to start live stream"
LIVE_STREAM_ERROR_UNKNOWN: EnumLiveStreamError.ValueType
"Unknown"
LIVE_STREAM_ERROR_SD_CARD_FULL: EnumLiveStreamError.ValueType
"Can not perform livestream because sd card is full"
LIVE_STREAM_ERROR_SD_CARD_REMOVED: EnumLiveStreamError.ValueType
"Livestream stopped because sd card was removed"
global___EnumLiveStreamError = EnumLiveStreamError

class _EnumLiveStreamStatus:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EnumLiveStreamStatusEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnumLiveStreamStatus.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    LIVE_STREAM_STATE_IDLE: _EnumLiveStreamStatus.ValueType
    "Initial status. Livestream has not yet been configured"
    LIVE_STREAM_STATE_CONFIG: _EnumLiveStreamStatus.ValueType
    "Livestream is being configured"
    LIVE_STREAM_STATE_READY: _EnumLiveStreamStatus.ValueType
    "Livestream has finished configuration and is ready to start streaming"
    LIVE_STREAM_STATE_STREAMING: _EnumLiveStreamStatus.ValueType
    "Livestream is actively streaming"
    LIVE_STREAM_STATE_COMPLETE_STAY_ON: _EnumLiveStreamStatus.ValueType
    "Live stream is exiting. No errors occured."
    LIVE_STREAM_STATE_FAILED_STAY_ON: _EnumLiveStreamStatus.ValueType
    "Live stream is exiting. An error occurred."
    LIVE_STREAM_STATE_RECONNECTING: _EnumLiveStreamStatus.ValueType
    "An error occurred during livestream and stream is attempting to reconnect."
    LIVE_STREAM_STATE_UNAVAILABLE: _EnumLiveStreamStatus.ValueType
    "Live stream setup is unavailable due to camera lens configuration"

class EnumLiveStreamStatus(_EnumLiveStreamStatus, metaclass=_EnumLiveStreamStatusEnumTypeWrapper): ...

LIVE_STREAM_STATE_IDLE: EnumLiveStreamStatus.ValueType
"Initial status. Livestream has not yet been configured"
LIVE_STREAM_STATE_CONFIG: EnumLiveStreamStatus.ValueType
"Livestream is being configured"
LIVE_STREAM_STATE_READY: EnumLiveStreamStatus.ValueType
"Livestream has finished configuration and is ready to start streaming"
LIVE_STREAM_STATE_STREAMING: EnumLiveStreamStatus.ValueType
"Livestream is actively streaming"
LIVE_STREAM_STATE_COMPLETE_STAY_ON: EnumLiveStreamStatus.ValueType
"Live stream is exiting. No errors occured."
LIVE_STREAM_STATE_FAILED_STAY_ON: EnumLiveStreamStatus.ValueType
"Live stream is exiting. An error occurred."
LIVE_STREAM_STATE_RECONNECTING: EnumLiveStreamStatus.ValueType
"An error occurred during livestream and stream is attempting to reconnect."
LIVE_STREAM_STATE_UNAVAILABLE: EnumLiveStreamStatus.ValueType
"Live stream setup is unavailable due to camera lens configuration"
global___EnumLiveStreamStatus = EnumLiveStreamStatus

class _EnumRegisterLiveStreamStatus:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EnumRegisterLiveStreamStatusEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnumRegisterLiveStreamStatus.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    REGISTER_LIVE_STREAM_STATUS_STATUS: _EnumRegisterLiveStreamStatus.ValueType
    REGISTER_LIVE_STREAM_STATUS_ERROR: _EnumRegisterLiveStreamStatus.ValueType
    REGISTER_LIVE_STREAM_STATUS_MODE: _EnumRegisterLiveStreamStatus.ValueType
    REGISTER_LIVE_STREAM_STATUS_BITRATE: _EnumRegisterLiveStreamStatus.ValueType

class EnumRegisterLiveStreamStatus(
    _EnumRegisterLiveStreamStatus,
    metaclass=_EnumRegisterLiveStreamStatusEnumTypeWrapper,
): ...

REGISTER_LIVE_STREAM_STATUS_STATUS: EnumRegisterLiveStreamStatus.ValueType
REGISTER_LIVE_STREAM_STATUS_ERROR: EnumRegisterLiveStreamStatus.ValueType
REGISTER_LIVE_STREAM_STATUS_MODE: EnumRegisterLiveStreamStatus.ValueType
REGISTER_LIVE_STREAM_STATUS_BITRATE: EnumRegisterLiveStreamStatus.ValueType
global___EnumRegisterLiveStreamStatus = EnumRegisterLiveStreamStatus

class _EnumWindowSize:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EnumWindowSizeEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnumWindowSize.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    WINDOW_SIZE_480: _EnumWindowSize.ValueType
    WINDOW_SIZE_720: _EnumWindowSize.ValueType
    WINDOW_SIZE_1080: _EnumWindowSize.ValueType

class EnumWindowSize(_EnumWindowSize, metaclass=_EnumWindowSizeEnumTypeWrapper): ...

WINDOW_SIZE_480: EnumWindowSize.ValueType
WINDOW_SIZE_720: EnumWindowSize.ValueType
WINDOW_SIZE_1080: EnumWindowSize.ValueType
global___EnumWindowSize = EnumWindowSize

@typing_extensions.final
class NotifyLiveStreamStatus(google.protobuf.message.Message):
    """*
    Live Stream status

    Sent either:

      - As a synchronous response to initial @ref RequestGetLiveStreamStatus
      - As an asynchronous notifications registered for via @ref RequestGetLiveStreamStatus
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    LIVE_STREAM_STATUS_FIELD_NUMBER: builtins.int
    LIVE_STREAM_ERROR_FIELD_NUMBER: builtins.int
    LIVE_STREAM_ENCODE_FIELD_NUMBER: builtins.int
    LIVE_STREAM_BITRATE_FIELD_NUMBER: builtins.int
    LIVE_STREAM_WINDOW_SIZE_SUPPORTED_ARRAY_FIELD_NUMBER: builtins.int
    LIVE_STREAM_ENCODE_SUPPORTED_FIELD_NUMBER: builtins.int
    LIVE_STREAM_MAX_LENS_UNSUPPORTED_FIELD_NUMBER: builtins.int
    LIVE_STREAM_MINIMUM_STREAM_BITRATE_FIELD_NUMBER: builtins.int
    LIVE_STREAM_MAXIMUM_STREAM_BITRATE_FIELD_NUMBER: builtins.int
    LIVE_STREAM_LENS_SUPPORTED_FIELD_NUMBER: builtins.int
    LIVE_STREAM_LENS_SUPPORTED_ARRAY_FIELD_NUMBER: builtins.int
    LIVE_STREAM_PROTUNE_SUPPORTED_FIELD_NUMBER: builtins.int
    live_stream_status: global___EnumLiveStreamStatus.ValueType
    "Live stream status"
    live_stream_error: global___EnumLiveStreamError.ValueType
    "Live stream error"
    live_stream_encode: builtins.bool
    "Is live stream encoding?"
    live_stream_bitrate: builtins.int
    "Live stream bitrate (Kbps)"

    @property
    def live_stream_window_size_supported_array(
        self,
    ) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___EnumWindowSize.ValueType]:
        """Set of currently supported resolutions"""
    live_stream_encode_supported: builtins.bool
    "Does the camera support encoding while live streaming?"
    live_stream_max_lens_unsupported: builtins.bool
    "Is the Max Lens feature NOT supported?"
    live_stream_minimum_stream_bitrate: builtins.int
    "Camera-defined minimum bitrate (static) (Kbps)"
    live_stream_maximum_stream_bitrate: builtins.int
    "Camera-defined maximum bitrate (static) (Kbps)"
    live_stream_lens_supported: builtins.bool
    "Does camera support setting lens for live streaming?"

    @property
    def live_stream_lens_supported_array(
        self,
    ) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___EnumLens.ValueType]:
        """Set of currently supported FOV options"""
    live_stream_protune_supported: builtins.bool
    "Does the camera support live stream protune settings"

    def __init__(
        self,
        *,
        live_stream_status: global___EnumLiveStreamStatus.ValueType | None = ...,
        live_stream_error: global___EnumLiveStreamError.ValueType | None = ...,
        live_stream_encode: builtins.bool | None = ...,
        live_stream_bitrate: builtins.int | None = ...,
        live_stream_window_size_supported_array: (
            collections.abc.Iterable[global___EnumWindowSize.ValueType] | None
        ) = ...,
        live_stream_encode_supported: builtins.bool | None = ...,
        live_stream_max_lens_unsupported: builtins.bool | None = ...,
        live_stream_minimum_stream_bitrate: builtins.int | None = ...,
        live_stream_maximum_stream_bitrate: builtins.int | None = ...,
        live_stream_lens_supported: builtins.bool | None = ...,
        live_stream_lens_supported_array: (collections.abc.Iterable[global___EnumLens.ValueType] | None) = ...,
        live_stream_protune_supported: builtins.bool | None = ...
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "live_stream_bitrate",
            b"live_stream_bitrate",
            "live_stream_encode",
            b"live_stream_encode",
            "live_stream_encode_supported",
            b"live_stream_encode_supported",
            "live_stream_error",
            b"live_stream_error",
            "live_stream_lens_supported",
            b"live_stream_lens_supported",
            "live_stream_max_lens_unsupported",
            b"live_stream_max_lens_unsupported",
            "live_stream_maximum_stream_bitrate",
            b"live_stream_maximum_stream_bitrate",
            "live_stream_minimum_stream_bitrate",
            b"live_stream_minimum_stream_bitrate",
            "live_stream_protune_supported",
            b"live_stream_protune_supported",
            "live_stream_status",
            b"live_stream_status",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "live_stream_bitrate",
            b"live_stream_bitrate",
            "live_stream_encode",
            b"live_stream_encode",
            "live_stream_encode_supported",
            b"live_stream_encode_supported",
            "live_stream_error",
            b"live_stream_error",
            "live_stream_lens_supported",
            b"live_stream_lens_supported",
            "live_stream_lens_supported_array",
            b"live_stream_lens_supported_array",
            "live_stream_max_lens_unsupported",
            b"live_stream_max_lens_unsupported",
            "live_stream_maximum_stream_bitrate",
            b"live_stream_maximum_stream_bitrate",
            "live_stream_minimum_stream_bitrate",
            b"live_stream_minimum_stream_bitrate",
            "live_stream_protune_supported",
            b"live_stream_protune_supported",
            "live_stream_status",
            b"live_stream_status",
            "live_stream_window_size_supported_array",
            b"live_stream_window_size_supported_array",
        ],
    ) -> None: ...

global___NotifyLiveStreamStatus = NotifyLiveStreamStatus

@typing_extensions.final
class RequestGetLiveStreamStatus(google.protobuf.message.Message):
    """*
    Get the current livestream status (and optionally register for future status changes)

    Response: @ref NotifyLiveStreamStatus

    Notification: @ref NotifyLiveStreamStatus
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    REGISTER_LIVE_STREAM_STATUS_FIELD_NUMBER: builtins.int
    UNREGISTER_LIVE_STREAM_STATUS_FIELD_NUMBER: builtins.int

    @property
    def register_live_stream_status(
        self,
    ) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[
        global___EnumRegisterLiveStreamStatus.ValueType
    ]:
        """Array of live stream statuses to be notified about"""
    @property
    def unregister_live_stream_status(
        self,
    ) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[
        global___EnumRegisterLiveStreamStatus.ValueType
    ]:
        """Array of live stream statuses to stop being notified about"""
    def __init__(
        self,
        *,
        register_live_stream_status: (
            collections.abc.Iterable[global___EnumRegisterLiveStreamStatus.ValueType] | None
        ) = ...,
        unregister_live_stream_status: (
            collections.abc.Iterable[global___EnumRegisterLiveStreamStatus.ValueType] | None
        ) = ...
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "register_live_stream_status",
            b"register_live_stream_status",
            "unregister_live_stream_status",
            b"unregister_live_stream_status",
        ],
    ) -> None: ...

global___RequestGetLiveStreamStatus = RequestGetLiveStreamStatus

@typing_extensions.final
class RequestSetLiveStreamMode(google.protobuf.message.Message):
    """*
    Configure Live Streaming

    Response: @ref ResponseGeneric
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    URL_FIELD_NUMBER: builtins.int
    ENCODE_FIELD_NUMBER: builtins.int
    WINDOW_SIZE_FIELD_NUMBER: builtins.int
    CERT_FIELD_NUMBER: builtins.int
    MINIMUM_BITRATE_FIELD_NUMBER: builtins.int
    MAXIMUM_BITRATE_FIELD_NUMBER: builtins.int
    STARTING_BITRATE_FIELD_NUMBER: builtins.int
    LENS_FIELD_NUMBER: builtins.int
    url: builtins.str
    "RTMP(S) URL used for live stream"
    encode: builtins.bool
    "Save media to sdcard while streaming?"
    window_size: global___EnumWindowSize.ValueType
    "*\n    Resolution to use for live stream\n\n    The set of supported resolutions is only available from the `live_stream_window_size_supported_array`\n    in @ref NotifyLiveStreamStatus.\n    "
    cert: builtins.bytes
    "Certificate for servers that require it in PEM format"
    minimum_bitrate: builtins.int
    "Minimum desired bitrate (may or may not be honored)"
    maximum_bitrate: builtins.int
    "Maximum desired bitrate (may or may not be honored)"
    starting_bitrate: builtins.int
    "Starting bitrate"
    lens: global___EnumLens.ValueType
    "*\n    Lens to use for live stream\n\n    The set of supported lenses is only available from the  `live_stream_lens_supported_array`\n    in @ref NotifyLiveStreamStatus.\n    "

    def __init__(
        self,
        *,
        url: builtins.str | None = ...,
        encode: builtins.bool | None = ...,
        window_size: global___EnumWindowSize.ValueType | None = ...,
        cert: builtins.bytes | None = ...,
        minimum_bitrate: builtins.int | None = ...,
        maximum_bitrate: builtins.int | None = ...,
        starting_bitrate: builtins.int | None = ...,
        lens: global___EnumLens.ValueType | None = ...
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "cert",
            b"cert",
            "encode",
            b"encode",
            "lens",
            b"lens",
            "maximum_bitrate",
            b"maximum_bitrate",
            "minimum_bitrate",
            b"minimum_bitrate",
            "starting_bitrate",
            b"starting_bitrate",
            "url",
            b"url",
            "window_size",
            b"window_size",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "cert",
            b"cert",
            "encode",
            b"encode",
            "lens",
            b"lens",
            "maximum_bitrate",
            b"maximum_bitrate",
            "minimum_bitrate",
            b"minimum_bitrate",
            "starting_bitrate",
            b"starting_bitrate",
            "url",
            b"url",
            "window_size",
            b"window_size",
        ],
    ) -> None: ...

global___RequestSetLiveStreamMode = RequestSetLiveStreamMode

================
File: demos/python/sdk_wireless_camera_control/open_gopro/proto/media_pb2.py
================
# media_pb2.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Mon Sep  9 19:50:27 UTC 2024

"""Generated protocol buffer code."""

from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder

_sym_db = _symbol_database.Default()
from . import response_generic_pb2 as response__generic__pb2

DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(
    b'\n\x0bmedia.proto\x12\nopen_gopro\x1a\x16response_generic.proto"\x1d\n\x1bRequestGetLastCapturedMedia"l\n\x19ResponseLastCapturedMedia\x12-\n\x06result\x18\x01 \x01(\x0e2\x1d.open_gopro.EnumResultGeneric\x12 \n\x05media\x18\x02 \x01(\x0b2\x11.open_gopro.Media'
)
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, globals())
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, "media_pb2", globals())
if _descriptor._USE_C_DESCRIPTORS == False:
    DESCRIPTOR._options = None
    _REQUESTGETLASTCAPTUREDMEDIA._serialized_start = 51
    _REQUESTGETLASTCAPTUREDMEDIA._serialized_end = 80
    _RESPONSELASTCAPTUREDMEDIA._serialized_start = 82
    _RESPONSELASTCAPTUREDMEDIA._serialized_end = 190

================
File: demos/python/sdk_wireless_camera_control/open_gopro/proto/media_pb2.pyi
================
"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
*
Commands to query and manipulate media files
"""

import builtins
import google.protobuf.descriptor
import google.protobuf.message
from . import response_generic_pb2
import sys

if sys.version_info >= (3, 8):
    import typing as typing_extensions
else:
    import typing_extensions
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class RequestGetLastCapturedMedia(google.protobuf.message.Message):
    """*
    Get the last captured media filename

    Returns a @ref ResponseLastCapturedMedia
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(self) -> None: ...

global___RequestGetLastCapturedMedia = RequestGetLastCapturedMedia

@typing_extensions.final
class ResponseLastCapturedMedia(google.protobuf.message.Message):
    """*
    The Last Captured Media

    Message is sent in response to a @ref RequestGetLastCapturedMedia.

    This contains the relative path of the last captured media starting from the `DCIM` directory on the SDCard. Depending
    on the type of media captured, it will return:

    - The single media path for single photo/video media
    - The path to the first captured media in the group for grouped media
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    RESULT_FIELD_NUMBER: builtins.int
    MEDIA_FIELD_NUMBER: builtins.int
    result: response_generic_pb2.EnumResultGeneric.ValueType
    "Was the request successful?"

    @property
    def media(self) -> response_generic_pb2.Media:
        """*
        Last captured media if result is RESULT_SUCCESS. Invalid if result is RESULT_RESOURCE_NOT_AVAILBLE.
        """
    def __init__(
        self,
        *,
        result: response_generic_pb2.EnumResultGeneric.ValueType | None = ...,
        media: response_generic_pb2.Media | None = ...
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal["media", b"media", "result", b"result"],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal["media", b"media", "result", b"result"],
    ) -> None: ...

global___ResponseLastCapturedMedia = ResponseLastCapturedMedia

================
File: demos/python/sdk_wireless_camera_control/open_gopro/proto/network_management_pb2.py
================
# network_management_pb2.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Mon Sep  9 19:50:27 UTC 2024

"""Generated protocol buffer code."""

from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder

_sym_db = _symbol_database.Default()
from . import response_generic_pb2 as response__generic__pb2

DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(
    b'\n\x18network_management.proto\x12\nopen_gopro\x1a\x16response_generic.proto"R\n\x16NotifProvisioningState\x128\n\x12provisioning_state\x18\x01 \x02(\x0e2\x1c.open_gopro.EnumProvisioning"\x8d\x01\n\x12NotifStartScanning\x120\n\x0escanning_state\x18\x01 \x02(\x0e2\x18.open_gopro.EnumScanning\x12\x0f\n\x07scan_id\x18\x02 \x01(\x05\x12\x15\n\rtotal_entries\x18\x03 \x01(\x05\x12\x1d\n\x15total_configured_ssid\x18\x04 \x02(\x05"\x1e\n\x0eRequestConnect\x12\x0c\n\x04ssid\x18\x01 \x02(\t"\x93\x01\n\x11RequestConnectNew\x12\x0c\n\x04ssid\x18\x01 \x02(\t\x12\x10\n\x08password\x18\x02 \x02(\t\x12\x11\n\tstatic_ip\x18\x03 \x01(\x0c\x12\x0f\n\x07gateway\x18\x04 \x01(\x0c\x12\x0e\n\x06subnet\x18\x05 \x01(\x0c\x12\x13\n\x0bdns_primary\x18\x06 \x01(\x0c\x12\x15\n\rdns_secondary\x18\x07 \x01(\x0c"P\n\x13RequestGetApEntries\x12\x13\n\x0bstart_index\x18\x01 \x02(\x05\x12\x13\n\x0bmax_entries\x18\x02 \x02(\x05\x12\x0f\n\x07scan_id\x18\x03 \x02(\x05"\x17\n\x15RequestReleaseNetwork"\x12\n\x10RequestStartScan"\x93\x01\n\x0fResponseConnect\x12-\n\x06result\x18\x01 \x02(\x0e2\x1d.open_gopro.EnumResultGeneric\x128\n\x12provisioning_state\x18\x02 \x02(\x0e2\x1c.open_gopro.EnumProvisioning\x12\x17\n\x0ftimeout_seconds\x18\x03 \x02(\x05"\x96\x01\n\x12ResponseConnectNew\x12-\n\x06result\x18\x01 \x02(\x0e2\x1d.open_gopro.EnumResultGeneric\x128\n\x12provisioning_state\x18\x02 \x02(\x0e2\x1c.open_gopro.EnumProvisioning\x12\x17\n\x0ftimeout_seconds\x18\x03 \x02(\x05"\x84\x02\n\x14ResponseGetApEntries\x12-\n\x06result\x18\x01 \x02(\x0e2\x1d.open_gopro.EnumResultGeneric\x12\x0f\n\x07scan_id\x18\x02 \x02(\x05\x12;\n\x07entries\x18\x03 \x03(\x0b2*.open_gopro.ResponseGetApEntries.ScanEntry\x1ao\n\tScanEntry\x12\x0c\n\x04ssid\x18\x01 \x02(\t\x12\x1c\n\x14signal_strength_bars\x18\x02 \x02(\x05\x12\x1c\n\x14signal_frequency_mhz\x18\x04 \x02(\x05\x12\x18\n\x10scan_entry_flags\x18\x05 \x02(\x05"x\n\x15ResponseStartScanning\x12-\n\x06result\x18\x01 \x02(\x0e2\x1d.open_gopro.EnumResultGeneric\x120\n\x0escanning_state\x18\x02 \x02(\x0e2\x18.open_gopro.EnumScanning*\xb5\x03\n\x10EnumProvisioning\x12\x18\n\x14PROVISIONING_UNKNOWN\x10\x00\x12\x1e\n\x1aPROVISIONING_NEVER_STARTED\x10\x01\x12\x18\n\x14PROVISIONING_STARTED\x10\x02\x12"\n\x1ePROVISIONING_ABORTED_BY_SYSTEM\x10\x03\x12"\n\x1ePROVISIONING_CANCELLED_BY_USER\x10\x04\x12\x1f\n\x1bPROVISIONING_SUCCESS_NEW_AP\x10\x05\x12\x1f\n\x1bPROVISIONING_SUCCESS_OLD_AP\x10\x06\x12*\n&PROVISIONING_ERROR_FAILED_TO_ASSOCIATE\x10\x07\x12$\n PROVISIONING_ERROR_PASSWORD_AUTH\x10\x08\x12$\n PROVISIONING_ERROR_EULA_BLOCKING\x10\t\x12"\n\x1ePROVISIONING_ERROR_NO_INTERNET\x10\n\x12\'\n#PROVISIONING_ERROR_UNSUPPORTED_TYPE\x10\x0b*\xac\x01\n\x0cEnumScanning\x12\x14\n\x10SCANNING_UNKNOWN\x10\x00\x12\x1a\n\x16SCANNING_NEVER_STARTED\x10\x01\x12\x14\n\x10SCANNING_STARTED\x10\x02\x12\x1e\n\x1aSCANNING_ABORTED_BY_SYSTEM\x10\x03\x12\x1e\n\x1aSCANNING_CANCELLED_BY_USER\x10\x04\x12\x14\n\x10SCANNING_SUCCESS\x10\x05*\xb2\x01\n\x12EnumScanEntryFlags\x12\x12\n\x0eSCAN_FLAG_OPEN\x10\x00\x12\x1b\n\x17SCAN_FLAG_AUTHENTICATED\x10\x01\x12\x18\n\x14SCAN_FLAG_CONFIGURED\x10\x02\x12\x17\n\x13SCAN_FLAG_BEST_SSID\x10\x04\x12\x18\n\x14SCAN_FLAG_ASSOCIATED\x10\x08\x12\x1e\n\x1aSCAN_FLAG_UNSUPPORTED_TYPE\x10\x10'
)
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, globals())
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, "network_management_pb2", globals())
if _descriptor._USE_C_DESCRIPTORS == False:
    DESCRIPTOR._options = None
    _ENUMPROVISIONING._serialized_start = 1290
    _ENUMPROVISIONING._serialized_end = 1727
    _ENUMSCANNING._serialized_start = 1730
    _ENUMSCANNING._serialized_end = 1902
    _ENUMSCANENTRYFLAGS._serialized_start = 1905
    _ENUMSCANENTRYFLAGS._serialized_end = 2083
    _NOTIFPROVISIONINGSTATE._serialized_start = 64
    _NOTIFPROVISIONINGSTATE._serialized_end = 146
    _NOTIFSTARTSCANNING._serialized_start = 149
    _NOTIFSTARTSCANNING._serialized_end = 290
    _REQUESTCONNECT._serialized_start = 292
    _REQUESTCONNECT._serialized_end = 322
    _REQUESTCONNECTNEW._serialized_start = 325
    _REQUESTCONNECTNEW._serialized_end = 472
    _REQUESTGETAPENTRIES._serialized_start = 474
    _REQUESTGETAPENTRIES._serialized_end = 554
    _REQUESTRELEASENETWORK._serialized_start = 556
    _REQUESTRELEASENETWORK._serialized_end = 579
    _REQUESTSTARTSCAN._serialized_start = 581
    _REQUESTSTARTSCAN._serialized_end = 599
    _RESPONSECONNECT._serialized_start = 602
    _RESPONSECONNECT._serialized_end = 749
    _RESPONSECONNECTNEW._serialized_start = 752
    _RESPONSECONNECTNEW._serialized_end = 902
    _RESPONSEGETAPENTRIES._serialized_start = 905
    _RESPONSEGETAPENTRIES._serialized_end = 1165
    _RESPONSEGETAPENTRIES_SCANENTRY._serialized_start = 1054
    _RESPONSEGETAPENTRIES_SCANENTRY._serialized_end = 1165
    _RESPONSESTARTSCANNING._serialized_start = 1167
    _RESPONSESTARTSCANNING._serialized_end = 1287

================
File: demos/python/sdk_wireless_camera_control/open_gopro/proto/network_management_pb2.pyi
================
"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
*
Defines the structure of protobuf messages for network management
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
from . import response_generic_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _EnumProvisioning:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EnumProvisioningEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnumProvisioning.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    PROVISIONING_UNKNOWN: _EnumProvisioning.ValueType
    PROVISIONING_NEVER_STARTED: _EnumProvisioning.ValueType
    PROVISIONING_STARTED: _EnumProvisioning.ValueType
    PROVISIONING_ABORTED_BY_SYSTEM: _EnumProvisioning.ValueType
    PROVISIONING_CANCELLED_BY_USER: _EnumProvisioning.ValueType
    PROVISIONING_SUCCESS_NEW_AP: _EnumProvisioning.ValueType
    PROVISIONING_SUCCESS_OLD_AP: _EnumProvisioning.ValueType
    PROVISIONING_ERROR_FAILED_TO_ASSOCIATE: _EnumProvisioning.ValueType
    PROVISIONING_ERROR_PASSWORD_AUTH: _EnumProvisioning.ValueType
    PROVISIONING_ERROR_EULA_BLOCKING: _EnumProvisioning.ValueType
    PROVISIONING_ERROR_NO_INTERNET: _EnumProvisioning.ValueType
    PROVISIONING_ERROR_UNSUPPORTED_TYPE: _EnumProvisioning.ValueType

class EnumProvisioning(_EnumProvisioning, metaclass=_EnumProvisioningEnumTypeWrapper): ...

PROVISIONING_UNKNOWN: EnumProvisioning.ValueType
PROVISIONING_NEVER_STARTED: EnumProvisioning.ValueType
PROVISIONING_STARTED: EnumProvisioning.ValueType
PROVISIONING_ABORTED_BY_SYSTEM: EnumProvisioning.ValueType
PROVISIONING_CANCELLED_BY_USER: EnumProvisioning.ValueType
PROVISIONING_SUCCESS_NEW_AP: EnumProvisioning.ValueType
PROVISIONING_SUCCESS_OLD_AP: EnumProvisioning.ValueType
PROVISIONING_ERROR_FAILED_TO_ASSOCIATE: EnumProvisioning.ValueType
PROVISIONING_ERROR_PASSWORD_AUTH: EnumProvisioning.ValueType
PROVISIONING_ERROR_EULA_BLOCKING: EnumProvisioning.ValueType
PROVISIONING_ERROR_NO_INTERNET: EnumProvisioning.ValueType
PROVISIONING_ERROR_UNSUPPORTED_TYPE: EnumProvisioning.ValueType
global___EnumProvisioning = EnumProvisioning

class _EnumScanning:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EnumScanningEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnumScanning.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SCANNING_UNKNOWN: _EnumScanning.ValueType
    SCANNING_NEVER_STARTED: _EnumScanning.ValueType
    SCANNING_STARTED: _EnumScanning.ValueType
    SCANNING_ABORTED_BY_SYSTEM: _EnumScanning.ValueType
    SCANNING_CANCELLED_BY_USER: _EnumScanning.ValueType
    SCANNING_SUCCESS: _EnumScanning.ValueType

class EnumScanning(_EnumScanning, metaclass=_EnumScanningEnumTypeWrapper): ...

SCANNING_UNKNOWN: EnumScanning.ValueType
SCANNING_NEVER_STARTED: EnumScanning.ValueType
SCANNING_STARTED: EnumScanning.ValueType
SCANNING_ABORTED_BY_SYSTEM: EnumScanning.ValueType
SCANNING_CANCELLED_BY_USER: EnumScanning.ValueType
SCANNING_SUCCESS: EnumScanning.ValueType
global___EnumScanning = EnumScanning

class _EnumScanEntryFlags:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EnumScanEntryFlagsEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnumScanEntryFlags.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SCAN_FLAG_OPEN: _EnumScanEntryFlags.ValueType
    "This network does not require authentication"
    SCAN_FLAG_AUTHENTICATED: _EnumScanEntryFlags.ValueType
    "This network requires authentication"
    SCAN_FLAG_CONFIGURED: _EnumScanEntryFlags.ValueType
    "This network has been previously provisioned"
    SCAN_FLAG_BEST_SSID: _EnumScanEntryFlags.ValueType
    SCAN_FLAG_ASSOCIATED: _EnumScanEntryFlags.ValueType
    "Camera is connected to this AP"
    SCAN_FLAG_UNSUPPORTED_TYPE: _EnumScanEntryFlags.ValueType

class EnumScanEntryFlags(_EnumScanEntryFlags, metaclass=_EnumScanEntryFlagsEnumTypeWrapper): ...

SCAN_FLAG_OPEN: EnumScanEntryFlags.ValueType
"This network does not require authentication"
SCAN_FLAG_AUTHENTICATED: EnumScanEntryFlags.ValueType
"This network requires authentication"
SCAN_FLAG_CONFIGURED: EnumScanEntryFlags.ValueType
"This network has been previously provisioned"
SCAN_FLAG_BEST_SSID: EnumScanEntryFlags.ValueType
SCAN_FLAG_ASSOCIATED: EnumScanEntryFlags.ValueType
"Camera is connected to this AP"
SCAN_FLAG_UNSUPPORTED_TYPE: EnumScanEntryFlags.ValueType
global___EnumScanEntryFlags = EnumScanEntryFlags

@typing_extensions.final
class NotifProvisioningState(google.protobuf.message.Message):
    """
    Provision state notification

    Sent during provisioning triggered via @ref RequestConnect or @ref RequestConnectNew
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    PROVISIONING_STATE_FIELD_NUMBER: builtins.int
    provisioning_state: global___EnumProvisioning.ValueType
    "Provisioning / connection state"

    def __init__(self, *, provisioning_state: global___EnumProvisioning.ValueType | None = ...) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal["provisioning_state", b"provisioning_state"],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal["provisioning_state", b"provisioning_state"],
    ) -> None: ...

global___NotifProvisioningState = NotifProvisioningState

@typing_extensions.final
class NotifStartScanning(google.protobuf.message.Message):
    """
    Scanning state notification

    Triggered via @ref RequestStartScan
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    SCANNING_STATE_FIELD_NUMBER: builtins.int
    SCAN_ID_FIELD_NUMBER: builtins.int
    TOTAL_ENTRIES_FIELD_NUMBER: builtins.int
    TOTAL_CONFIGURED_SSID_FIELD_NUMBER: builtins.int
    scanning_state: global___EnumScanning.ValueType
    "Scanning state"
    scan_id: builtins.int
    "ID associated with scan results (included if scan was successful)"
    total_entries: builtins.int
    "Number of APs found during scan (included if scan was successful)"
    total_configured_ssid: builtins.int
    "Total count of camera's provisioned SSIDs"

    def __init__(
        self,
        *,
        scanning_state: global___EnumScanning.ValueType | None = ...,
        scan_id: builtins.int | None = ...,
        total_entries: builtins.int | None = ...,
        total_configured_ssid: builtins.int | None = ...
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "scan_id",
            b"scan_id",
            "scanning_state",
            b"scanning_state",
            "total_configured_ssid",
            b"total_configured_ssid",
            "total_entries",
            b"total_entries",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "scan_id",
            b"scan_id",
            "scanning_state",
            b"scanning_state",
            "total_configured_ssid",
            b"total_configured_ssid",
            "total_entries",
            b"total_entries",
        ],
    ) -> None: ...

global___NotifStartScanning = NotifStartScanning

@typing_extensions.final
class RequestConnect(google.protobuf.message.Message):
    """*
    Connect to (but do not authenticate with) an Access Point

    This is intended to be used to connect to a previously-connected Access Point

    Response: @ref ResponseConnect

    Notification: @ref NotifProvisioningState sent periodically as provisioning state changes
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    SSID_FIELD_NUMBER: builtins.int
    ssid: builtins.str
    "AP SSID"

    def __init__(self, *, ssid: builtins.str | None = ...) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["ssid", b"ssid"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["ssid", b"ssid"]) -> None: ...

global___RequestConnect = RequestConnect

@typing_extensions.final
class RequestConnectNew(google.protobuf.message.Message):
    """*
    Connect to and authenticate with an Access Point

    This is only intended to be used if the AP is not previously provisioned.

    Response: @ref ResponseConnectNew sent immediately

    Notification: @ref NotifProvisioningState sent periodically as provisioning state changes
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    SSID_FIELD_NUMBER: builtins.int
    PASSWORD_FIELD_NUMBER: builtins.int
    STATIC_IP_FIELD_NUMBER: builtins.int
    GATEWAY_FIELD_NUMBER: builtins.int
    SUBNET_FIELD_NUMBER: builtins.int
    DNS_PRIMARY_FIELD_NUMBER: builtins.int
    DNS_SECONDARY_FIELD_NUMBER: builtins.int
    ssid: builtins.str
    "AP SSID"
    password: builtins.str
    "AP password"
    static_ip: builtins.bytes
    "Static IP address"
    gateway: builtins.bytes
    "Gateway IP address"
    subnet: builtins.bytes
    "Subnet mask"
    dns_primary: builtins.bytes
    "Primary DNS"
    dns_secondary: builtins.bytes
    "Secondary DNS"

    def __init__(
        self,
        *,
        ssid: builtins.str | None = ...,
        password: builtins.str | None = ...,
        static_ip: builtins.bytes | None = ...,
        gateway: builtins.bytes | None = ...,
        subnet: builtins.bytes | None = ...,
        dns_primary: builtins.bytes | None = ...,
        dns_secondary: builtins.bytes | None = ...
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "dns_primary",
            b"dns_primary",
            "dns_secondary",
            b"dns_secondary",
            "gateway",
            b"gateway",
            "password",
            b"password",
            "ssid",
            b"ssid",
            "static_ip",
            b"static_ip",
            "subnet",
            b"subnet",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "dns_primary",
            b"dns_primary",
            "dns_secondary",
            b"dns_secondary",
            "gateway",
            b"gateway",
            "password",
            b"password",
            "ssid",
            b"ssid",
            "static_ip",
            b"static_ip",
            "subnet",
            b"subnet",
        ],
    ) -> None: ...

global___RequestConnectNew = RequestConnectNew

@typing_extensions.final
class RequestGetApEntries(google.protobuf.message.Message):
    """*
    Get a list of Access Points found during a @ref RequestStartScan

    Response: @ref ResponseGetApEntries
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    START_INDEX_FIELD_NUMBER: builtins.int
    MAX_ENTRIES_FIELD_NUMBER: builtins.int
    SCAN_ID_FIELD_NUMBER: builtins.int
    start_index: builtins.int
    "Used for paging. 0 <= start_index < @ref ResponseGetApEntries .total_entries"
    max_entries: builtins.int
    "Used for paging. Value must be < @ref ResponseGetApEntries .total_entries"
    scan_id: builtins.int
    "ID corresponding to a set of scan results (i.e. @ref ResponseGetApEntries .scan_id)"

    def __init__(
        self,
        *,
        start_index: builtins.int | None = ...,
        max_entries: builtins.int | None = ...,
        scan_id: builtins.int | None = ...
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "max_entries",
            b"max_entries",
            "scan_id",
            b"scan_id",
            "start_index",
            b"start_index",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "max_entries",
            b"max_entries",
            "scan_id",
            b"scan_id",
            "start_index",
            b"start_index",
        ],
    ) -> None: ...

global___RequestGetApEntries = RequestGetApEntries

@typing_extensions.final
class RequestReleaseNetwork(google.protobuf.message.Message):
    """*
    Request to disconnect from currently-connected AP

    This drops the camera out of Station (STA) Mode and returns it to Access Point (AP) mode.

    Response: @ref ResponseGeneric
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(self) -> None: ...

global___RequestReleaseNetwork = RequestReleaseNetwork

@typing_extensions.final
class RequestStartScan(google.protobuf.message.Message):
    """*
    Start scanning for Access Points

    @note Serialization of this object is zero bytes.

    Response: @ref ResponseStartScanning  are sent immediately after the camera receives this command

    Notifications: @ref NotifStartScanning are sent periodically as scanning state changes. Use to detect scan complete.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(self) -> None: ...

global___RequestStartScan = RequestStartScan

@typing_extensions.final
class ResponseConnect(google.protobuf.message.Message):
    """*
    The status of an attempt to connect to an Access Point

    Sent as the initial response to @ref RequestConnect
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    RESULT_FIELD_NUMBER: builtins.int
    PROVISIONING_STATE_FIELD_NUMBER: builtins.int
    TIMEOUT_SECONDS_FIELD_NUMBER: builtins.int
    result: response_generic_pb2.EnumResultGeneric.ValueType
    "Generic pass/fail/error info"
    provisioning_state: global___EnumProvisioning.ValueType
    "Provisioning/connection state"
    timeout_seconds: builtins.int
    "Network connection timeout (seconds)"

    def __init__(
        self,
        *,
        result: response_generic_pb2.EnumResultGeneric.ValueType | None = ...,
        provisioning_state: global___EnumProvisioning.ValueType | None = ...,
        timeout_seconds: builtins.int | None = ...
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "provisioning_state",
            b"provisioning_state",
            "result",
            b"result",
            "timeout_seconds",
            b"timeout_seconds",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "provisioning_state",
            b"provisioning_state",
            "result",
            b"result",
            "timeout_seconds",
            b"timeout_seconds",
        ],
    ) -> None: ...

global___ResponseConnect = ResponseConnect

@typing_extensions.final
class ResponseConnectNew(google.protobuf.message.Message):
    """*
    The status of an attempt to connect to an Access Point

    Sent as the initial response to @ref RequestConnectNew
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    RESULT_FIELD_NUMBER: builtins.int
    PROVISIONING_STATE_FIELD_NUMBER: builtins.int
    TIMEOUT_SECONDS_FIELD_NUMBER: builtins.int
    result: response_generic_pb2.EnumResultGeneric.ValueType
    "Status of Connect New request"
    provisioning_state: global___EnumProvisioning.ValueType
    "Current provisioning state of the network"
    timeout_seconds: builtins.int
    "*\n    Number of seconds camera will wait before declaring a network connection attempt failed\n    "

    def __init__(
        self,
        *,
        result: response_generic_pb2.EnumResultGeneric.ValueType | None = ...,
        provisioning_state: global___EnumProvisioning.ValueType | None = ...,
        timeout_seconds: builtins.int | None = ...
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "provisioning_state",
            b"provisioning_state",
            "result",
            b"result",
            "timeout_seconds",
            b"timeout_seconds",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "provisioning_state",
            b"provisioning_state",
            "result",
            b"result",
            "timeout_seconds",
            b"timeout_seconds",
        ],
    ) -> None: ...

global___ResponseConnectNew = ResponseConnectNew

@typing_extensions.final
class ResponseGetApEntries(google.protobuf.message.Message):
    """*
    A list of scan entries describing a scanned Access Point

    This is sent in response to a @ref RequestGetApEntries
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class ScanEntry(google.protobuf.message.Message):
        """*
        An individual Scan Entry in a @ref ResponseGetApEntries response

        @note When `scan_entry_flags` contains `SCAN_FLAG_CONFIGURED`, it is an indication that this network has already been provisioned.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        SSID_FIELD_NUMBER: builtins.int
        SIGNAL_STRENGTH_BARS_FIELD_NUMBER: builtins.int
        SIGNAL_FREQUENCY_MHZ_FIELD_NUMBER: builtins.int
        SCAN_ENTRY_FLAGS_FIELD_NUMBER: builtins.int
        ssid: builtins.str
        "AP SSID"
        signal_strength_bars: builtins.int
        "Signal strength (3 bars: >-70 dBm; 2 bars: >-85 dBm; 1 bar: <=-85 dBm)"
        signal_frequency_mhz: builtins.int
        "Signal frequency (MHz)"
        scan_entry_flags: builtins.int
        "Bitmasked value from @ref EnumScanEntryFlags"

        def __init__(
            self,
            *,
            ssid: builtins.str | None = ...,
            signal_strength_bars: builtins.int | None = ...,
            signal_frequency_mhz: builtins.int | None = ...,
            scan_entry_flags: builtins.int | None = ...
        ) -> None: ...
        def HasField(
            self,
            field_name: typing_extensions.Literal[
                "scan_entry_flags",
                b"scan_entry_flags",
                "signal_frequency_mhz",
                b"signal_frequency_mhz",
                "signal_strength_bars",
                b"signal_strength_bars",
                "ssid",
                b"ssid",
            ],
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing_extensions.Literal[
                "scan_entry_flags",
                b"scan_entry_flags",
                "signal_frequency_mhz",
                b"signal_frequency_mhz",
                "signal_strength_bars",
                b"signal_strength_bars",
                "ssid",
                b"ssid",
            ],
        ) -> None: ...

    RESULT_FIELD_NUMBER: builtins.int
    SCAN_ID_FIELD_NUMBER: builtins.int
    ENTRIES_FIELD_NUMBER: builtins.int
    result: response_generic_pb2.EnumResultGeneric.ValueType
    "Generic pass/fail/error info"
    scan_id: builtins.int
    "ID associated with this batch of results"

    @property
    def entries(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ResponseGetApEntries.ScanEntry]:
        """Array containing details about discovered APs"""
    def __init__(
        self,
        *,
        result: response_generic_pb2.EnumResultGeneric.ValueType | None = ...,
        scan_id: builtins.int | None = ...,
        entries: (collections.abc.Iterable[global___ResponseGetApEntries.ScanEntry] | None) = ...
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal["result", b"result", "scan_id", b"scan_id"],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal["entries", b"entries", "result", b"result", "scan_id", b"scan_id"],
    ) -> None: ...

global___ResponseGetApEntries = ResponseGetApEntries

@typing_extensions.final
class ResponseStartScanning(google.protobuf.message.Message):
    """*
    The current scanning state.

    This is the initial response to a @ref RequestStartScan
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    RESULT_FIELD_NUMBER: builtins.int
    SCANNING_STATE_FIELD_NUMBER: builtins.int
    result: response_generic_pb2.EnumResultGeneric.ValueType
    "Generic pass/fail/error info"
    scanning_state: global___EnumScanning.ValueType
    "Scanning state"

    def __init__(
        self,
        *,
        result: response_generic_pb2.EnumResultGeneric.ValueType | None = ...,
        scanning_state: global___EnumScanning.ValueType | None = ...
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal["result", b"result", "scanning_state", b"scanning_state"],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal["result", b"result", "scanning_state", b"scanning_state"],
    ) -> None: ...

global___ResponseStartScanning = ResponseStartScanning

================
File: demos/python/sdk_wireless_camera_control/open_gopro/proto/preset_status_pb2.py
================
# preset_status_pb2.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Mon Sep  9 19:50:27 UTC 2024

"""Generated protocol buffer code."""

from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder

_sym_db = _symbol_database.Default()
from . import response_generic_pb2 as response__generic__pb2

DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(
    b'\n\x13preset_status.proto\x12\nopen_gopro\x1a\x16response_generic.proto"I\n\x12NotifyPresetStatus\x123\n\x12preset_group_array\x18\x01 \x03(\x0b2\x17.open_gopro.PresetGroup"\xaf\x02\n\x06Preset\x12\n\n\x02id\x18\x01 \x01(\x05\x12&\n\x04mode\x18\x02 \x01(\x0e2\x18.open_gopro.EnumFlatMode\x12-\n\x08title_id\x18\x03 \x01(\x0e2\x1b.open_gopro.EnumPresetTitle\x12\x14\n\x0ctitle_number\x18\x04 \x01(\x05\x12\x14\n\x0cuser_defined\x18\x05 \x01(\x08\x12(\n\x04icon\x18\x06 \x01(\x0e2\x1a.open_gopro.EnumPresetIcon\x120\n\rsetting_array\x18\x07 \x03(\x0b2\x19.open_gopro.PresetSetting\x12\x13\n\x0bis_modified\x18\x08 \x01(\x08\x12\x10\n\x08is_fixed\x18\t \x01(\x08\x12\x13\n\x0bcustom_name\x18\n \x01(\t"\x8c\x01\n\x19RequestCustomPresetUpdate\x12-\n\x08title_id\x18\x01 \x01(\x0e2\x1b.open_gopro.EnumPresetTitle\x12\x13\n\x0bcustom_name\x18\x02 \x01(\t\x12+\n\x07icon_id\x18\x03 \x01(\x0e2\x1a.open_gopro.EnumPresetIcon"\xd5\x01\n\x0bPresetGroup\x12\'\n\x02id\x18\x01 \x01(\x0e2\x1b.open_gopro.EnumPresetGroup\x12(\n\x0cpreset_array\x18\x02 \x03(\x0b2\x12.open_gopro.Preset\x12\x16\n\x0ecan_add_preset\x18\x03 \x01(\x08\x12-\n\x04icon\x18\x04 \x01(\x0e2\x1f.open_gopro.EnumPresetGroupIcon\x12,\n\nmode_array\x18\x05 \x03(\x0e2\x18.open_gopro.EnumFlatMode">\n\rPresetSetting\x12\n\n\x02id\x18\x01 \x01(\x05\x12\r\n\x05value\x18\x02 \x01(\x05\x12\x12\n\nis_caption\x18\x03 \x01(\x08*\x9b\x05\n\x0cEnumFlatMode\x12\x1e\n\x11FLAT_MODE_UNKNOWN\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x16\n\x12FLAT_MODE_PLAYBACK\x10\x04\x12\x13\n\x0fFLAT_MODE_SETUP\x10\x05\x12\x13\n\x0fFLAT_MODE_VIDEO\x10\x0c\x12\x1e\n\x1aFLAT_MODE_TIME_LAPSE_VIDEO\x10\r\x12\x15\n\x11FLAT_MODE_LOOPING\x10\x0f\x12\x1a\n\x16FLAT_MODE_PHOTO_SINGLE\x10\x10\x12\x13\n\x0fFLAT_MODE_PHOTO\x10\x11\x12\x19\n\x15FLAT_MODE_PHOTO_NIGHT\x10\x12\x12\x19\n\x15FLAT_MODE_PHOTO_BURST\x10\x13\x12\x1e\n\x1aFLAT_MODE_TIME_LAPSE_PHOTO\x10\x14\x12\x1f\n\x1bFLAT_MODE_NIGHT_LAPSE_PHOTO\x10\x15\x12\x1e\n\x1aFLAT_MODE_BROADCAST_RECORD\x10\x16\x12!\n\x1dFLAT_MODE_BROADCAST_BROADCAST\x10\x17\x12\x1d\n\x19FLAT_MODE_TIME_WARP_VIDEO\x10\x18\x12\x18\n\x14FLAT_MODE_LIVE_BURST\x10\x19\x12\x1f\n\x1bFLAT_MODE_NIGHT_LAPSE_VIDEO\x10\x1a\x12\x13\n\x0fFLAT_MODE_SLOMO\x10\x1b\x12\x12\n\x0eFLAT_MODE_IDLE\x10\x1c\x12\x1e\n\x1aFLAT_MODE_VIDEO_STAR_TRAIL\x10\x1d\x12"\n\x1eFLAT_MODE_VIDEO_LIGHT_PAINTING\x10\x1e\x12\x1f\n\x1bFLAT_MODE_VIDEO_LIGHT_TRAIL\x10\x1f\x12\x1f\n\x1bFLAT_MODE_VIDEO_BURST_SLOMO\x10 *i\n\x0fEnumPresetGroup\x12\x1a\n\x15PRESET_GROUP_ID_VIDEO\x10\xe8\x07\x12\x1a\n\x15PRESET_GROUP_ID_PHOTO\x10\xe9\x07\x12\x1e\n\x19PRESET_GROUP_ID_TIMELAPSE\x10\xea\x07*\xb5\x03\n\x13EnumPresetGroupIcon\x12\x1e\n\x1aPRESET_GROUP_VIDEO_ICON_ID\x10\x00\x12\x1e\n\x1aPRESET_GROUP_PHOTO_ICON_ID\x10\x01\x12"\n\x1ePRESET_GROUP_TIMELAPSE_ICON_ID\x10\x02\x12\'\n#PRESET_GROUP_LONG_BAT_VIDEO_ICON_ID\x10\x03\x12(\n$PRESET_GROUP_ENDURANCE_VIDEO_ICON_ID\x10\x04\x12"\n\x1ePRESET_GROUP_MAX_VIDEO_ICON_ID\x10\x05\x12"\n\x1ePRESET_GROUP_MAX_PHOTO_ICON_ID\x10\x06\x12&\n"PRESET_GROUP_MAX_TIMELAPSE_ICON_ID\x10\x07\x12%\n!PRESET_GROUP_ND_MOD_VIDEO_ICON_ID\x10\x08\x12%\n!PRESET_GROUP_ND_MOD_PHOTO_ICON_ID\x10\t\x12)\n%PRESET_GROUP_ND_MOD_TIMELAPSE_ICON_ID\x10\n*\xff\x12\n\x0eEnumPresetIcon\x12\x15\n\x11PRESET_ICON_VIDEO\x10\x00\x12\x18\n\x14PRESET_ICON_ACTIVITY\x10\x01\x12\x19\n\x15PRESET_ICON_CINEMATIC\x10\x02\x12\x15\n\x11PRESET_ICON_PHOTO\x10\x03\x12\x1a\n\x16PRESET_ICON_LIVE_BURST\x10\x04\x12\x15\n\x11PRESET_ICON_BURST\x10\x05\x12\x1b\n\x17PRESET_ICON_PHOTO_NIGHT\x10\x06\x12\x18\n\x14PRESET_ICON_TIMEWARP\x10\x07\x12\x19\n\x15PRESET_ICON_TIMELAPSE\x10\x08\x12\x1a\n\x16PRESET_ICON_NIGHTLAPSE\x10\t\x12\x15\n\x11PRESET_ICON_SNAIL\x10\n\x12\x17\n\x13PRESET_ICON_VIDEO_2\x10\x0b\x12\x17\n\x13PRESET_ICON_PHOTO_2\x10\r\x12\x18\n\x14PRESET_ICON_PANORAMA\x10\x0e\x12\x17\n\x13PRESET_ICON_BURST_2\x10\x0f\x12\x1a\n\x16PRESET_ICON_TIMEWARP_2\x10\x10\x12\x1b\n\x17PRESET_ICON_TIMELAPSE_2\x10\x11\x12\x16\n\x12PRESET_ICON_CUSTOM\x10\x12\x12\x13\n\x0fPRESET_ICON_AIR\x10\x13\x12\x14\n\x10PRESET_ICON_BIKE\x10\x14\x12\x14\n\x10PRESET_ICON_EPIC\x10\x15\x12\x16\n\x12PRESET_ICON_INDOOR\x10\x16\x12\x15\n\x11PRESET_ICON_MOTOR\x10\x17\x12\x17\n\x13PRESET_ICON_MOUNTED\x10\x18\x12\x17\n\x13PRESET_ICON_OUTDOOR\x10\x19\x12\x13\n\x0fPRESET_ICON_POV\x10\x1a\x12\x16\n\x12PRESET_ICON_SELFIE\x10\x1b\x12\x15\n\x11PRESET_ICON_SKATE\x10\x1c\x12\x14\n\x10PRESET_ICON_SNOW\x10\x1d\x12\x15\n\x11PRESET_ICON_TRAIL\x10\x1e\x12\x16\n\x12PRESET_ICON_TRAVEL\x10\x1f\x12\x15\n\x11PRESET_ICON_WATER\x10 \x12\x17\n\x13PRESET_ICON_LOOPING\x10!\x12\x15\n\x11PRESET_ICON_STARS\x10"\x12\x16\n\x12PRESET_ICON_ACTION\x10#\x12\x1a\n\x16PRESET_ICON_FOLLOW_CAM\x10$\x12\x14\n\x10PRESET_ICON_SURF\x10%\x12\x14\n\x10PRESET_ICON_CITY\x10&\x12\x15\n\x11PRESET_ICON_SHAKY\x10\'\x12\x16\n\x12PRESET_ICON_CHESTY\x10(\x12\x16\n\x12PRESET_ICON_HELMET\x10)\x12\x14\n\x10PRESET_ICON_BITE\x10*\x12 \n\x1cPRESET_ICON_CUSTOM_CINEMATIC\x10+\x12\x14\n\x10PRESET_ICON_VLOG\x10,\x12\x13\n\x0fPRESET_ICON_FPV\x10-\x12\x13\n\x0fPRESET_ICON_HDR\x10.\x12\x19\n\x15PRESET_ICON_LANDSCAPE\x10/\x12\x13\n\x0fPRESET_ICON_LOG\x100\x12\x1c\n\x18PRESET_ICON_CUSTOM_SLOMO\x101\x12\x16\n\x12PRESET_ICON_TRIPOD\x102\x12\x19\n\x15PRESET_ICON_MAX_VIDEO\x107\x12\x19\n\x15PRESET_ICON_MAX_PHOTO\x108\x12\x1c\n\x18PRESET_ICON_MAX_TIMEWARP\x109\x12\x15\n\x11PRESET_ICON_BASIC\x10:\x12\x1c\n\x18PRESET_ICON_ULTRA_SLO_MO\x10;\x12"\n\x1ePRESET_ICON_STANDARD_ENDURANCE\x10<\x12"\n\x1ePRESET_ICON_ACTIVITY_ENDURANCE\x10=\x12#\n\x1fPRESET_ICON_CINEMATIC_ENDURANCE\x10>\x12\x1f\n\x1bPRESET_ICON_SLOMO_ENDURANCE\x10?\x12\x1c\n\x18PRESET_ICON_STATIONARY_1\x10@\x12\x1c\n\x18PRESET_ICON_STATIONARY_2\x10A\x12\x1c\n\x18PRESET_ICON_STATIONARY_3\x10B\x12\x1c\n\x18PRESET_ICON_STATIONARY_4\x10C\x12"\n\x1ePRESET_ICON_SIMPLE_SUPER_PHOTO\x10F\x12"\n\x1ePRESET_ICON_SIMPLE_NIGHT_PHOTO\x10G\x12%\n!PRESET_ICON_HIGHEST_QUALITY_VIDEO\x10I\x12&\n"PRESET_ICON_STANDARD_QUALITY_VIDEO\x10J\x12#\n\x1fPRESET_ICON_BASIC_QUALITY_VIDEO\x10K\x12\x1a\n\x16PRESET_ICON_STAR_TRAIL\x10L\x12\x1e\n\x1aPRESET_ICON_LIGHT_PAINTING\x10M\x12\x1b\n\x17PRESET_ICON_LIGHT_TRAIL\x10N\x12\x1a\n\x16PRESET_ICON_FULL_FRAME\x10O\x12\x1e\n\x1aPRESET_ICON_EASY_MAX_VIDEO\x10P\x12\x1e\n\x1aPRESET_ICON_EASY_MAX_PHOTO\x10Q\x12!\n\x1dPRESET_ICON_EASY_MAX_TIMEWARP\x10R\x12#\n\x1fPRESET_ICON_EASY_MAX_STAR_TRAIL\x10S\x12\'\n#PRESET_ICON_EASY_MAX_LIGHT_PAINTING\x10T\x12$\n PRESET_ICON_EASY_MAX_LIGHT_TRAIL\x10U\x12\x1e\n\x1aPRESET_ICON_MAX_STAR_TRAIL\x10Y\x12"\n\x1ePRESET_ICON_MAX_LIGHT_PAINTING\x10Z\x12\x1f\n\x1bPRESET_ICON_MAX_LIGHT_TRAIL\x10[\x12%\n!PRESET_ICON_EASY_STANDARD_PROFILE\x10d\x12 \n\x1cPRESET_ICON_EASY_HDR_PROFILE\x10e\x12\x1b\n\x17PRESET_ICON_BURST_SLOMO\x10f\x12 \n\x1bPRESET_ICON_TIMELAPSE_PHOTO\x10\xe8\x07\x12!\n\x1cPRESET_ICON_NIGHTLAPSE_PHOTO\x10\xe9\x07*\xb7\x11\n\x0fEnumPresetTitle\x12\x19\n\x15PRESET_TITLE_ACTIVITY\x10\x00\x12\x19\n\x15PRESET_TITLE_STANDARD\x10\x01\x12\x1a\n\x16PRESET_TITLE_CINEMATIC\x10\x02\x12\x16\n\x12PRESET_TITLE_PHOTO\x10\x03\x12\x1b\n\x17PRESET_TITLE_LIVE_BURST\x10\x04\x12\x16\n\x12PRESET_TITLE_BURST\x10\x05\x12\x16\n\x12PRESET_TITLE_NIGHT\x10\x06\x12\x1a\n\x16PRESET_TITLE_TIME_WARP\x10\x07\x12\x1b\n\x17PRESET_TITLE_TIME_LAPSE\x10\x08\x12\x1c\n\x18PRESET_TITLE_NIGHT_LAPSE\x10\t\x12\x16\n\x12PRESET_TITLE_VIDEO\x10\n\x12\x16\n\x12PRESET_TITLE_SLOMO\x10\x0b\x12\x18\n\x14PRESET_TITLE_PHOTO_2\x10\r\x12\x19\n\x15PRESET_TITLE_PANORAMA\x10\x0e\x12\x1c\n\x18PRESET_TITLE_TIME_WARP_2\x10\x10\x12\x17\n\x13PRESET_TITLE_CUSTOM\x10\x12\x12\x14\n\x10PRESET_TITLE_AIR\x10\x13\x12\x15\n\x11PRESET_TITLE_BIKE\x10\x14\x12\x15\n\x11PRESET_TITLE_EPIC\x10\x15\x12\x17\n\x13PRESET_TITLE_INDOOR\x10\x16\x12\x16\n\x12PRESET_TITLE_MOTOR\x10\x17\x12\x18\n\x14PRESET_TITLE_MOUNTED\x10\x18\x12\x18\n\x14PRESET_TITLE_OUTDOOR\x10\x19\x12\x14\n\x10PRESET_TITLE_POV\x10\x1a\x12\x17\n\x13PRESET_TITLE_SELFIE\x10\x1b\x12\x16\n\x12PRESET_TITLE_SKATE\x10\x1c\x12\x15\n\x11PRESET_TITLE_SNOW\x10\x1d\x12\x16\n\x12PRESET_TITLE_TRAIL\x10\x1e\x12\x17\n\x13PRESET_TITLE_TRAVEL\x10\x1f\x12\x16\n\x12PRESET_TITLE_WATER\x10 \x12\x18\n\x14PRESET_TITLE_LOOPING\x10!\x12\x16\n\x12PRESET_TITLE_STARS\x10"\x12\x17\n\x13PRESET_TITLE_ACTION\x10#\x12\x1b\n\x17PRESET_TITLE_FOLLOW_CAM\x10$\x12\x15\n\x11PRESET_TITLE_SURF\x10%\x12\x15\n\x11PRESET_TITLE_CITY\x10&\x12\x16\n\x12PRESET_TITLE_SHAKY\x10\'\x12\x17\n\x13PRESET_TITLE_CHESTY\x10(\x12\x17\n\x13PRESET_TITLE_HELMET\x10)\x12\x15\n\x11PRESET_TITLE_BITE\x10*\x12!\n\x1dPRESET_TITLE_CUSTOM_CINEMATIC\x10+\x12\x15\n\x11PRESET_TITLE_VLOG\x10,\x12\x14\n\x10PRESET_TITLE_FPV\x10-\x12\x14\n\x10PRESET_TITLE_HDR\x10.\x12\x1a\n\x16PRESET_TITLE_LANDSCAPE\x10/\x12\x14\n\x10PRESET_TITLE_LOG\x100\x12\x1d\n\x19PRESET_TITLE_CUSTOM_SLOMO\x101\x12\x17\n\x13PRESET_TITLE_TRIPOD\x102\x12\x16\n\x12PRESET_TITLE_BASIC\x10:\x12\x1d\n\x19PRESET_TITLE_ULTRA_SLO_MO\x10;\x12#\n\x1fPRESET_TITLE_STANDARD_ENDURANCE\x10<\x12#\n\x1fPRESET_TITLE_ACTIVITY_ENDURANCE\x10=\x12$\n PRESET_TITLE_CINEMATIC_ENDURANCE\x10>\x12 \n\x1cPRESET_TITLE_SLOMO_ENDURANCE\x10?\x12\x1d\n\x19PRESET_TITLE_STATIONARY_1\x10@\x12\x1d\n\x19PRESET_TITLE_STATIONARY_2\x10A\x12\x1d\n\x19PRESET_TITLE_STATIONARY_3\x10B\x12\x1d\n\x19PRESET_TITLE_STATIONARY_4\x10C\x12\x1d\n\x19PRESET_TITLE_SIMPLE_VIDEO\x10D\x12!\n\x1dPRESET_TITLE_SIMPLE_TIME_WARP\x10E\x12#\n\x1fPRESET_TITLE_SIMPLE_SUPER_PHOTO\x10F\x12#\n\x1fPRESET_TITLE_SIMPLE_NIGHT_PHOTO\x10G\x12\'\n#PRESET_TITLE_SIMPLE_VIDEO_ENDURANCE\x10H\x12 \n\x1cPRESET_TITLE_HIGHEST_QUALITY\x10I\x12!\n\x1dPRESET_TITLE_EXTENDED_BATTERY\x10J\x12 \n\x1cPRESET_TITLE_LONGEST_BATTERY\x10K\x12\x1b\n\x17PRESET_TITLE_STAR_TRAIL\x10L\x12\x1f\n\x1bPRESET_TITLE_LIGHT_PAINTING\x10M\x12\x1c\n\x18PRESET_TITLE_LIGHT_TRAIL\x10N\x12\x1b\n\x17PRESET_TITLE_FULL_FRAME\x10O\x12\'\n#PRESET_TITLE_STANDARD_QUALITY_VIDEO\x10R\x12$\n PRESET_TITLE_BASIC_QUALITY_VIDEO\x10S\x12&\n"PRESET_TITLE_HIGHEST_QUALITY_VIDEO\x10]\x12)\n%PRESET_TITLE_USER_DEFINED_CUSTOM_NAME\x10^\x12&\n"PRESET_TITLE_EASY_STANDARD_PROFILE\x10c\x12!\n\x1dPRESET_TITLE_EASY_HDR_PROFILE\x10d\x12\x1c\n\x18PRESET_TITLE_BURST_SLOMO\x10j'
)
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, globals())
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, "preset_status_pb2", globals())
if _descriptor._USE_C_DESCRIPTORS == False:
    DESCRIPTOR._options = None
    _ENUMFLATMODE._serialized_start = 864
    _ENUMFLATMODE._serialized_end = 1531
    _ENUMPRESETGROUP._serialized_start = 1533
    _ENUMPRESETGROUP._serialized_end = 1638
    _ENUMPRESETGROUPICON._serialized_start = 1641
    _ENUMPRESETGROUPICON._serialized_end = 2078
    _ENUMPRESETICON._serialized_start = 2081
    _ENUMPRESETICON._serialized_end = 4512
    _ENUMPRESETTITLE._serialized_start = 4515
    _ENUMPRESETTITLE._serialized_end = 6746
    _NOTIFYPRESETSTATUS._serialized_start = 59
    _NOTIFYPRESETSTATUS._serialized_end = 132
    _PRESET._serialized_start = 135
    _PRESET._serialized_end = 438
    _REQUESTCUSTOMPRESETUPDATE._serialized_start = 441
    _REQUESTCUSTOMPRESETUPDATE._serialized_end = 581
    _PRESETGROUP._serialized_start = 584
    _PRESETGROUP._serialized_end = 797
    _PRESETSETTING._serialized_start = 799
    _PRESETSETTING._serialized_end = 861

================
File: demos/python/sdk_wireless_camera_control/open_gopro/proto/preset_status_pb2.pyi
================
"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
*
Defines the structure of protobuf message received from camera containing preset status
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _EnumFlatMode:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EnumFlatModeEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnumFlatMode.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    FLAT_MODE_UNKNOWN: _EnumFlatMode.ValueType
    FLAT_MODE_PLAYBACK: _EnumFlatMode.ValueType
    FLAT_MODE_SETUP: _EnumFlatMode.ValueType
    FLAT_MODE_VIDEO: _EnumFlatMode.ValueType
    FLAT_MODE_TIME_LAPSE_VIDEO: _EnumFlatMode.ValueType
    FLAT_MODE_LOOPING: _EnumFlatMode.ValueType
    FLAT_MODE_PHOTO_SINGLE: _EnumFlatMode.ValueType
    FLAT_MODE_PHOTO: _EnumFlatMode.ValueType
    FLAT_MODE_PHOTO_NIGHT: _EnumFlatMode.ValueType
    FLAT_MODE_PHOTO_BURST: _EnumFlatMode.ValueType
    FLAT_MODE_TIME_LAPSE_PHOTO: _EnumFlatMode.ValueType
    FLAT_MODE_NIGHT_LAPSE_PHOTO: _EnumFlatMode.ValueType
    FLAT_MODE_BROADCAST_RECORD: _EnumFlatMode.ValueType
    FLAT_MODE_BROADCAST_BROADCAST: _EnumFlatMode.ValueType
    FLAT_MODE_TIME_WARP_VIDEO: _EnumFlatMode.ValueType
    FLAT_MODE_LIVE_BURST: _EnumFlatMode.ValueType
    FLAT_MODE_NIGHT_LAPSE_VIDEO: _EnumFlatMode.ValueType
    FLAT_MODE_SLOMO: _EnumFlatMode.ValueType
    FLAT_MODE_IDLE: _EnumFlatMode.ValueType
    FLAT_MODE_VIDEO_STAR_TRAIL: _EnumFlatMode.ValueType
    FLAT_MODE_VIDEO_LIGHT_PAINTING: _EnumFlatMode.ValueType
    FLAT_MODE_VIDEO_LIGHT_TRAIL: _EnumFlatMode.ValueType
    FLAT_MODE_VIDEO_BURST_SLOMO: _EnumFlatMode.ValueType

class EnumFlatMode(_EnumFlatMode, metaclass=_EnumFlatModeEnumTypeWrapper): ...

FLAT_MODE_UNKNOWN: EnumFlatMode.ValueType
FLAT_MODE_PLAYBACK: EnumFlatMode.ValueType
FLAT_MODE_SETUP: EnumFlatMode.ValueType
FLAT_MODE_VIDEO: EnumFlatMode.ValueType
FLAT_MODE_TIME_LAPSE_VIDEO: EnumFlatMode.ValueType
FLAT_MODE_LOOPING: EnumFlatMode.ValueType
FLAT_MODE_PHOTO_SINGLE: EnumFlatMode.ValueType
FLAT_MODE_PHOTO: EnumFlatMode.ValueType
FLAT_MODE_PHOTO_NIGHT: EnumFlatMode.ValueType
FLAT_MODE_PHOTO_BURST: EnumFlatMode.ValueType
FLAT_MODE_TIME_LAPSE_PHOTO: EnumFlatMode.ValueType
FLAT_MODE_NIGHT_LAPSE_PHOTO: EnumFlatMode.ValueType
FLAT_MODE_BROADCAST_RECORD: EnumFlatMode.ValueType
FLAT_MODE_BROADCAST_BROADCAST: EnumFlatMode.ValueType
FLAT_MODE_TIME_WARP_VIDEO: EnumFlatMode.ValueType
FLAT_MODE_LIVE_BURST: EnumFlatMode.ValueType
FLAT_MODE_NIGHT_LAPSE_VIDEO: EnumFlatMode.ValueType
FLAT_MODE_SLOMO: EnumFlatMode.ValueType
FLAT_MODE_IDLE: EnumFlatMode.ValueType
FLAT_MODE_VIDEO_STAR_TRAIL: EnumFlatMode.ValueType
FLAT_MODE_VIDEO_LIGHT_PAINTING: EnumFlatMode.ValueType
FLAT_MODE_VIDEO_LIGHT_TRAIL: EnumFlatMode.ValueType
FLAT_MODE_VIDEO_BURST_SLOMO: EnumFlatMode.ValueType
global___EnumFlatMode = EnumFlatMode

class _EnumPresetGroup:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EnumPresetGroupEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnumPresetGroup.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    PRESET_GROUP_ID_VIDEO: _EnumPresetGroup.ValueType
    PRESET_GROUP_ID_PHOTO: _EnumPresetGroup.ValueType
    PRESET_GROUP_ID_TIMELAPSE: _EnumPresetGroup.ValueType

class EnumPresetGroup(_EnumPresetGroup, metaclass=_EnumPresetGroupEnumTypeWrapper): ...

PRESET_GROUP_ID_VIDEO: EnumPresetGroup.ValueType
PRESET_GROUP_ID_PHOTO: EnumPresetGroup.ValueType
PRESET_GROUP_ID_TIMELAPSE: EnumPresetGroup.ValueType
global___EnumPresetGroup = EnumPresetGroup

class _EnumPresetGroupIcon:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EnumPresetGroupIconEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnumPresetGroupIcon.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    PRESET_GROUP_VIDEO_ICON_ID: _EnumPresetGroupIcon.ValueType
    PRESET_GROUP_PHOTO_ICON_ID: _EnumPresetGroupIcon.ValueType
    PRESET_GROUP_TIMELAPSE_ICON_ID: _EnumPresetGroupIcon.ValueType
    PRESET_GROUP_LONG_BAT_VIDEO_ICON_ID: _EnumPresetGroupIcon.ValueType
    PRESET_GROUP_ENDURANCE_VIDEO_ICON_ID: _EnumPresetGroupIcon.ValueType
    PRESET_GROUP_MAX_VIDEO_ICON_ID: _EnumPresetGroupIcon.ValueType
    PRESET_GROUP_MAX_PHOTO_ICON_ID: _EnumPresetGroupIcon.ValueType
    PRESET_GROUP_MAX_TIMELAPSE_ICON_ID: _EnumPresetGroupIcon.ValueType
    PRESET_GROUP_ND_MOD_VIDEO_ICON_ID: _EnumPresetGroupIcon.ValueType
    PRESET_GROUP_ND_MOD_PHOTO_ICON_ID: _EnumPresetGroupIcon.ValueType
    PRESET_GROUP_ND_MOD_TIMELAPSE_ICON_ID: _EnumPresetGroupIcon.ValueType

class EnumPresetGroupIcon(_EnumPresetGroupIcon, metaclass=_EnumPresetGroupIconEnumTypeWrapper): ...

PRESET_GROUP_VIDEO_ICON_ID: EnumPresetGroupIcon.ValueType
PRESET_GROUP_PHOTO_ICON_ID: EnumPresetGroupIcon.ValueType
PRESET_GROUP_TIMELAPSE_ICON_ID: EnumPresetGroupIcon.ValueType
PRESET_GROUP_LONG_BAT_VIDEO_ICON_ID: EnumPresetGroupIcon.ValueType
PRESET_GROUP_ENDURANCE_VIDEO_ICON_ID: EnumPresetGroupIcon.ValueType
PRESET_GROUP_MAX_VIDEO_ICON_ID: EnumPresetGroupIcon.ValueType
PRESET_GROUP_MAX_PHOTO_ICON_ID: EnumPresetGroupIcon.ValueType
PRESET_GROUP_MAX_TIMELAPSE_ICON_ID: EnumPresetGroupIcon.ValueType
PRESET_GROUP_ND_MOD_VIDEO_ICON_ID: EnumPresetGroupIcon.ValueType
PRESET_GROUP_ND_MOD_PHOTO_ICON_ID: EnumPresetGroupIcon.ValueType
PRESET_GROUP_ND_MOD_TIMELAPSE_ICON_ID: EnumPresetGroupIcon.ValueType
global___EnumPresetGroupIcon = EnumPresetGroupIcon

class _EnumPresetIcon:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EnumPresetIconEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnumPresetIcon.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    PRESET_ICON_VIDEO: _EnumPresetIcon.ValueType
    PRESET_ICON_ACTIVITY: _EnumPresetIcon.ValueType
    PRESET_ICON_CINEMATIC: _EnumPresetIcon.ValueType
    PRESET_ICON_PHOTO: _EnumPresetIcon.ValueType
    PRESET_ICON_LIVE_BURST: _EnumPresetIcon.ValueType
    PRESET_ICON_BURST: _EnumPresetIcon.ValueType
    PRESET_ICON_PHOTO_NIGHT: _EnumPresetIcon.ValueType
    PRESET_ICON_TIMEWARP: _EnumPresetIcon.ValueType
    PRESET_ICON_TIMELAPSE: _EnumPresetIcon.ValueType
    PRESET_ICON_NIGHTLAPSE: _EnumPresetIcon.ValueType
    PRESET_ICON_SNAIL: _EnumPresetIcon.ValueType
    PRESET_ICON_VIDEO_2: _EnumPresetIcon.ValueType
    PRESET_ICON_PHOTO_2: _EnumPresetIcon.ValueType
    PRESET_ICON_PANORAMA: _EnumPresetIcon.ValueType
    PRESET_ICON_BURST_2: _EnumPresetIcon.ValueType
    PRESET_ICON_TIMEWARP_2: _EnumPresetIcon.ValueType
    PRESET_ICON_TIMELAPSE_2: _EnumPresetIcon.ValueType
    PRESET_ICON_CUSTOM: _EnumPresetIcon.ValueType
    PRESET_ICON_AIR: _EnumPresetIcon.ValueType
    PRESET_ICON_BIKE: _EnumPresetIcon.ValueType
    PRESET_ICON_EPIC: _EnumPresetIcon.ValueType
    PRESET_ICON_INDOOR: _EnumPresetIcon.ValueType
    PRESET_ICON_MOTOR: _EnumPresetIcon.ValueType
    PRESET_ICON_MOUNTED: _EnumPresetIcon.ValueType
    PRESET_ICON_OUTDOOR: _EnumPresetIcon.ValueType
    PRESET_ICON_POV: _EnumPresetIcon.ValueType
    PRESET_ICON_SELFIE: _EnumPresetIcon.ValueType
    PRESET_ICON_SKATE: _EnumPresetIcon.ValueType
    PRESET_ICON_SNOW: _EnumPresetIcon.ValueType
    PRESET_ICON_TRAIL: _EnumPresetIcon.ValueType
    PRESET_ICON_TRAVEL: _EnumPresetIcon.ValueType
    PRESET_ICON_WATER: _EnumPresetIcon.ValueType
    PRESET_ICON_LOOPING: _EnumPresetIcon.ValueType
    PRESET_ICON_STARS: _EnumPresetIcon.ValueType
    PRESET_ICON_ACTION: _EnumPresetIcon.ValueType
    PRESET_ICON_FOLLOW_CAM: _EnumPresetIcon.ValueType
    PRESET_ICON_SURF: _EnumPresetIcon.ValueType
    PRESET_ICON_CITY: _EnumPresetIcon.ValueType
    PRESET_ICON_SHAKY: _EnumPresetIcon.ValueType
    PRESET_ICON_CHESTY: _EnumPresetIcon.ValueType
    PRESET_ICON_HELMET: _EnumPresetIcon.ValueType
    PRESET_ICON_BITE: _EnumPresetIcon.ValueType
    PRESET_ICON_CUSTOM_CINEMATIC: _EnumPresetIcon.ValueType
    PRESET_ICON_VLOG: _EnumPresetIcon.ValueType
    PRESET_ICON_FPV: _EnumPresetIcon.ValueType
    PRESET_ICON_HDR: _EnumPresetIcon.ValueType
    PRESET_ICON_LANDSCAPE: _EnumPresetIcon.ValueType
    PRESET_ICON_LOG: _EnumPresetIcon.ValueType
    PRESET_ICON_CUSTOM_SLOMO: _EnumPresetIcon.ValueType
    PRESET_ICON_TRIPOD: _EnumPresetIcon.ValueType
    PRESET_ICON_MAX_VIDEO: _EnumPresetIcon.ValueType
    PRESET_ICON_MAX_PHOTO: _EnumPresetIcon.ValueType
    PRESET_ICON_MAX_TIMEWARP: _EnumPresetIcon.ValueType
    PRESET_ICON_BASIC: _EnumPresetIcon.ValueType
    PRESET_ICON_ULTRA_SLO_MO: _EnumPresetIcon.ValueType
    PRESET_ICON_STANDARD_ENDURANCE: _EnumPresetIcon.ValueType
    PRESET_ICON_ACTIVITY_ENDURANCE: _EnumPresetIcon.ValueType
    PRESET_ICON_CINEMATIC_ENDURANCE: _EnumPresetIcon.ValueType
    PRESET_ICON_SLOMO_ENDURANCE: _EnumPresetIcon.ValueType
    PRESET_ICON_STATIONARY_1: _EnumPresetIcon.ValueType
    PRESET_ICON_STATIONARY_2: _EnumPresetIcon.ValueType
    PRESET_ICON_STATIONARY_3: _EnumPresetIcon.ValueType
    PRESET_ICON_STATIONARY_4: _EnumPresetIcon.ValueType
    PRESET_ICON_SIMPLE_SUPER_PHOTO: _EnumPresetIcon.ValueType
    PRESET_ICON_SIMPLE_NIGHT_PHOTO: _EnumPresetIcon.ValueType
    PRESET_ICON_HIGHEST_QUALITY_VIDEO: _EnumPresetIcon.ValueType
    PRESET_ICON_STANDARD_QUALITY_VIDEO: _EnumPresetIcon.ValueType
    PRESET_ICON_BASIC_QUALITY_VIDEO: _EnumPresetIcon.ValueType
    PRESET_ICON_STAR_TRAIL: _EnumPresetIcon.ValueType
    PRESET_ICON_LIGHT_PAINTING: _EnumPresetIcon.ValueType
    PRESET_ICON_LIGHT_TRAIL: _EnumPresetIcon.ValueType
    PRESET_ICON_FULL_FRAME: _EnumPresetIcon.ValueType
    PRESET_ICON_EASY_MAX_VIDEO: _EnumPresetIcon.ValueType
    PRESET_ICON_EASY_MAX_PHOTO: _EnumPresetIcon.ValueType
    PRESET_ICON_EASY_MAX_TIMEWARP: _EnumPresetIcon.ValueType
    PRESET_ICON_EASY_MAX_STAR_TRAIL: _EnumPresetIcon.ValueType
    PRESET_ICON_EASY_MAX_LIGHT_PAINTING: _EnumPresetIcon.ValueType
    PRESET_ICON_EASY_MAX_LIGHT_TRAIL: _EnumPresetIcon.ValueType
    PRESET_ICON_MAX_STAR_TRAIL: _EnumPresetIcon.ValueType
    PRESET_ICON_MAX_LIGHT_PAINTING: _EnumPresetIcon.ValueType
    PRESET_ICON_MAX_LIGHT_TRAIL: _EnumPresetIcon.ValueType
    PRESET_ICON_EASY_STANDARD_PROFILE: _EnumPresetIcon.ValueType
    PRESET_ICON_EASY_HDR_PROFILE: _EnumPresetIcon.ValueType
    PRESET_ICON_BURST_SLOMO: _EnumPresetIcon.ValueType
    PRESET_ICON_TIMELAPSE_PHOTO: _EnumPresetIcon.ValueType
    PRESET_ICON_NIGHTLAPSE_PHOTO: _EnumPresetIcon.ValueType

class EnumPresetIcon(_EnumPresetIcon, metaclass=_EnumPresetIconEnumTypeWrapper): ...

PRESET_ICON_VIDEO: EnumPresetIcon.ValueType
PRESET_ICON_ACTIVITY: EnumPresetIcon.ValueType
PRESET_ICON_CINEMATIC: EnumPresetIcon.ValueType
PRESET_ICON_PHOTO: EnumPresetIcon.ValueType
PRESET_ICON_LIVE_BURST: EnumPresetIcon.ValueType
PRESET_ICON_BURST: EnumPresetIcon.ValueType
PRESET_ICON_PHOTO_NIGHT: EnumPresetIcon.ValueType
PRESET_ICON_TIMEWARP: EnumPresetIcon.ValueType
PRESET_ICON_TIMELAPSE: EnumPresetIcon.ValueType
PRESET_ICON_NIGHTLAPSE: EnumPresetIcon.ValueType
PRESET_ICON_SNAIL: EnumPresetIcon.ValueType
PRESET_ICON_VIDEO_2: EnumPresetIcon.ValueType
PRESET_ICON_PHOTO_2: EnumPresetIcon.ValueType
PRESET_ICON_PANORAMA: EnumPresetIcon.ValueType
PRESET_ICON_BURST_2: EnumPresetIcon.ValueType
PRESET_ICON_TIMEWARP_2: EnumPresetIcon.ValueType
PRESET_ICON_TIMELAPSE_2: EnumPresetIcon.ValueType
PRESET_ICON_CUSTOM: EnumPresetIcon.ValueType
PRESET_ICON_AIR: EnumPresetIcon.ValueType
PRESET_ICON_BIKE: EnumPresetIcon.ValueType
PRESET_ICON_EPIC: EnumPresetIcon.ValueType
PRESET_ICON_INDOOR: EnumPresetIcon.ValueType
PRESET_ICON_MOTOR: EnumPresetIcon.ValueType
PRESET_ICON_MOUNTED: EnumPresetIcon.ValueType
PRESET_ICON_OUTDOOR: EnumPresetIcon.ValueType
PRESET_ICON_POV: EnumPresetIcon.ValueType
PRESET_ICON_SELFIE: EnumPresetIcon.ValueType
PRESET_ICON_SKATE: EnumPresetIcon.ValueType
PRESET_ICON_SNOW: EnumPresetIcon.ValueType
PRESET_ICON_TRAIL: EnumPresetIcon.ValueType
PRESET_ICON_TRAVEL: EnumPresetIcon.ValueType
PRESET_ICON_WATER: EnumPresetIcon.ValueType
PRESET_ICON_LOOPING: EnumPresetIcon.ValueType
PRESET_ICON_STARS: EnumPresetIcon.ValueType
PRESET_ICON_ACTION: EnumPresetIcon.ValueType
PRESET_ICON_FOLLOW_CAM: EnumPresetIcon.ValueType
PRESET_ICON_SURF: EnumPresetIcon.ValueType
PRESET_ICON_CITY: EnumPresetIcon.ValueType
PRESET_ICON_SHAKY: EnumPresetIcon.ValueType
PRESET_ICON_CHESTY: EnumPresetIcon.ValueType
PRESET_ICON_HELMET: EnumPresetIcon.ValueType
PRESET_ICON_BITE: EnumPresetIcon.ValueType
PRESET_ICON_CUSTOM_CINEMATIC: EnumPresetIcon.ValueType
PRESET_ICON_VLOG: EnumPresetIcon.ValueType
PRESET_ICON_FPV: EnumPresetIcon.ValueType
PRESET_ICON_HDR: EnumPresetIcon.ValueType
PRESET_ICON_LANDSCAPE: EnumPresetIcon.ValueType
PRESET_ICON_LOG: EnumPresetIcon.ValueType
PRESET_ICON_CUSTOM_SLOMO: EnumPresetIcon.ValueType
PRESET_ICON_TRIPOD: EnumPresetIcon.ValueType
PRESET_ICON_MAX_VIDEO: EnumPresetIcon.ValueType
PRESET_ICON_MAX_PHOTO: EnumPresetIcon.ValueType
PRESET_ICON_MAX_TIMEWARP: EnumPresetIcon.ValueType
PRESET_ICON_BASIC: EnumPresetIcon.ValueType
PRESET_ICON_ULTRA_SLO_MO: EnumPresetIcon.ValueType
PRESET_ICON_STANDARD_ENDURANCE: EnumPresetIcon.ValueType
PRESET_ICON_ACTIVITY_ENDURANCE: EnumPresetIcon.ValueType
PRESET_ICON_CINEMATIC_ENDURANCE: EnumPresetIcon.ValueType
PRESET_ICON_SLOMO_ENDURANCE: EnumPresetIcon.ValueType
PRESET_ICON_STATIONARY_1: EnumPresetIcon.ValueType
PRESET_ICON_STATIONARY_2: EnumPresetIcon.ValueType
PRESET_ICON_STATIONARY_3: EnumPresetIcon.ValueType
PRESET_ICON_STATIONARY_4: EnumPresetIcon.ValueType
PRESET_ICON_SIMPLE_SUPER_PHOTO: EnumPresetIcon.ValueType
PRESET_ICON_SIMPLE_NIGHT_PHOTO: EnumPresetIcon.ValueType
PRESET_ICON_HIGHEST_QUALITY_VIDEO: EnumPresetIcon.ValueType
PRESET_ICON_STANDARD_QUALITY_VIDEO: EnumPresetIcon.ValueType
PRESET_ICON_BASIC_QUALITY_VIDEO: EnumPresetIcon.ValueType
PRESET_ICON_STAR_TRAIL: EnumPresetIcon.ValueType
PRESET_ICON_LIGHT_PAINTING: EnumPresetIcon.ValueType
PRESET_ICON_LIGHT_TRAIL: EnumPresetIcon.ValueType
PRESET_ICON_FULL_FRAME: EnumPresetIcon.ValueType
PRESET_ICON_EASY_MAX_VIDEO: EnumPresetIcon.ValueType
PRESET_ICON_EASY_MAX_PHOTO: EnumPresetIcon.ValueType
PRESET_ICON_EASY_MAX_TIMEWARP: EnumPresetIcon.ValueType
PRESET_ICON_EASY_MAX_STAR_TRAIL: EnumPresetIcon.ValueType
PRESET_ICON_EASY_MAX_LIGHT_PAINTING: EnumPresetIcon.ValueType
PRESET_ICON_EASY_MAX_LIGHT_TRAIL: EnumPresetIcon.ValueType
PRESET_ICON_MAX_STAR_TRAIL: EnumPresetIcon.ValueType
PRESET_ICON_MAX_LIGHT_PAINTING: EnumPresetIcon.ValueType
PRESET_ICON_MAX_LIGHT_TRAIL: EnumPresetIcon.ValueType
PRESET_ICON_EASY_STANDARD_PROFILE: EnumPresetIcon.ValueType
PRESET_ICON_EASY_HDR_PROFILE: EnumPresetIcon.ValueType
PRESET_ICON_BURST_SLOMO: EnumPresetIcon.ValueType
PRESET_ICON_TIMELAPSE_PHOTO: EnumPresetIcon.ValueType
PRESET_ICON_NIGHTLAPSE_PHOTO: EnumPresetIcon.ValueType
global___EnumPresetIcon = EnumPresetIcon

class _EnumPresetTitle:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EnumPresetTitleEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnumPresetTitle.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    PRESET_TITLE_ACTIVITY: _EnumPresetTitle.ValueType
    PRESET_TITLE_STANDARD: _EnumPresetTitle.ValueType
    PRESET_TITLE_CINEMATIC: _EnumPresetTitle.ValueType
    PRESET_TITLE_PHOTO: _EnumPresetTitle.ValueType
    PRESET_TITLE_LIVE_BURST: _EnumPresetTitle.ValueType
    PRESET_TITLE_BURST: _EnumPresetTitle.ValueType
    PRESET_TITLE_NIGHT: _EnumPresetTitle.ValueType
    PRESET_TITLE_TIME_WARP: _EnumPresetTitle.ValueType
    PRESET_TITLE_TIME_LAPSE: _EnumPresetTitle.ValueType
    PRESET_TITLE_NIGHT_LAPSE: _EnumPresetTitle.ValueType
    PRESET_TITLE_VIDEO: _EnumPresetTitle.ValueType
    PRESET_TITLE_SLOMO: _EnumPresetTitle.ValueType
    PRESET_TITLE_PHOTO_2: _EnumPresetTitle.ValueType
    PRESET_TITLE_PANORAMA: _EnumPresetTitle.ValueType
    PRESET_TITLE_TIME_WARP_2: _EnumPresetTitle.ValueType
    PRESET_TITLE_CUSTOM: _EnumPresetTitle.ValueType
    PRESET_TITLE_AIR: _EnumPresetTitle.ValueType
    PRESET_TITLE_BIKE: _EnumPresetTitle.ValueType
    PRESET_TITLE_EPIC: _EnumPresetTitle.ValueType
    PRESET_TITLE_INDOOR: _EnumPresetTitle.ValueType
    PRESET_TITLE_MOTOR: _EnumPresetTitle.ValueType
    PRESET_TITLE_MOUNTED: _EnumPresetTitle.ValueType
    PRESET_TITLE_OUTDOOR: _EnumPresetTitle.ValueType
    PRESET_TITLE_POV: _EnumPresetTitle.ValueType
    PRESET_TITLE_SELFIE: _EnumPresetTitle.ValueType
    PRESET_TITLE_SKATE: _EnumPresetTitle.ValueType
    PRESET_TITLE_SNOW: _EnumPresetTitle.ValueType
    PRESET_TITLE_TRAIL: _EnumPresetTitle.ValueType
    PRESET_TITLE_TRAVEL: _EnumPresetTitle.ValueType
    PRESET_TITLE_WATER: _EnumPresetTitle.ValueType
    PRESET_TITLE_LOOPING: _EnumPresetTitle.ValueType
    PRESET_TITLE_STARS: _EnumPresetTitle.ValueType
    PRESET_TITLE_ACTION: _EnumPresetTitle.ValueType
    PRESET_TITLE_FOLLOW_CAM: _EnumPresetTitle.ValueType
    PRESET_TITLE_SURF: _EnumPresetTitle.ValueType
    PRESET_TITLE_CITY: _EnumPresetTitle.ValueType
    PRESET_TITLE_SHAKY: _EnumPresetTitle.ValueType
    PRESET_TITLE_CHESTY: _EnumPresetTitle.ValueType
    PRESET_TITLE_HELMET: _EnumPresetTitle.ValueType
    PRESET_TITLE_BITE: _EnumPresetTitle.ValueType
    PRESET_TITLE_CUSTOM_CINEMATIC: _EnumPresetTitle.ValueType
    PRESET_TITLE_VLOG: _EnumPresetTitle.ValueType
    PRESET_TITLE_FPV: _EnumPresetTitle.ValueType
    PRESET_TITLE_HDR: _EnumPresetTitle.ValueType
    PRESET_TITLE_LANDSCAPE: _EnumPresetTitle.ValueType
    PRESET_TITLE_LOG: _EnumPresetTitle.ValueType
    PRESET_TITLE_CUSTOM_SLOMO: _EnumPresetTitle.ValueType
    PRESET_TITLE_TRIPOD: _EnumPresetTitle.ValueType
    PRESET_TITLE_BASIC: _EnumPresetTitle.ValueType
    PRESET_TITLE_ULTRA_SLO_MO: _EnumPresetTitle.ValueType
    PRESET_TITLE_STANDARD_ENDURANCE: _EnumPresetTitle.ValueType
    PRESET_TITLE_ACTIVITY_ENDURANCE: _EnumPresetTitle.ValueType
    PRESET_TITLE_CINEMATIC_ENDURANCE: _EnumPresetTitle.ValueType
    PRESET_TITLE_SLOMO_ENDURANCE: _EnumPresetTitle.ValueType
    PRESET_TITLE_STATIONARY_1: _EnumPresetTitle.ValueType
    PRESET_TITLE_STATIONARY_2: _EnumPresetTitle.ValueType
    PRESET_TITLE_STATIONARY_3: _EnumPresetTitle.ValueType
    PRESET_TITLE_STATIONARY_4: _EnumPresetTitle.ValueType
    PRESET_TITLE_SIMPLE_VIDEO: _EnumPresetTitle.ValueType
    PRESET_TITLE_SIMPLE_TIME_WARP: _EnumPresetTitle.ValueType
    PRESET_TITLE_SIMPLE_SUPER_PHOTO: _EnumPresetTitle.ValueType
    PRESET_TITLE_SIMPLE_NIGHT_PHOTO: _EnumPresetTitle.ValueType
    PRESET_TITLE_SIMPLE_VIDEO_ENDURANCE: _EnumPresetTitle.ValueType
    PRESET_TITLE_HIGHEST_QUALITY: _EnumPresetTitle.ValueType
    PRESET_TITLE_EXTENDED_BATTERY: _EnumPresetTitle.ValueType
    PRESET_TITLE_LONGEST_BATTERY: _EnumPresetTitle.ValueType
    PRESET_TITLE_STAR_TRAIL: _EnumPresetTitle.ValueType
    PRESET_TITLE_LIGHT_PAINTING: _EnumPresetTitle.ValueType
    PRESET_TITLE_LIGHT_TRAIL: _EnumPresetTitle.ValueType
    PRESET_TITLE_FULL_FRAME: _EnumPresetTitle.ValueType
    PRESET_TITLE_STANDARD_QUALITY_VIDEO: _EnumPresetTitle.ValueType
    PRESET_TITLE_BASIC_QUALITY_VIDEO: _EnumPresetTitle.ValueType
    PRESET_TITLE_HIGHEST_QUALITY_VIDEO: _EnumPresetTitle.ValueType
    PRESET_TITLE_USER_DEFINED_CUSTOM_NAME: _EnumPresetTitle.ValueType
    PRESET_TITLE_EASY_STANDARD_PROFILE: _EnumPresetTitle.ValueType
    PRESET_TITLE_EASY_HDR_PROFILE: _EnumPresetTitle.ValueType
    PRESET_TITLE_BURST_SLOMO: _EnumPresetTitle.ValueType

class EnumPresetTitle(_EnumPresetTitle, metaclass=_EnumPresetTitleEnumTypeWrapper): ...

PRESET_TITLE_ACTIVITY: EnumPresetTitle.ValueType
PRESET_TITLE_STANDARD: EnumPresetTitle.ValueType
PRESET_TITLE_CINEMATIC: EnumPresetTitle.ValueType
PRESET_TITLE_PHOTO: EnumPresetTitle.ValueType
PRESET_TITLE_LIVE_BURST: EnumPresetTitle.ValueType
PRESET_TITLE_BURST: EnumPresetTitle.ValueType
PRESET_TITLE_NIGHT: EnumPresetTitle.ValueType
PRESET_TITLE_TIME_WARP: EnumPresetTitle.ValueType
PRESET_TITLE_TIME_LAPSE: EnumPresetTitle.ValueType
PRESET_TITLE_NIGHT_LAPSE: EnumPresetTitle.ValueType
PRESET_TITLE_VIDEO: EnumPresetTitle.ValueType
PRESET_TITLE_SLOMO: EnumPresetTitle.ValueType
PRESET_TITLE_PHOTO_2: EnumPresetTitle.ValueType
PRESET_TITLE_PANORAMA: EnumPresetTitle.ValueType
PRESET_TITLE_TIME_WARP_2: EnumPresetTitle.ValueType
PRESET_TITLE_CUSTOM: EnumPresetTitle.ValueType
PRESET_TITLE_AIR: EnumPresetTitle.ValueType
PRESET_TITLE_BIKE: EnumPresetTitle.ValueType
PRESET_TITLE_EPIC: EnumPresetTitle.ValueType
PRESET_TITLE_INDOOR: EnumPresetTitle.ValueType
PRESET_TITLE_MOTOR: EnumPresetTitle.ValueType
PRESET_TITLE_MOUNTED: EnumPresetTitle.ValueType
PRESET_TITLE_OUTDOOR: EnumPresetTitle.ValueType
PRESET_TITLE_POV: EnumPresetTitle.ValueType
PRESET_TITLE_SELFIE: EnumPresetTitle.ValueType
PRESET_TITLE_SKATE: EnumPresetTitle.ValueType
PRESET_TITLE_SNOW: EnumPresetTitle.ValueType
PRESET_TITLE_TRAIL: EnumPresetTitle.ValueType
PRESET_TITLE_TRAVEL: EnumPresetTitle.ValueType
PRESET_TITLE_WATER: EnumPresetTitle.ValueType
PRESET_TITLE_LOOPING: EnumPresetTitle.ValueType
PRESET_TITLE_STARS: EnumPresetTitle.ValueType
PRESET_TITLE_ACTION: EnumPresetTitle.ValueType
PRESET_TITLE_FOLLOW_CAM: EnumPresetTitle.ValueType
PRESET_TITLE_SURF: EnumPresetTitle.ValueType
PRESET_TITLE_CITY: EnumPresetTitle.ValueType
PRESET_TITLE_SHAKY: EnumPresetTitle.ValueType
PRESET_TITLE_CHESTY: EnumPresetTitle.ValueType
PRESET_TITLE_HELMET: EnumPresetTitle.ValueType
PRESET_TITLE_BITE: EnumPresetTitle.ValueType
PRESET_TITLE_CUSTOM_CINEMATIC: EnumPresetTitle.ValueType
PRESET_TITLE_VLOG: EnumPresetTitle.ValueType
PRESET_TITLE_FPV: EnumPresetTitle.ValueType
PRESET_TITLE_HDR: EnumPresetTitle.ValueType
PRESET_TITLE_LANDSCAPE: EnumPresetTitle.ValueType
PRESET_TITLE_LOG: EnumPresetTitle.ValueType
PRESET_TITLE_CUSTOM_SLOMO: EnumPresetTitle.ValueType
PRESET_TITLE_TRIPOD: EnumPresetTitle.ValueType
PRESET_TITLE_BASIC: EnumPresetTitle.ValueType
PRESET_TITLE_ULTRA_SLO_MO: EnumPresetTitle.ValueType
PRESET_TITLE_STANDARD_ENDURANCE: EnumPresetTitle.ValueType
PRESET_TITLE_ACTIVITY_ENDURANCE: EnumPresetTitle.ValueType
PRESET_TITLE_CINEMATIC_ENDURANCE: EnumPresetTitle.ValueType
PRESET_TITLE_SLOMO_ENDURANCE: EnumPresetTitle.ValueType
PRESET_TITLE_STATIONARY_1: EnumPresetTitle.ValueType
PRESET_TITLE_STATIONARY_2: EnumPresetTitle.ValueType
PRESET_TITLE_STATIONARY_3: EnumPresetTitle.ValueType
PRESET_TITLE_STATIONARY_4: EnumPresetTitle.ValueType
PRESET_TITLE_SIMPLE_VIDEO: EnumPresetTitle.ValueType
PRESET_TITLE_SIMPLE_TIME_WARP: EnumPresetTitle.ValueType
PRESET_TITLE_SIMPLE_SUPER_PHOTO: EnumPresetTitle.ValueType
PRESET_TITLE_SIMPLE_NIGHT_PHOTO: EnumPresetTitle.ValueType
PRESET_TITLE_SIMPLE_VIDEO_ENDURANCE: EnumPresetTitle.ValueType
PRESET_TITLE_HIGHEST_QUALITY: EnumPresetTitle.ValueType
PRESET_TITLE_EXTENDED_BATTERY: EnumPresetTitle.ValueType
PRESET_TITLE_LONGEST_BATTERY: EnumPresetTitle.ValueType
PRESET_TITLE_STAR_TRAIL: EnumPresetTitle.ValueType
PRESET_TITLE_LIGHT_PAINTING: EnumPresetTitle.ValueType
PRESET_TITLE_LIGHT_TRAIL: EnumPresetTitle.ValueType
PRESET_TITLE_FULL_FRAME: EnumPresetTitle.ValueType
PRESET_TITLE_STANDARD_QUALITY_VIDEO: EnumPresetTitle.ValueType
PRESET_TITLE_BASIC_QUALITY_VIDEO: EnumPresetTitle.ValueType
PRESET_TITLE_HIGHEST_QUALITY_VIDEO: EnumPresetTitle.ValueType
PRESET_TITLE_USER_DEFINED_CUSTOM_NAME: EnumPresetTitle.ValueType
PRESET_TITLE_EASY_STANDARD_PROFILE: EnumPresetTitle.ValueType
PRESET_TITLE_EASY_HDR_PROFILE: EnumPresetTitle.ValueType
PRESET_TITLE_BURST_SLOMO: EnumPresetTitle.ValueType
global___EnumPresetTitle = EnumPresetTitle

@typing_extensions.final
class NotifyPresetStatus(google.protobuf.message.Message):
    """*
    Current Preset status

    Sent either:

    - Synchronously via initial response to @ref RequestGetPresetStatus
    - Asynchronously when Preset change if registered in @ref RequestGetPresetStatus
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    PRESET_GROUP_ARRAY_FIELD_NUMBER: builtins.int

    @property
    def preset_group_array(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PresetGroup]:
        """List of currently available Preset Groups"""
    def __init__(self, *, preset_group_array: collections.abc.Iterable[global___PresetGroup] | None = ...) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal["preset_group_array", b"preset_group_array"],
    ) -> None: ...

global___NotifyPresetStatus = NotifyPresetStatus

@typing_extensions.final
class Preset(google.protobuf.message.Message):
    """*
    An individual preset.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    ID_FIELD_NUMBER: builtins.int
    MODE_FIELD_NUMBER: builtins.int
    TITLE_ID_FIELD_NUMBER: builtins.int
    TITLE_NUMBER_FIELD_NUMBER: builtins.int
    USER_DEFINED_FIELD_NUMBER: builtins.int
    ICON_FIELD_NUMBER: builtins.int
    SETTING_ARRAY_FIELD_NUMBER: builtins.int
    IS_MODIFIED_FIELD_NUMBER: builtins.int
    IS_FIXED_FIELD_NUMBER: builtins.int
    CUSTOM_NAME_FIELD_NUMBER: builtins.int
    id: builtins.int
    "Preset ID"
    mode: global___EnumFlatMode.ValueType
    "Preset flatmode ID"
    title_id: global___EnumPresetTitle.ValueType
    "Preset Title ID"
    title_number: builtins.int
    "Preset Title Number (e.g. 1/2/3 in Custom1, Custom2, Custom3)"
    user_defined: builtins.bool
    "Is the Preset custom/user-defined?"
    icon: global___EnumPresetIcon.ValueType
    "Preset Icon ID"

    @property
    def setting_array(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PresetSetting]:
        """Array of settings associated with this Preset"""
    is_modified: builtins.bool
    "Has Preset been modified from factory defaults? (False for user-defined Presets)"
    is_fixed: builtins.bool
    "Is this Preset mutable?"
    custom_name: builtins.str
    "Custom string name given to this preset via @ref RequestCustomPresetUpdate"

    def __init__(
        self,
        *,
        id: builtins.int | None = ...,
        mode: global___EnumFlatMode.ValueType | None = ...,
        title_id: global___EnumPresetTitle.ValueType | None = ...,
        title_number: builtins.int | None = ...,
        user_defined: builtins.bool | None = ...,
        icon: global___EnumPresetIcon.ValueType | None = ...,
        setting_array: collections.abc.Iterable[global___PresetSetting] | None = ...,
        is_modified: builtins.bool | None = ...,
        is_fixed: builtins.bool | None = ...,
        custom_name: builtins.str | None = ...
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "custom_name",
            b"custom_name",
            "icon",
            b"icon",
            "id",
            b"id",
            "is_fixed",
            b"is_fixed",
            "is_modified",
            b"is_modified",
            "mode",
            b"mode",
            "title_id",
            b"title_id",
            "title_number",
            b"title_number",
            "user_defined",
            b"user_defined",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "custom_name",
            b"custom_name",
            "icon",
            b"icon",
            "id",
            b"id",
            "is_fixed",
            b"is_fixed",
            "is_modified",
            b"is_modified",
            "mode",
            b"mode",
            "setting_array",
            b"setting_array",
            "title_id",
            b"title_id",
            "title_number",
            b"title_number",
            "user_defined",
            b"user_defined",
        ],
    ) -> None: ...

global___Preset = Preset

@typing_extensions.final
class RequestCustomPresetUpdate(google.protobuf.message.Message):
    """*
    Request to Update the Title and / or Icon of the Active Custom Preset

    This only operates on the currently active Preset and will fail  if the current
    Preset is not custom.

    The use cases are:

    1. Update the Custom Preset Icon

        - `icon_id` is always optional and can always be passed

    and / or

    2. Update the Custom Preset Title to a...

         - **Factory Preset Title**: Set `title_id` to a non-PRESET_TITLE_USER_DEFINED_CUSTOM_NAME (94) value
         - **Custom Preset Name**: Set `title_id` to PRESET_TITLE_USER_DEFINED_CUSTOM_NAME (94) and specify a `custom_name`

    Returns a @ref ResponseGeneric with the status of the preset update request.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    TITLE_ID_FIELD_NUMBER: builtins.int
    CUSTOM_NAME_FIELD_NUMBER: builtins.int
    ICON_ID_FIELD_NUMBER: builtins.int
    title_id: global___EnumPresetTitle.ValueType
    "*\n    Preset Title ID\n\n    The range of acceptable custom title ID's can be found in the initial @ref NotifyPresetStatus response\n    to @ref RequestGetPresetStatus\n    "
    custom_name: builtins.str
    "*\n    UTF-8 encoded custom preset name to be used if `title_id` is set to 94 (PRESET_TITLE_USER_DEFINED_CUSTOM_NAME)\n\n    The name must obey the following:\n\n      - Custom titles must be between 1 and 16 characters (inclusive)\n      - No special characters outside of the following languages: English, French, Italian, German,\n        Spanish, Portuguese, Swedish, Russian\n    "
    icon_id: global___EnumPresetIcon.ValueType
    "*\n    Preset Icon ID\n\n    The range of acceptable custom icon ID's can be found in the initial @ref NotifyPresetStatus response to\n    @ref RequestGetPresetStatus\n    "

    def __init__(
        self,
        *,
        title_id: global___EnumPresetTitle.ValueType | None = ...,
        custom_name: builtins.str | None = ...,
        icon_id: global___EnumPresetIcon.ValueType | None = ...
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "custom_name",
            b"custom_name",
            "icon_id",
            b"icon_id",
            "title_id",
            b"title_id",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "custom_name",
            b"custom_name",
            "icon_id",
            b"icon_id",
            "title_id",
            b"title_id",
        ],
    ) -> None: ...

global___RequestCustomPresetUpdate = RequestCustomPresetUpdate

@typing_extensions.final
class PresetGroup(google.protobuf.message.Message):
    """
    Preset Group meta information and contained Presets
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    ID_FIELD_NUMBER: builtins.int
    PRESET_ARRAY_FIELD_NUMBER: builtins.int
    CAN_ADD_PRESET_FIELD_NUMBER: builtins.int
    ICON_FIELD_NUMBER: builtins.int
    MODE_ARRAY_FIELD_NUMBER: builtins.int
    id: global___EnumPresetGroup.ValueType
    "Preset Group ID"

    @property
    def preset_array(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Preset]:
        """Array of Presets contained in this Preset Group"""
    can_add_preset: builtins.bool
    "Is there room in the group to add additional Presets?"
    icon: global___EnumPresetGroupIcon.ValueType
    "The icon to display for this preset group"

    @property
    def mode_array(
        self,
    ) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___EnumFlatMode.ValueType]:
        """A list of flatmodes available for this preset group"""
    def __init__(
        self,
        *,
        id: global___EnumPresetGroup.ValueType | None = ...,
        preset_array: collections.abc.Iterable[global___Preset] | None = ...,
        can_add_preset: builtins.bool | None = ...,
        icon: global___EnumPresetGroupIcon.ValueType | None = ...,
        mode_array: (collections.abc.Iterable[global___EnumFlatMode.ValueType] | None) = ...
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal["can_add_preset", b"can_add_preset", "icon", b"icon", "id", b"id"],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "can_add_preset",
            b"can_add_preset",
            "icon",
            b"icon",
            "id",
            b"id",
            "mode_array",
            b"mode_array",
            "preset_array",
            b"preset_array",
        ],
    ) -> None: ...

global___PresetGroup = PresetGroup

@typing_extensions.final
class PresetSetting(google.protobuf.message.Message):
    """*
    Setting representation that comprises a  @ref Preset
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    ID_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    IS_CAPTION_FIELD_NUMBER: builtins.int
    id: builtins.int
    "Setting ID"
    value: builtins.int
    "Setting value"
    is_caption: builtins.bool
    'Does this setting appear on the Preset "pill" in the camera UI?'

    def __init__(
        self, *, id: builtins.int | None = ..., value: builtins.int | None = ..., is_caption: builtins.bool | None = ...
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal["id", b"id", "is_caption", b"is_caption", "value", b"value"],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal["id", b"id", "is_caption", b"is_caption", "value", b"value"],
    ) -> None: ...

global___PresetSetting = PresetSetting

================
File: demos/python/sdk_wireless_camera_control/open_gopro/proto/request_get_preset_status_pb2.py
================
# request_get_preset_status_pb2.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Mon Sep  9 19:50:27 UTC 2024

"""Generated protocol buffer code."""

from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder

_sym_db = _symbol_database.Default()
DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(
    b'\n\x1frequest_get_preset_status.proto\x12\nopen_gopro"\xa6\x01\n\x16RequestGetPresetStatus\x12D\n\x16register_preset_status\x18\x01 \x03(\x0e2$.open_gopro.EnumRegisterPresetStatus\x12F\n\x18unregister_preset_status\x18\x02 \x03(\x0e2$.open_gopro.EnumRegisterPresetStatus*l\n\x18EnumRegisterPresetStatus\x12!\n\x1dREGISTER_PRESET_STATUS_PRESET\x10\x01\x12-\n)REGISTER_PRESET_STATUS_PRESET_GROUP_ARRAY\x10\x02'
)
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, globals())
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, "request_get_preset_status_pb2", globals())
if _descriptor._USE_C_DESCRIPTORS == False:
    DESCRIPTOR._options = None
    _ENUMREGISTERPRESETSTATUS._serialized_start = 216
    _ENUMREGISTERPRESETSTATUS._serialized_end = 324
    _REQUESTGETPRESETSTATUS._serialized_start = 48
    _REQUESTGETPRESETSTATUS._serialized_end = 214

================
File: demos/python/sdk_wireless_camera_control/open_gopro/proto/request_get_preset_status_pb2.pyi
================
"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
*
Defines the structure of protobuf messages for obtaining preset status
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _EnumRegisterPresetStatus:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EnumRegisterPresetStatusEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnumRegisterPresetStatus.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    REGISTER_PRESET_STATUS_PRESET: _EnumRegisterPresetStatus.ValueType
    "Send notification when properties of a preset change"
    REGISTER_PRESET_STATUS_PRESET_GROUP_ARRAY: _EnumRegisterPresetStatus.ValueType
    "Send notification when properties of a preset group change"

class EnumRegisterPresetStatus(_EnumRegisterPresetStatus, metaclass=_EnumRegisterPresetStatusEnumTypeWrapper): ...

REGISTER_PRESET_STATUS_PRESET: EnumRegisterPresetStatus.ValueType
"Send notification when properties of a preset change"
REGISTER_PRESET_STATUS_PRESET_GROUP_ARRAY: EnumRegisterPresetStatus.ValueType
"Send notification when properties of a preset group change"
global___EnumRegisterPresetStatus = EnumRegisterPresetStatus

@typing_extensions.final
class RequestGetPresetStatus(google.protobuf.message.Message):
    """*
    Get the set of currently available presets and optionally register to be notified when it changes.

    Response: @ref NotifyPresetStatus sent immediately

    Notification: @ref NotifyPresetStatus sent periodically as preset status changes, if registered.

    The preset status changes when:

    - A client changes one of a preset's captioned settings via the API
    - The user exits from a preset's settings UI on the camera (e.g. long-press the preset pill and then press the back arrow)
    - The user creates/deletes/reorders a preset within a group
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    REGISTER_PRESET_STATUS_FIELD_NUMBER: builtins.int
    UNREGISTER_PRESET_STATUS_FIELD_NUMBER: builtins.int

    @property
    def register_preset_status(
        self,
    ) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___EnumRegisterPresetStatus.ValueType]:
        """Array of Preset statuses to be notified about"""
    @property
    def unregister_preset_status(
        self,
    ) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___EnumRegisterPresetStatus.ValueType]:
        """Array of Preset statuses to stop being notified about"""
    def __init__(
        self,
        *,
        register_preset_status: (collections.abc.Iterable[global___EnumRegisterPresetStatus.ValueType] | None) = ...,
        unregister_preset_status: (collections.abc.Iterable[global___EnumRegisterPresetStatus.ValueType] | None) = ...
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "register_preset_status",
            b"register_preset_status",
            "unregister_preset_status",
            b"unregister_preset_status",
        ],
    ) -> None: ...

global___RequestGetPresetStatus = RequestGetPresetStatus

================
File: demos/python/sdk_wireless_camera_control/open_gopro/proto/response_generic_pb2.py
================
# response_generic_pb2.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Mon Sep  9 19:50:27 UTC 2024

"""Generated protocol buffer code."""

from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder

_sym_db = _symbol_database.Default()
DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(
    b'\n\x16response_generic.proto\x12\nopen_gopro"@\n\x0fResponseGeneric\x12-\n\x06result\x18\x01 \x02(\x0e2\x1d.open_gopro.EnumResultGeneric"%\n\x05Media\x12\x0e\n\x06folder\x18\x01 \x01(\t\x12\x0c\n\x04file\x18\x02 \x01(\t*\xcf\x01\n\x11EnumResultGeneric\x12\x12\n\x0eRESULT_UNKNOWN\x10\x00\x12\x12\n\x0eRESULT_SUCCESS\x10\x01\x12\x15\n\x11RESULT_ILL_FORMED\x10\x02\x12\x18\n\x14RESULT_NOT_SUPPORTED\x10\x03\x12!\n\x1dRESULT_ARGUMENT_OUT_OF_BOUNDS\x10\x04\x12\x1b\n\x17RESULT_ARGUMENT_INVALID\x10\x05\x12!\n\x1dRESULT_RESOURCE_NOT_AVAILABLE\x10\x06'
)
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, globals())
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, "response_generic_pb2", globals())
if _descriptor._USE_C_DESCRIPTORS == False:
    DESCRIPTOR._options = None
    _ENUMRESULTGENERIC._serialized_start = 144
    _ENUMRESULTGENERIC._serialized_end = 351
    _RESPONSEGENERIC._serialized_start = 38
    _RESPONSEGENERIC._serialized_end = 102
    _MEDIA._serialized_start = 104
    _MEDIA._serialized_end = 141

================
File: demos/python/sdk_wireless_camera_control/open_gopro/proto/response_generic_pb2.pyi
================
"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
*
Defines the structure of protobuf message containing generic response to a command
"""

import builtins
import google.protobuf.descriptor
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _EnumResultGeneric:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EnumResultGenericEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnumResultGeneric.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    RESULT_UNKNOWN: _EnumResultGeneric.ValueType
    RESULT_SUCCESS: _EnumResultGeneric.ValueType
    RESULT_ILL_FORMED: _EnumResultGeneric.ValueType
    RESULT_NOT_SUPPORTED: _EnumResultGeneric.ValueType
    RESULT_ARGUMENT_OUT_OF_BOUNDS: _EnumResultGeneric.ValueType
    RESULT_ARGUMENT_INVALID: _EnumResultGeneric.ValueType
    RESULT_RESOURCE_NOT_AVAILABLE: _EnumResultGeneric.ValueType

class EnumResultGeneric(_EnumResultGeneric, metaclass=_EnumResultGenericEnumTypeWrapper): ...

RESULT_UNKNOWN: EnumResultGeneric.ValueType
RESULT_SUCCESS: EnumResultGeneric.ValueType
RESULT_ILL_FORMED: EnumResultGeneric.ValueType
RESULT_NOT_SUPPORTED: EnumResultGeneric.ValueType
RESULT_ARGUMENT_OUT_OF_BOUNDS: EnumResultGeneric.ValueType
RESULT_ARGUMENT_INVALID: EnumResultGeneric.ValueType
RESULT_RESOURCE_NOT_AVAILABLE: EnumResultGeneric.ValueType
global___EnumResultGeneric = EnumResultGeneric

@typing_extensions.final
class ResponseGeneric(google.protobuf.message.Message):
    """
    Generic Response used across many response / notification messages
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    RESULT_FIELD_NUMBER: builtins.int
    result: global___EnumResultGeneric.ValueType
    "Generic pass/fail/error info"

    def __init__(self, *, result: global___EnumResultGeneric.ValueType | None = ...) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["result", b"result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["result", b"result"]) -> None: ...

global___ResponseGeneric = ResponseGeneric

@typing_extensions.final
class Media(google.protobuf.message.Message):
    """*
    A common model to represent a media file
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    FOLDER_FIELD_NUMBER: builtins.int
    FILE_FIELD_NUMBER: builtins.int
    folder: builtins.str
    "Directory in which the media is contained"
    file: builtins.str
    "Filename of media"

    def __init__(self, *, folder: builtins.str | None = ..., file: builtins.str | None = ...) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal["file", b"file", "folder", b"folder"],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal["file", b"file", "folder", b"folder"],
    ) -> None: ...

global___Media = Media

================
File: demos/python/sdk_wireless_camera_control/open_gopro/proto/set_camera_control_status_pb2.py
================
# set_camera_control_status_pb2.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Mon Sep  9 19:50:27 UTC 2024

"""Generated protocol buffer code."""

from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder

_sym_db = _symbol_database.Default()
DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(
    b'\n\x1fset_camera_control_status.proto\x12\nopen_gopro"c\n\x1dRequestSetCameraControlStatus\x12B\n\x15camera_control_status\x18\x01 \x02(\x0e2#.open_gopro.EnumCameraControlStatus*q\n\x17EnumCameraControlStatus\x12\x0f\n\x0bCAMERA_IDLE\x10\x00\x12\x12\n\x0eCAMERA_CONTROL\x10\x01\x12\x1b\n\x17CAMERA_EXTERNAL_CONTROL\x10\x02\x12\x14\n\x10CAMERA_COF_SETUP\x10\x03'
)
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, globals())
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, "set_camera_control_status_pb2", globals())
if _descriptor._USE_C_DESCRIPTORS == False:
    DESCRIPTOR._options = None
    _ENUMCAMERACONTROLSTATUS._serialized_start = 148
    _ENUMCAMERACONTROLSTATUS._serialized_end = 261
    _REQUESTSETCAMERACONTROLSTATUS._serialized_start = 47
    _REQUESTSETCAMERACONTROLSTATUS._serialized_end = 146

================
File: demos/python/sdk_wireless_camera_control/open_gopro/proto/set_camera_control_status_pb2.pyi
================
"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
*
Defines the structure of protobuf messages for setting camera control status
"""

import builtins
import google.protobuf.descriptor
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _EnumCameraControlStatus:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EnumCameraControlStatusEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnumCameraControlStatus.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    CAMERA_IDLE: _EnumCameraControlStatus.ValueType
    CAMERA_CONTROL: _EnumCameraControlStatus.ValueType
    "Can only be set by camera, not by app or third party"
    CAMERA_EXTERNAL_CONTROL: _EnumCameraControlStatus.ValueType
    CAMERA_COF_SETUP: _EnumCameraControlStatus.ValueType
    "Set by the camera when it is on the CAH (Camera As a Hub) / COF (Cloud OFfload) setup screen"

class EnumCameraControlStatus(_EnumCameraControlStatus, metaclass=_EnumCameraControlStatusEnumTypeWrapper): ...

CAMERA_IDLE: EnumCameraControlStatus.ValueType
CAMERA_CONTROL: EnumCameraControlStatus.ValueType
"Can only be set by camera, not by app or third party"
CAMERA_EXTERNAL_CONTROL: EnumCameraControlStatus.ValueType
CAMERA_COF_SETUP: EnumCameraControlStatus.ValueType
"Set by the camera when it is on the CAH (Camera As a Hub) / COF (Cloud OFfload) setup screen"
global___EnumCameraControlStatus = EnumCameraControlStatus

@typing_extensions.final
class RequestSetCameraControlStatus(google.protobuf.message.Message):
    """*
    Set Camera Control Status (as part of Global Behaviors feature)

    This command is used to tell the camera that the app (i.e. External Control) wishes to claim control of the camera.
    This causes the camera to immediately exit most contextual menus and return to the idle screen. Any interaction with
    the camera's physical buttons will cause the camera to reclaim control and update control status accordingly. If the
    user returns the camera UI to the idle screen, the camera updates control status to Idle.

    The entity currently claiming control of the camera is advertised in camera status 114. Information about whether the
    camera is in a contextual menu or not is advertised in camera status 63.

    Response: @ref ResponseGeneric
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    CAMERA_CONTROL_STATUS_FIELD_NUMBER: builtins.int
    camera_control_status: global___EnumCameraControlStatus.ValueType
    "Declare who is taking control of the camera"

    def __init__(self, *, camera_control_status: global___EnumCameraControlStatus.ValueType | None = ...) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal["camera_control_status", b"camera_control_status"],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal["camera_control_status", b"camera_control_status"],
    ) -> None: ...

global___RequestSetCameraControlStatus = RequestSetCameraControlStatus

================
File: demos/python/sdk_wireless_camera_control/open_gopro/proto/turbo_transfer_pb2.py
================
# turbo_transfer_pb2.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Mon Sep  9 19:50:27 UTC 2024

"""Generated protocol buffer code."""

from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder

_sym_db = _symbol_database.Default()
DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(
    b"\n\x14turbo_transfer.proto\x12\nopen_gopro\"'\n\x15RequestSetTurboActive\x12\x0e\n\x06active\x18\x01 \x02(\x08"
)
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, globals())
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, "turbo_transfer_pb2", globals())
if _descriptor._USE_C_DESCRIPTORS == False:
    DESCRIPTOR._options = None
    _REQUESTSETTURBOACTIVE._serialized_start = 36
    _REQUESTSETTURBOACTIVE._serialized_end = 75

================
File: demos/python/sdk_wireless_camera_control/open_gopro/proto/turbo_transfer_pb2.pyi
================
"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
*
Defines the structure of protobuf messages for enabling and disabling Turbo Transfer feature
"""

import builtins
import google.protobuf.descriptor
import google.protobuf.message
import sys

if sys.version_info >= (3, 8):
    import typing as typing_extensions
else:
    import typing_extensions
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class RequestSetTurboActive(google.protobuf.message.Message):
    """*
    Enable/disable display of "Transferring Media" UI

    Response: @ref ResponseGeneric
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    ACTIVE_FIELD_NUMBER: builtins.int
    active: builtins.bool
    "Enable or disable Turbo Transfer feature"

    def __init__(self, *, active: builtins.bool | None = ...) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["active", b"active"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["active", b"active"]) -> None: ...

global___RequestSetTurboActive = RequestSetTurboActive

================
File: demos/python/sdk_wireless_camera_control/open_gopro/wifi/adapters/__init__.py
================
# __init__.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Tue Sep  7 21:35:53 UTC 2021

"""Universal WiFi adapter implementation for Open GoPro WiFi interface"""

from .wireless import WifiCli

================
File: demos/python/sdk_wireless_camera_control/open_gopro/wifi/adapters/wireless.py
================
# wifi_controller.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Wed, Sep  1, 2021  5:05:51 PM

"""Manage a WiFI connection using native OS commands."""

from __future__ import annotations

import ctypes
import html
import locale
import logging
import os
import platform
import re
import tempfile
import time
from enum import Enum, auto
from getpass import getpass
from shutil import which
from typing import Any, Callable, Optional

import wrapt
from packaging.version import Version

from open_gopro.util import cmd
from open_gopro.wifi import SsidState, WifiController

logger = logging.getLogger(__name__)


def ensure_us_english() -> None:
    """Validate the system language is US English for CLI response parsing

    From https://stackoverflow.com/questions/3425294/how-to-detect-the-os-default-language-in-python

    Raises:
        RuntimeError: The system is using any language other then en_US
    """
    if platform.system().lower() == "windows":
        windll = getattr(ctypes, "windll").kernel32
        language = locale.windows_locale[windll.GetUserDefaultUILanguage()]
    else:
        language = os.environ["LANG"]

    if not language.startswith("en_US"):
        raise RuntimeError(
            f"The Wifi driver parses CLI responses and only supports en_US where your language is {language}"
        )


@wrapt.decorator
def pass_through_to_driver(wrapped: Callable, instance: WifiCli, args: Any, kwargs: Any) -> Any:
    """Call this same method on the _driver attribute

    Args:
        wrapped (Callable): method to call
        instance (WifiCli): instance to use to find driver
        args (Any): positional arguments
        kwargs (Any): keyword arguments

    Returns:
        Any: result after pass through to driver
    """
    driver_method = getattr(instance._driver, wrapped.__name__)
    return driver_method(*args, **kwargs)


class WifiCli(WifiController):
    """Top level abstraction of different Wifi drivers.

    If interface is not specified (i.e. it is None), we will attempt to automatically
    discover a suitable interface

    This will raise a RunTimeError if either:
        - The system is using any language other then en_US
        - We weren't able to find a suitable driver or auto-detect an interface after detecting driver

    Args:
        interface (str | None): Interface. Defaults to None.
        password (str | None): User Password for sudo. Defaults to None.
    """

    def __init__(self, interface: str | None = None, password: str | None = None) -> None:  # noqa: DOC502
        ensure_us_english()
        WifiController.__init__(self, interface, password)

        # detect and init appropriate driver
        self._driver = self._detect_driver()

        # Attempt to set interface (will raise an exception if not able to auto-detect)
        self.interface = interface  # type: ignore

        logger.debug(f"Wifi setup. Using {self}")

    def __str__(self) -> str:
        return f"[{type(self).__name__}] driver::[{self.interface}] interface"

    def _detect_driver(self) -> WifiController:
        """Try to find and instantiate a Wifi driver that can be used.

        Raises:
            RuntimeError: We weren't able to find a suitable driver
            RuntimeError: We weren't able to auto-detect an interface after detecting driver

        Returns:
            WifiController: [description]
        """
        # Try netsh (Windows).
        if os.name == "nt" and which("netsh"):
            return NetshWireless()

        # try networksetup (Mac OS 10.10)
        if which("networksetup"):
            return NetworksetupWireless()

        # Try Linux options.
        # try nmcli (Ubuntu 14.04). Allow for use in Snap Package
        if which("nmcli") or which("nmcli", path="/snap/bin/"):

            ctrl_wifi = cmd("nmcli general permissions |grep enable-disable-wifi")
            scan_wifi = cmd("nmcli general permissions |grep scan")

            if not "yes" in ctrl_wifi or not "yes" in scan_wifi:
                self._sudo_from_stdin()

            version = cmd("nmcli --version").split()[-1]
            # On RHEL based systems, the version is in the form of 1.44.2-1.fc39
            # wich raises an error when trying to compare it with the Version class
            if any(c.isalpha() for c in version):
                version = version.split("-")[0]
            return (
                Nmcli0990Wireless(password=self._password)
                if Version(version) >= Version("0.9.9.0")
                else NmcliWireless(password=self._password)
            )
        # try nmcli (Ubuntu w/o network-manager)
        if which("wpa_supplicant"):
            self._sudo_from_stdin()
            return WpasupplicantWireless(password=self._password)

        raise RuntimeError("Unable to find compatible wireless driver.")

    def _sudo_from_stdin(self) -> str:
        """Ask for sudo password input from stdin

        This method prompts the user to enter the sudo password from the command line.
        It validates the password by running a command with sudo and checking if the password is valid.

        Returns:
            str: The entered sudo password.

        Raises:
            RuntimeError: If the password is empty or invalid.
        """
        # Need password for sudo
        if not self._password:
            self._password = getpass("Need to run as sudo. Enter password: ")
        if not self._password:
            raise RuntimeError("Can't use sudo with empty password.")
        # Validate password
        if "VALID PASSWORD" not in cmd(f'echo "{self._password}" | sudo -S echo "VALID PASSWORD"'):
            raise RuntimeError("Invalid password")

        return self._password

    @pass_through_to_driver
    def connect(self, ssid: str, password: str, timeout: float = 15) -> bool:  # type: ignore
        """Connect to a network.

        # noqa: DAR202

        Args:
            ssid (str): SSID of network to connect to
            password (str): password of network to connect to
            timeout (float): Time before considering connection failed (in seconds). Defaults to 15.

        Returns:
            bool: True if successful, False otherwise
        """

    @pass_through_to_driver
    def disconnect(self) -> bool:  # type: ignore
        """Disconnect from a network.

        # noqa: DAR202

        Returns:
            bool: True if successful, False otherwise
        """

    @pass_through_to_driver
    def current(self) -> tuple[Optional[str], SsidState]:  # type: ignore
        """Return the SSID and state of the current network.

        # noqa: DAR202

        Returns:
            tuple[Optional[str], SsidState]: Tuple of SSID str and state. If SSID is None,
            there is no current connection.
        """

    @pass_through_to_driver
    def available_interfaces(self) -> list[str]:  # type: ignore
        """Return a list of the available Wifi interfaces

        # noqa: DAR202

        Returns:
            list[str]: list of available interfaces
        """

    @pass_through_to_driver
    def power(self, power: bool) -> bool:  # type: ignore
        """Enable / disable the wireless driver.

        # noqa: DAR202

        Args:
            power (bool): Enable if True. Disable if False.

        Returns:
            bool: True if successful, False otherwise
        """

    @property
    def interface(self) -> str:
        """Get the Wifi Interface

        Returns:
            str: interface
        """
        return self._driver.interface

    @interface.setter
    def interface(self, interface: Optional[str]) -> None:
        """Set the Wifi interface.

        If None is passed, interface will attempt to be auto-detected

        Args:
            interface (Optional[str]): interface (or None)
        """
        self._driver.interface = interface  # type: ignore

    @property
    def is_on(self) -> bool:
        """Is the wireless driver currently enabled.

        Returns:
            bool: True if yes. False if no.
        """
        return self._driver.is_on


class NmcliWireless(WifiController):
    """Linux nmcli Driver < 0.9.9.0."""

    def __init__(self, password: str | None, interface: Optional[str] = None) -> None:
        WifiController.__init__(self, interface=interface, password=password)

    def _clean(self, partial: str) -> None:
        """Clean up connections.

        This is needed to prevent the following error after extended use:
        'maximum number of pending replies per connection has been reached'

        Args:
            partial (str): part of the connection name
        """
        # list matching connections
        response = cmd(f'{self.sudo} nmcli --fields BleUUID,NAME con list | grep "{partial}"')

        # delete all of the matching connections
        for line in response.splitlines():
            if len(line) > 0:
                cmd(f"{self.sudo} nmcli con delete uuid {line.split()[0]}")

    @staticmethod
    def _error_in_response(response: str) -> bool:
        """Ignore warnings in nmcli output.

        Sometimes there are warnings but we connected just fine

        Args:
            response (str): output to parse

        Returns:
            bool: True if errors found. False if not.
        """
        # no error if no response
        if len(response) == 0:
            return False

        # loop through each line
        for line in response.splitlines():
            # all error lines start with 'Error'
            if line.startswith("Error"):
                return True

        # if we didn't find an error then we are in the clear
        return False

    def connect(self, ssid: str, password: str, timeout: float = 15) -> bool:
        """Connect to WiFi SSID.

        Args:
            ssid (str): network SSID
            password (str): network password
            timeout (float): Time before considering connection failed (in seconds). Defaults to 15.

        Returns:
            bool: [description]
        """
        # clean up previous connection
        current, _ = self.current()
        if current is not None:
            self._clean(current)

        # First scan to ensure our network is there
        logger.info(f"Scanning for {ssid}...")
        cmd(f"{self.sudo} nmcli device wifi rescan")

        start = time.time()
        discovered = False
        while not discovered and (time.time() - start) <= timeout:
            # Scan for network
            response = cmd(f"{self.sudo} nmcli -f SSID device wifi list")
            for result in response.splitlines()[1:]:  # Skip title row
                if result.strip() == ssid.strip():
                    discovered = True
                    break
            if discovered:
                break
            time.sleep(1)
        else:
            logger.warning("Wifi Scan timed out")
            return False

        # attempt to connect
        logger.info(f"Connecting to {ssid}...")
        response = cmd(f'{self.sudo} nmcli dev wifi connect "{ssid}" password "{password}" iface "{self.interface}"')

        # parse response
        return not self._error_in_response(response)

    def disconnect(self) -> bool:
        """[summary].

        Returns:
            bool: [description]
        """
        return False

    def current(self) -> tuple[Optional[str], SsidState]:
        """[summary].

        Returns:
            tuple[Optional[str], SsidState]: [description]
        """
        # list active connections for all interfaces
        response = cmd(f'{self.sudo} nmcli con status | grep "{self.interface}"')

        # the current network is in the first column
        for line in response.splitlines():
            if len(line) > 0:
                return (line.split()[0], SsidState.CONNECTED)

        # return none if there was not an active connection
        return (None, SsidState.DISCONNECTED)

    def available_interfaces(self) -> list[str]:
        """Return a list of available Wifi Interface strings

        Returns:
            list[str]: list of interfaces
        """
        # grab list of interfaces
        response = cmd(f"{self.sudo} nmcli dev")

        # parse response
        interfaces = []
        for line in response.splitlines():
            if "wireless" in line:
                # this line has our interface name in the first column
                interfaces.append(line.split()[0])

        # return list
        return interfaces

    @property
    def is_on(self) -> bool:
        """[summary].

        Returns:
            bool: [description]
        """
        return "enabled" in cmd(f"{self.sudo} nmcli nm wifi")

    def power(self, power: bool) -> bool:
        """Enable or disbale the Wifi controller

        Args:
            power (bool): True to enable, False to Disable

        Returns:
            bool: True if success, False otherwise
        """
        if power:
            cmd(f"{self.sudo} nmcli nm wifi on")
        else:
            cmd(f"{self.sudo} nmcli nm wifi off")

        return True


class Nmcli0990Wireless(WifiController):
    """Linux nmcli Driver >= 0.9.9.0."""

    def __init__(self, password: str | None, interface: Optional[str] = None) -> None:
        WifiController.__init__(self, interface=interface, password=password)

    def _clean(self, partial: str) -> None:
        """Clean up connections.

        This is needed to prevent the following error after extended use:
        'maximum number of pending replies per connection has been reached'

        Args:
            partial (str): part of the connection name
        """
        # list matching connections
        response = cmd(f'{self.sudo} nmcli --fields UUID,NAME con show | grep "{partial}"')

        # delete all of the matching connections
        for line in response.splitlines():
            if len(line) > 0:
                uuid = line.split()[0]
                cmd(f"{self.sudo} nmcli con delete uuid {uuid}")

    @staticmethod
    def _error_in_response(response: str) -> bool:
        """Ignore warnings in nmcli output.

        Sometimes there are warnings but we connected just fine

        Args:
            response (str): output to parse

        Returns:
            bool: True if errors found. False if not.
        """
        # no error if no response
        if len(response) == 0:
            return False

        # loop through each line
        for line in response.splitlines():
            # all error lines start with 'Error'
            if line.startswith("Error"):
                logger.error("line")
                return True

        # if we didn't find an error then we are in the clear
        return False

    def connect(self, ssid: str, password: str, timeout: float = 15) -> bool:
        """Connect to Wifi SSID.

        Args:
            ssid (str): network SSID
            password (str): network password
            timeout (float): Time before considering connection failed (in seconds). Defaults to 15.

        Returns:
            bool: True if connection suceeded, False otherwise
        """
        # First scan to ensure our network is there
        logger.info(f"Scanning for {ssid}...")
        start = time.time()
        discovered = False
        while not discovered and (time.time() - start) <= timeout:
            # Scan for network
            cmd(f"{self.sudo} nmcli device wifi rescan")
            response = cmd(f"{self.sudo} nmcli -f SSID device wifi list")
            for result in response.splitlines()[1:]:  # Skip title row
                if result.strip() == ssid.strip():
                    discovered = True
                    break
            if discovered:
                break
            time.sleep(1)
        else:
            logger.warning("Wifi Scan timed out")
            return False

        # attempt to connect
        logger.info(f"Connecting to {ssid}...")
        response = cmd(f'{self.sudo} nmcli dev wifi connect "{ssid}" password "{password}" ifname "{self.interface}"')

        # parse response
        return not self._error_in_response(response)

    def disconnect(self) -> bool:
        """[summary].

        Returns:
            bool: [description]
        """
        return False

    def current(self) -> tuple[Optional[str], SsidState]:
        """[summary].

        Returns:
            tuple[Optional[str], SsidState]: [description]
        """
        # list active connections for all interfaces
        response = cmd(f'{self.sudo} nmcli con | grep "{self.interface}"')

        # the current network is in the first column
        for line in response.splitlines():
            if len(line) > 0:
                return (line.split()[0], SsidState.CONNECTED)

        # return none if there was not an active connection
        return (None, SsidState.DISCONNECTED)

    def available_interfaces(self) -> list[str]:
        """Return a list of available Wifi Interface strings

        Returns:
            list[str]: list of interfaces
        """
        # grab list of interfaces
        response = cmd(f"{self.sudo} nmcli dev")

        # parse response
        interfaces = []
        for line in response.splitlines():
            if "wifi" in line:
                # this line has our interface name in the first column
                interfaces.append(line.split()[0])

        # return list
        return interfaces

    @property
    def is_on(self) -> bool:
        """[summary].

        Returns:
            bool: [description]
        """
        return "enabled" in cmd(f"{self.sudo} nmcli r wifi")

    def power(self, power: bool) -> bool:
        """Enable or disbale the Wifi controller

        Args:
            power (bool): True to enable, False to Disable

        Returns:
            bool: True if success, False otherwise
        """
        if power:
            cmd(f"{self.sudo} nmcli r wifi on")
        else:
            cmd(f"{self.sudo} nmcli r wifi off")

        return True


class WpasupplicantWireless(WifiController):
    """Linux wpa_supplicant Driver."""

    _file = "/tmp/wpa_supplicant.conf"

    def __init__(self, password: str | None, interface: Optional[str] = None) -> None:
        WifiController.__init__(self, interface=interface, password=password)

    def connect(self, ssid: str, password: str, timeout: float = 15) -> bool:
        """[summary].

        Args:
            ssid (str): network SSID
            password (str): network password
            timeout (float): Time before considering connection failed (in seconds). Defaults to 15.

        Returns:
            bool: [description]
        """
        # attempt to stop any active wpa_supplicant instances
        # ideally we do this just for the interface we care about
        cmd(f"{self.sudo} killall wpa_supplicant")

        # don't do DHCP for GoPros; can cause dropouts with the server
        cmd(f'{self.sudo} ifconfig "{self.interface}" 10.5.5.10/24 up')

        # create configuration file
        with open(self._file, "w") as fp:
            fp.write(f'network={{\n    ssid="{ssid}"\n    psk="{password}"\n}}\n')
            fp.close()

        # attempt to connect
        cmd(f'{self.sudo} wpa_supplicant -i"{self.interface}" -c"{self._file}" -B')

        # check that the connection was successful
        # i've never seen it take more than 3 seconds for the link to establish
        time.sleep(5)
        current_ssid, _ = self.current()
        if current_ssid != ssid:
            return False

        # attempt to grab an IP
        # better hope we are connected because the timeout here is really long
        # cmd(f"{self.sudo} dhclient {self.interface}"")

        # parse response
        return True

    def disconnect(self) -> bool:
        """[summary].

        Returns:
            bool: [description]
        """
        return False

    def current(self) -> tuple[Optional[str], SsidState]:
        """[summary].

        Returns:
            tuple[Optional[str], SsidState]: [description]
        """
        # get interface status
        response = cmd(f'{self.sudo} iwconfig "{self.interface}"')

        # the current network is on the first line like ESSID:"network"
        line = response.splitlines()[0]
        line = line.replace('"', "")
        parts = line.split("ESSID:")
        if len(parts) > 1:
            network = parts[1].strip()
            if network != "off/any":
                return (network, SsidState.CONNECTED)

        # return none if there was not an active connection
        return (None, SsidState.DISCONNECTED)

    def available_interfaces(self) -> list[str]:
        """Return a list of available Wifi Interface strings

        Returns:
            list[str]: list of interfaces
        """
        # grab list of interfaces
        response = cmd(f"{self.sudo} iwconfig")

        # parse response
        interfaces = []
        for line in response.splitlines():
            if len(line) > 0 and not line.startswith(" "):
                # this line contains an interface name!
                if "no wireless extensions" not in line:
                    # this is a wireless interface
                    interfaces.append(line.split()[0])
        return interfaces

    @property
    def is_on(self) -> bool:
        """[summary].

        Returns:
            bool: [description]
        """
        return "enabled" in cmd(f"{self.sudo} nmcli r wifi")

    def power(self, power: bool) -> bool:
        """Enable or disable the Wifi controller

        Args:
            power (bool): True to enable, False to Disable

        Returns:
            bool: True if success, False otherwise
        """
        return False


class NetworksetupWireless(WifiController):
    """OS X networksetup Driver."""

    def __init__(self, interface: Optional[str] = None) -> None:
        WifiController.__init__(self, interface)

    def connect(self, ssid: str, password: str, timeout: float = 15) -> bool:
        """Connect to SSID.

        Args:
            ssid (str): network SSID
            password (str): network password
            timeout (float): Time before considering connection failed (in seconds). Defaults to 15.

        Returns:
            bool: [description]
        """
        # Escape single quotes
        ssid = ssid.replace(r"'", '''"'"''')

        logger.info(f"Scanning for {ssid}...")
        start = time.time()
        discovered = False
        while not discovered and (time.time() - start) <= timeout:
            # Scan for network
            response = cmd(r"/usr/sbin/system_profiler SPAirPortDataType")
            regex = re.compile(
                r"\n\s+([\x20-\x7E]{1,32}):\n\s+PHY Mode:"
            )  # 0x20...0x7E --> ASCII for printable characters
            if ssid in sorted(regex.findall(response)):
                break
            time.sleep(1)
        else:
            logger.warning("Wifi Scan timed out")
            return False

        # If we're already connected, return
        if self.current()[0] == ssid:
            return True

        # Connect now that we found the ssid
        logger.info(f"Connecting to {ssid}...")
        response = cmd(f"networksetup -setairportnetwork '{self.interface}' '{ssid}' '{password}'")

        if "not find" in response.lower():
            return False
        # Now wait for network to actually establish
        current = self.current()[0]
        logger.debug(f"current wifi: {current}")
        while current is not None and ssid not in current and timeout > 0:
            time.sleep(1)
            current = self.current()[0]
            logger.debug(f"current wifi: {current}")
            timeout -= 1
            if timeout == 0:
                return False

        # There is some delay required here, presumably because the network is not ready.
        time.sleep(5)

        return True

    def disconnect(self) -> bool:
        """[summary].

        Returns:
            bool: [description]
        """
        return False

    def current(self) -> tuple[Optional[str], SsidState]:
        """[summary].

        Returns:
            tuple[Optional[str], SsidState]: [description]
        """
        # attempt to get current network
        response = cmd(f"networksetup -getairportnetwork '{self.interface}'")

        # parse response
        phrase = "Current Wi-Fi Network: "
        if phrase in response:
            return (response.replace("Current Wi-Fi Network: ", "").strip(), SsidState.CONNECTED)
        return (None, SsidState.DISCONNECTED)

    def available_interfaces(self) -> list[str]:
        """Return a list of available Wifi Interface strings

        Returns:
            list[str]: list of interfaces
        """
        # grab list of interfaces
        response = cmd("networksetup -listallhardwareports")

        # parse response
        interfaces = []
        detected_wifi = False
        for line in response.splitlines():
            if detected_wifi:
                # this line has our interface name in it
                interfaces.append(line.replace("Device: ", ""))
                detected_wifi = False
            else:
                # search for the line that has 'Wi-Fi' in it
                if "Wi-Fi" in line:
                    detected_wifi = True

        # return list
        return interfaces

    @property
    def is_on(self) -> bool:
        """[summary].

        Returns:
            bool: [description]
        """
        return "On" in cmd(f"networksetup -getairportpower '{self.interface}'")

    def power(self, power: bool) -> bool:
        """Enable or disbale the Wifi controller

        Args:
            power (bool): True to enable, False to Disable

        Returns:
            bool: True if success, False otherwise
        """
        cmd(f"networksetup -setairportpower '{self.interface}' {'on' if power else 'off'}")

        return True


class NetshWireless(WifiController):
    """Windows Driver."""

    # Used to build profile
    template = r"""<?xml version="1.0"?>
<WLANProfile xmlns="http://www.microsoft.com/networking/WLAN/profile/v1">
    <name>{ssid}</name>
    <SSIDConfig>
        <SSID>
            <name>{ssid}</name>
        </SSID>
    </SSIDConfig>
    <connectionType>ESS</connectionType>
    <connectionMode>manual</connectionMode>
    <MSM>
        <security>
            <authEncryption>
                <authentication>{auth}</authentication>
                <encryption>{encrypt}</encryption>
                <useOneX>false</useOneX>
            </authEncryption>
            <sharedKey>
                <keyType>passPhrase</keyType>
                <protected>false</protected>
                <keyMaterial>{passwd}</keyMaterial>
            </sharedKey>
        </security>
    </MSM>
    <MacRandomization xmlns="http://www.microsoft.com/networking/WLAN/profile/v3">
        <enableRandomization>false</enableRandomization>
    </MacRandomization>
</WLANProfile>"""

    def __init__(self, interface: Optional[str] = None) -> None:
        WifiController.__init__(self, interface)
        self.ssid: Optional[str] = None

    def __del__(self) -> None:
        self._clean(self.ssid)

    def connect(self, ssid: str, password: str, timeout: float = 15) -> bool:
        """Establish a connection.

        This is blocking and won't return until either a connection is established or
        a 10 second timeout

        Args:
            ssid (str): SSID of network to connect to
            password (str): password of network to connect to
            timeout (float): Time before considering connection failed (in seconds). Defaults to 15.

        Raises:
            RuntimeError: Can not add profile or request to connect to SSID fails

        Returns:
            bool: True if connected, False otherwise
        """
        # Replace xml tokens (&, <, >, etc.)
        password = html.escape(password)
        ssid = html.escape(ssid)

        logger.info(f"Attempting to establish Wifi connection to {ssid}...")

        # Start fresh each time.
        self._clean(ssid)

        # Create new profile
        output = NetshWireless.template.format(ssid=ssid, auth="WPA2PSK", encrypt="AES", passwd=password)
        logger.debug(f"Using template {output}")
        # Need ugly low level mkstemp and os here because standard tempfile can't be accessed by a subprocess in Windows :(
        fd, filename = tempfile.mkstemp()
        os.write(fd, output.encode("utf-8"))
        os.close(fd)
        response = cmd(f"netsh wlan add profile filename={filename}")
        if "is added on interface" not in response:
            raise RuntimeError(response)
        os.remove(filename)

        for _ in range(5):
            # Try to connect
            response = cmd(f'netsh wlan connect ssid="{ssid}" name="{ssid}" interface="{self.interface}"')
            if "was completed successfully" not in response:
                raise RuntimeError(response)
            # Wait for connection to establish
            DELAY = 1
            while current := self.current():
                if current == (ssid, SsidState.CONNECTED):
                    logger.info("Wifi connection established!")
                    self.ssid = ssid
                    return True
                logger.debug(f"Waiting {DELAY} second for Wi-Fi connection to establish...")
                time.sleep(DELAY)
                timeout -= DELAY
                if timeout <= 0 or current[1] is SsidState.DISCONNECTED:
                    logger.debug("Wifi driver detected disconnect. Attempting retry...")
                    break

        return False

    def disconnect(self) -> bool:
        """Terminate the Wifi connection.

        Returns:
            bool: True if the disconnect was successful, False otherwise.
        """
        response = cmd(f'netsh wlan disconnect interface="{self.interface}"')

        return bool("completed successfully" in response.lower())

    def current(self) -> tuple[Optional[str], SsidState]:
        """Get the current network SSID and state.

        # Here is an example of what we are parsing (i.e. to find FunHouse SSID):
        # Name                   : Wi-Fi
        # Description            : TP-Link Wireless USB Adapter
        # GUID                   : 093d8022-33cb-4400-8362-275eaf24cb86
        # Physical address       : 98:48:27:88:cb:18
        # State                  : connected
        # SSID                   : FunHouse

        Returns:
            tuple[Optional[str], SsidState]: Tuple of (ssid, network_state)
        """

        class ParseState(Enum):
            """Current state of interface parsing"""

            PARSE_INTERFACE = auto()
            PARSE_SSID = auto()
            PARSE_STATE = auto()

        response = cmd("netsh wlan show interfaces")
        parse_state = ParseState.PARSE_INTERFACE
        ssid: Optional[str] = None
        network_state: Optional[str] = None
        for field in response.split("\r\n"):
            if parse_state is ParseState.PARSE_INTERFACE:
                if "Name" in field and self.interface in field:
                    parse_state = ParseState.PARSE_STATE
            elif parse_state is ParseState.PARSE_STATE:
                if "State" in field:
                    network_state = field.split(":")[1].strip().lower()
                    parse_state = ParseState.PARSE_SSID
            elif parse_state is ParseState.PARSE_SSID:
                if "SSID" in field:
                    ssid = field.split(":")[1].strip()
                    break

        if network_state == "connected":
            state = SsidState.CONNECTED
        elif network_state == "disconnected":
            state = SsidState.DISCONNECTED
        else:
            state = SsidState.ESTABLISHING
        return (ssid, state)

    def available_interfaces(self) -> list[str]:
        """Discover all available interfaces.

        # We're parsing, for example, the following line to find "Wi-Fi":
        # Name                   : Wi-Fi

        Returns:
            list[str]: List of interfaces
        """
        response = cmd("netsh wlan show interfaces")
        interfaces = []

        # Look behind to find field, then match (non-greedy) any chars until CRLF
        match = "(?<={}).+?(?=\\r\\n)"
        for interface in re.findall(match.format("Name"), response):
            # Strip leading whitespace and then the first two chars of remaining (i.e. " :")
            interfaces.append(interface.strip()[2:])

        return interfaces

    @property
    def is_on(self) -> bool:
        """Is Wifi enabled?

        For Windows, this means "Is there at least one Wifi interfaces available?"

        Returns:
            bool: True if yes, False if no.
        """
        response = cmd("netsh wlan show interfaces")
        # Is there at least one interfaces enabled?
        if "no wireless interface" in response.lower():
            return False
        return True

    def power(self, power: bool) -> bool:
        """Enable or disable the Wifi controller

        Args:
            power (bool): True to enable, False to Disable

        Returns:
            bool: True if success, False otherwise
        """
        arg = "enable" if power else "disable"
        response = cmd(f'netsh interface set interface "{self._interface}" "{arg}"')
        return "not exist" not in response

    @staticmethod
    def _clean(ssid: Optional[str]) -> None:
        """Disconnect and delete SSID profile.

        Args:
            ssid (Optional[str]): name of SSID
        """
        cmd("netsh wlan disconnect")
        if ssid is not None:
            cmd(f'netsh wlan delete profile name="{ssid}"')

================
File: demos/python/sdk_wireless_camera_control/open_gopro/wifi/__init__.py
================
# __init__.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Tue Sep  7 21:35:53 UTC 2021

"""Open GoPro WiFi Interface interface and implementation

isort:skip_file
"""

from .controller import SsidState, WifiController
from .client import WifiClient
from .adapters import WifiCli

================
File: demos/python/sdk_wireless_camera_control/open_gopro/wifi/client.py
================
# client.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Tue Sep  7 21:35:53 UTC 2021

"""Open GoPro WiFi Client Implementation"""

from __future__ import annotations

import logging
from typing import Optional

from open_gopro.exceptions import ConnectFailed

from .controller import SsidState, WifiController

logger = logging.getLogger(__name__)


class WifiClient:
    """A Wifi client that is composed of, among other things, a Wifi interface

    The interface is generic and can be set with the 'controller' argument

    Args:
        controller (WifiController): controller implementation to use for this client
    """

    def __init__(self, controller: WifiController) -> None:
        self._controller = controller
        self.ssid: Optional[str]
        self.password: Optional[str]

    def open(self, ssid: str, password: str, timeout: int = 15, retries: int = 5) -> None:
        """Open the WiFi client resource so that it is ready to send and receive data

        Args:
            ssid (str): [description]
            password (str): [description]
            timeout (int): [description]. Defaults to 15.
            retries (int): [description]. Defaults to 5.

        Raises:
            ConnectFailed: [description]
        """
        logger.info(f"Establishing Wifi connection to {ssid}")
        for _ in range(retries):
            if self._controller.connect(ssid, password, timeout):
                self.ssid = ssid
                self.password = password
                return
        raise ConnectFailed("Wifi failed to connect", timeout, retries)

    def close(self) -> None:
        """Close the client resource.

        This should always be called before exiting.
        """
        logger.info("Terminating the Wifi connection")
        self._controller.disconnect()

    @property
    def is_connected(self) -> bool:
        """Is the WiFi connection currently established?

        Returns:
            bool: True if yes, False if no
        """
        (ssid, state) = self._controller.current()
        return ssid is not None and state is SsidState.CONNECTED

================
File: demos/python/sdk_wireless_camera_control/open_gopro/wifi/controller.py
================
# controller.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Tue Sep  7 21:35:53 UTC 2021

"""Wifi Controller Interface Definition."""

from __future__ import annotations

import logging
from abc import ABC, abstractmethod
from enum import IntEnum, auto
from typing import Optional

from open_gopro.exceptions import InterfaceConfigFailure

logger = logging.getLogger(__name__)


class SsidState(IntEnum):
    """Current state of the SSID"""

    ESTABLISHING = auto()
    CONNECTED = auto()
    DISCONNECTED = auto()


class WifiController(ABC):
    """Interface definition for a Wifi driver to be used by GoPro.

    Args:
        interface (str | None): Wifi interface to use. Defaults to None (auto-detect).
        password (str | None): user password to use for sudo. Defaults to None.
    """

    def __init__(self, interface: str | None = None, password: str | None = None) -> None:
        self._target_interface = interface
        self._interface: str
        self._password = password

    @abstractmethod
    def connect(self, ssid: str, password: str, timeout: float = 15) -> bool:
        """Connect to a network.

        Args:
            ssid (str): SSID of network to connect to
            password (str): password of network to connect to
            timeout (float): Time before considering connection failed (in seconds). Defaults to 15.

        Returns:
            bool: True if successful, False otherwise
        """

    @abstractmethod
    def disconnect(self) -> bool:
        """Disconnect from a network.

        Returns:
            bool: True if successful, False otherwise
        """

    @abstractmethod
    def current(self) -> tuple[Optional[str], SsidState]:
        """Return the SSID and state of the current network.

        Returns:
            tuple[Optional[str], SsidState]: Tuple of SSID str and state. If SSID is None,
            there is no current connection.
        """

    @abstractmethod
    def available_interfaces(self) -> list[str]:
        """Return a list of available Wifi Interface strings

        Returns:
            list[str]: list of interfaces
        """

    @property
    def interface(self) -> str:
        """Get the Wifi Interface

        Returns:
            str: interface
        """
        return self._interface

    @interface.setter
    def interface(self, interface: Optional[str]) -> None:
        """Set the Wifi interface.

        If None is passed, interface will attempt to be auto-detected

        Args:
            interface (Optional[str]): interface (or None to auto-detect)

        Raises:
            InterfaceConfigFailure: Requested interface does not exist or not able to automatically detect
                any interfaces
        """
        detected_interfaces = self.available_interfaces()
        if interface:
            if interface in detected_interfaces:
                self._interface = interface
            else:
                raise InterfaceConfigFailure(
                    f"Requested WiFi interface [{interface}] not found among [{', '.join(detected_interfaces)}]"
                )
        else:
            if detected_interfaces:
                self._interface = detected_interfaces[0]
            else:
                raise InterfaceConfigFailure(
                    """
Can't auto-assign Wifi interface because no suitable interface was found.
Is there an available Wifi interface on this computer? To verify this, try:
    - MacOS: networksetup -listallhardwareports
    - Linux: nmcli dev
    - Windows: netsh wlan show interfaces"""
                )

    @abstractmethod
    def power(self, power: bool) -> bool:
        """Enable / disable the wireless driver.

        Args:
            power (bool): Enable if True. Disable if False.

        Returns:
            bool: was the power request successful?
        """

    @property
    @abstractmethod
    def is_on(self) -> bool:
        """Is the wireless driver currently enabled.

        Returns:
            bool: True if yes. False if no.
        """

    @property
    def sudo(self) -> str:
        """Return the sudo encapsulated password

        Returns:
            str: echo "**********" | sudo -S
        """
        if not self._password:
            return ""
        return f'echo "{self._password}" | sudo -S'

================
File: demos/python/sdk_wireless_camera_control/open_gopro/wifi/mdns_scanner.py
================
# mdns_scanner.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Tue Aug  8 18:10:56 UTC 2023

"""MDNS utility functions"""

from __future__ import annotations

import asyncio
import logging
from typing import Any

import zeroconf

# Imported this way for monkeypatching in pytest
import zeroconf.asyncio

from open_gopro import exceptions as GpException

logger = logging.getLogger(__name__)


class ZeroconfListener(zeroconf.ServiceListener):
    """Listens for mDNS services on the local system and save fully-formed ipaddr URLs"""

    def __init__(self) -> None:
        self.urls: asyncio.Queue[str] = asyncio.Queue()

    def add_service(self, zc: zeroconf.Zeroconf, type_: str, name: str) -> None:
        """Callback called by ServiceBrowser when a new service is discovered

        Args:
            zc (zeroconf.Zeroconf): instantiated zeroconf object that owns the search
            type_ (str): name of mDNS service that search is occurring on
            name (str): discovered device
        """
        logger.debug(f"Found MDNS service {name}")
        self.urls.put_nowait(name)

    def update_service(self, *_: Any) -> None:
        """Not used

        Args:
            *_ (Any): not used
        """

    def remove_service(self, *_: Any) -> None:
        """Not used

        Args:
            *_ (Any): not used
        """


async def find_first_ip_addr(service: str, timeout: int = 5) -> str:
    """Query the mDNS server to find a an IP address matching a service

    The first IP address matching the service will be returned

    Args:
        service (str): service name to scan for
        timeout (int): how long to search for before timing out in seconds

    Raises:
        FailedToFindDevice: search timed out

    Returns:
        str: First discovered IP address matching service
    """
    logger.info(f"Querying mDNS to find {service}...")
    listener = ZeroconfListener()
    with zeroconf.Zeroconf(unicast=True) as zc:
        zeroconf.asyncio.AsyncServiceBrowser(zc, service, listener)
        try:
            name = await asyncio.wait_for(listener.urls.get(), timeout)
            async with zeroconf.asyncio.AsyncZeroconf(unicast=True) as azc:
                if info := await azc.async_get_service_info(service, name):
                    ip_addr = info.parsed_addresses()[0]
                    return ip_addr
                raise GpException.FailedToFindDevice()
        except Exception as e:
            raise GpException.FailedToFindDevice() from e


async def get_all_services() -> list[str]:
    """Get all service names

    Returns:
        list[str]: list of service names
    """
    return list(await zeroconf.asyncio.AsyncZeroconfServiceTypes.async_find())

================
File: demos/python/sdk_wireless_camera_control/open_gopro/__init__.py
================
# __init__.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Wed, Sep  1, 2021  5:05:51 PM

# pylint: disable=wrong-import-position

"""All GoPro exports that the the user will want should be exported here."""

import sys

# Validate python version
# This is to make it painfully clear so that people hopefully stop trying invalid versions
if sys.version_info.major != 3 or not 9 <= sys.version_info.minor < 12:
    raise RuntimeError("Python >= 3.9 and < 3.12 must be used")

import logging

from open_gopro.logger import Logger

Logger.addLoggingLevel("TRACE", logging.DEBUG - 5)

from open_gopro.api import Params
from open_gopro.gopro_wired import WiredGoPro
from open_gopro.gopro_wireless import WirelessGoPro
from open_gopro.models import GoProResp

================
File: demos/python/sdk_wireless_camera_control/open_gopro/communicator_interface.py
================
# communication_client.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Tue Sep  7 21:35:53 UTC 2021

"""GoPro specific BLE client"""

from __future__ import annotations

import enum
import inspect
import logging
import re
from abc import ABC, abstractmethod
from pathlib import Path
from typing import Any, Generic, Iterator, Pattern, Protocol, TypeVar
from urllib.parse import urlencode

from construct import Bit, BitsInteger, BitStruct, Const, Construct, Padding

from open_gopro.ble import (
    BleClient,
    BLEController,
    BleDevice,
    BleHandle,
    BleUUID,
    DisconnectHandlerType,
    NotiHandlerType,
)
from open_gopro.constants import GoProUUIDs
from open_gopro.models.response import GoProResp, Header
from open_gopro.parser_interface import (
    BytesParser,
    BytesTransformer,
    GlobalParsers,
    JsonParser,
    JsonTransformer,
    Parser,
)
from open_gopro.types import IdType, JsonDict, UpdateCb, UpdateType
from open_gopro.wifi import WifiClient, WifiController

logger = logging.getLogger(__name__)


class MessageRules:
    """Message Rules Manager

    Args:
        fastpass_analyzer (Analyzer): Analyzer to decide if the message is fastpass. Defaults to always_false.
        wait_for_encoding_analyzer (Analyzer): Analyzer to decide if the message should wait for encoding.
            Defaults to always_false.
    """

    class Analyzer(Protocol):
        """Protocol definition of message rules analyzer"""

        def __call__(self, **kwargs: Any) -> bool:
            """Analyze the current inputs to see if the rule should be applied

            Args:
                **kwargs (Any): input arguments

            Returns:
                bool: Should the rule be applied?
            """

    always_false: Analyzer = lambda **kwargs: False
    always_true: Analyzer = lambda **kwargs: True

    def __init__(
        self, fastpass_analyzer: Analyzer = always_false, wait_for_encoding_analyzer: Analyzer = always_false
    ) -> None:
        self._analyze_fastpass = fastpass_analyzer
        self._analyze_wait_for_encoding = wait_for_encoding_analyzer

    def is_fastpass(self, **kwargs: Any) -> bool:
        """Is this command fastpass?

        Args:
            **kwargs (Any) : Arguments passed into the message

        Returns:
            bool: result of rule check
        """
        return self._analyze_fastpass(**kwargs)

    def should_wait_for_encoding_start(self, **kwargs: Any) -> bool:
        """Should this message wait for encoding to start?

        Args:
            **kwargs (Any) : Arguments passed into the message

        Returns:
            bool: result of rule check
        """
        return self._analyze_wait_for_encoding(**kwargs)


##############################################################################################################
####### Communicators / Clients
##############################################################################################################


class BaseGoProCommunicator(ABC):
    """Common Communicator interface"""

    @abstractmethod
    def register_update(self, callback: UpdateCb, update: UpdateType) -> None:
        """Register for callbacks when an update occurs

        Args:
            callback (UpdateCb): callback to be notified in
            update (UpdateType): update to register for
        """

    @abstractmethod
    def unregister_update(self, callback: UpdateCb, update: UpdateType | None = None) -> None:
        """Unregister for asynchronous update(s)

        Args:
            callback (UpdateCb): callback to stop receiving update(s) on
            update (UpdateType | None): updates to unsubscribe for. Defaults to None (all
                updates that use this callback will be unsubscribed).
        """


class GoProHttp(BaseGoProCommunicator):
    """Interface definition for all HTTP communicators"""

    @abstractmethod
    async def _get_json(
        self, message: HttpMessage, *, timeout: int = 0, rules: MessageRules | None = MessageRules(), **kwargs: Any
    ) -> GoProResp:
        """Perform a GET operation that returns JSON

        Args:
            message (HttpMessage): operation description
            timeout (int): time (in seconds) to wait to receive response before returning error. Defaults to 0.
            rules (MessageRules | None): message rules that this operation will obey. Defaults to MessageRules().
            **kwargs (Any) : any run-time arguments to apply to the operation

        Returns:
            GoProResp: response parsed from received JSON
        """

    @abstractmethod
    async def _get_stream(
        self, message: HttpMessage, *, timeout: int = 0, rules: MessageRules | None = MessageRules(), **kwargs: Any
    ) -> GoProResp:
        """Perform a GET operation that returns a binary stream

        Args:
            message (HttpMessage): operation description
            timeout (int): time (in seconds) to wait to receive response before returning error. Defaults to 0.
            rules (MessageRules | None): message rules that this operation will obey. Defaults to MessageRules().
            **kwargs (Any) : any run-time arguments to apply to the operation

        Returns:
            GoProResp: response wrapper around downloaded binary
        """

    @abstractmethod
    async def _put_json(
        self, message: HttpMessage, *, timeout: int = 0, rules: MessageRules | None = MessageRules(), **kwargs: Any
    ) -> GoProResp:
        """Perform a PUT operation that returns JSON

        Args:
            message (HttpMessage): operation description
            timeout (int): time (in seconds) to wait to receive response before returning error. Defaults to 0.
            rules (MessageRules | None): message rules that this operation will obey. Defaults to MessageRules().
            **kwargs (Any) : any run-time arguments to apply to the operation

        Returns:
            GoProResp: response parsed from received JSON
        """


class GoProWifi(GoProHttp):
    """GoPro specific WiFi Client

    Args:
        controller (WifiController): instance of Wifi Controller to use for this client
    """

    def __init__(self, controller: WifiController):
        self._wifi: WifiClient = WifiClient(controller)

    @property
    def password(self) -> str | None:
        """Get the GoPro AP's password

        Returns:
            str | None: password or None if it is not known
        """
        return self._wifi.password

    @property
    def ssid(self) -> str | None:
        """Get the GoPro AP's WiFi SSID

        Returns:
            str | None: SSID or None if it is not known
        """
        return self._wifi.ssid


class GoProBle(BaseGoProCommunicator, Generic[BleHandle, BleDevice]):
    """GoPro specific BLE Client

    Args:
        controller (BLEController): controller implementation to use for this client
        disconnected_cb (DisconnectHandlerType): disconnected callback
        notification_cb (NotiHandlerType): notification callback
        target (Pattern | BleDevice): regex or device to connect to
    """

    def __init__(
        self,
        controller: BLEController,
        disconnected_cb: DisconnectHandlerType,
        notification_cb: NotiHandlerType,
        target: Pattern | BleDevice,
    ) -> None:
        self._ble: BleClient = BleClient(
            controller,
            disconnected_cb,
            notification_cb,
            (re.compile(r"GoPro [A-Z0-9]{4}") if target is None else target, [GoProUUIDs.S_CONTROL_QUERY]),
            uuids=GoProUUIDs,
        )

    @abstractmethod
    async def _send_ble_message(
        self, message: BleMessage, rules: MessageRules = MessageRules(), **kwargs: Any
    ) -> GoProResp:
        """Perform a GATT write with response and accumulate received notifications into a response.

        Args:
            message (BleMessage): BLE operation description
            rules (MessageRules): message rules that this operation will obey. Defaults to MessageRules().
            **kwargs (Any) : any run-time arguments to apply to the operation

        Returns:
            GoProResp: response parsed from accumulated BLE notifications
        """

    @abstractmethod
    async def _read_ble_characteristic(
        self, message: BleMessage, rules: MessageRules = MessageRules(), **kwargs: Any
    ) -> GoProResp:
        """Perform a direct GATT read of a characteristic

        Args:
            message (BleMessage): BLE operation description
            rules (MessageRules): message rules that this operation will obey. Defaults to MessageRules().
            **kwargs (Any) : any run-time arguments to apply to the operation

        Returns:
            GoProResp: response parsed from bytes read from characteristic
        """

    # TODO this should be somewhere else
    @classmethod
    def _fragment(cls, data: bytes) -> Iterator[bytes]:
        """Fragment data in to MAX_BLE_PKT_LEN length packets

        Args:
            data (bytes): data to fragment

        Raises:
            ValueError: data is too long

        Yields:
            bytes: packet as bytes
        """
        MAX_BLE_PKT_LEN = 20

        extended_13_header = BitStruct(
            "continuation" / Const(0, Bit),
            "header" / Const(Header.EXT_13.value, BitsInteger(2)),
            "length" / BitsInteger(13),
        )

        extended_16_header = BitStruct(
            "continuation" / Const(0, Bit),
            "header" / Const(Header.EXT_16.value, BitsInteger(2)),
            "padding" / Padding(5),
            "length" / BitsInteger(16),
        )

        continuation_header = BitStruct(
            "continuation" / Const(1, Bit),
            "padding" / Padding(7),
        )

        header: Construct
        if (data_len := len(data)) < (2**13 - 1):
            header = extended_13_header
        elif data_len < (2**16 - 1):
            header = extended_16_header
        else:
            raise ValueError(f"Data length {data_len} is too long")

        assert header
        while data:
            if header == continuation_header:
                packet = bytearray(header.build({}))
            else:
                packet = bytearray(header.build({"length": data_len}))
                header = continuation_header

            bytes_remaining = MAX_BLE_PKT_LEN - len(packet)
            current, data = (data[:bytes_remaining], data[bytes_remaining:])
            packet.extend(current)
            yield bytes(packet)


class GoProWiredInterface(BaseGoProCommunicator):
    """The top-level interface for a Wired Open GoPro controller"""


class GoProWirelessInterface(GoProBle, GoProWifi, Generic[BleDevice, BleHandle]):
    """The top-level interface for a Wireless Open GoPro controller

    This always supports BLE and can optionally support Wifi

    Args:
        ble_controller (BLEController): BLE controller instance
        wifi_controller (WifiController | None): Wifi controller instance
        disconnected_cb (DisconnectHandlerType): callback for BLE disconnects
        notification_cb (NotiHandlerType): callback for BLE received notifications
        target (Pattern | BleDevice): BLE device to search for
    """

    def __init__(
        self,
        ble_controller: BLEController,
        wifi_controller: WifiController | None,
        disconnected_cb: DisconnectHandlerType,
        notification_cb: NotiHandlerType,
        target: Pattern | BleDevice,
    ) -> None:
        # Initialize GoPro Communication Client
        GoProBle.__init__(self, ble_controller, disconnected_cb, notification_cb, target)
        if wifi_controller:
            GoProWifi.__init__(self, wifi_controller)


ParserType = TypeVar("ParserType", BytesParser, JsonParser)
FilterType = TypeVar("FilterType", BytesTransformer, JsonTransformer)


##############################################################################################################
####### Messages (commands, etc.)
##############################################################################################################


class Message(ABC):
    """Base class for all messages that will be contained in a Messages class"""

    def __init__(
        self,
        identifier: IdType,
        parser: Parser | None = None,
    ) -> None:
        self._identifier: IdType = identifier
        self._parser = parser

    @abstractmethod
    def _as_dict(self, **kwargs: Any) -> JsonDict:
        """Return the attributes of the message as a dict

        Args:
            **kwargs (Any): additional entries for the dict

        Returns:
            JsonDict: message as dict
        """


class BleMessage(Message):
    """The base class for all BLE messages to store common info

    Args:
        uuid (BleUUID): BLE client to read / write
        identifier (IdType): BleUUID to read / write to
        parser (Parser | None): parser to interpret message
    """

    def __init__(
        self,
        uuid: BleUUID,
        identifier: IdType,
        parser: Parser | None,
    ) -> None:
        Message.__init__(self, identifier, parser)
        self._uuid = uuid
        self._base_dict = {"protocol": GoProResp.Protocol.BLE, "uuid": self._uuid}

        if parser:
            GlobalParsers.add(identifier, parser)

    @abstractmethod
    def _build_data(self, **kwargs: Any) -> bytearray:
        """Build the raw write request from operation description and run-time arguments

        Args:
            **kwargs (Any) : run-time arguments

        Returns:
            bytearray: raw bytes request
        """


class HttpMessage(Message):
    """The base class for all HTTP messages. Stores common information.

    Args:
        endpoint (str): base endpoint
        identifier (IdType | None): explicit message identifier. If None, will be generated from endpoint.
        components (list[str] | None): Additional path components (i.e. endpoint/{COMPONENT}). Defaults to None.
        arguments (list[str] | None): Any arguments to be appended after endpoint (i.e. endpoint?{ARGUMENT}). Defaults to None.
        body_args (list[str] | None): Arguments to be added to the body JSON. Defaults to None.
        headers (dict[str, Any] | None): A dict of values to be set in the HTTP operation headers. Defaults to None.
        certificate (Path | None): Path to SSL certificate bundle. Defaults to None.
        parser (Parser | None): Parser to interpret HTTP responses. Defaults to None.
    """

    def __init__(
        self,
        endpoint: str,
        identifier: IdType | None,
        components: list[str] | None = None,
        arguments: list[str] | None = None,
        body_args: list[str] | None = None,
        headers: dict[str, Any] | None = None,
        certificate: Path | None = None,
        parser: Parser | None = None,
    ) -> None:
        if not identifier:
            # Build human-readable name from endpoint
            identifier = endpoint.lower().removeprefix("gopro/").replace("/", " ").replace("_", " ").title()
            try:
                identifier = identifier.split("?")[0].strip("{}")
            except IndexError:
                pass

        self._headers = headers or {}
        self._endpoint = endpoint
        self._components = components or []
        self._arguments = arguments or []
        self._body_args = body_args or []
        self._certificate = certificate
        Message.__init__(self, identifier, parser)
        self._base_dict: JsonDict = {
            "id": self._identifier,
            "protocol": GoProResp.Protocol.HTTP,
            "endpoint": self._endpoint,
        }

    def __str__(self) -> str:
        return str(self._identifier).title()

    def _as_dict(self, **kwargs: Any) -> JsonDict:
        """Return the attributes of the message as a dict

        Args:
            **kwargs (Any): additional entries for the dict

        Returns:
            JsonDict: message as dict
        """
        # If any kwargs keys were to conflict with base dict, append underscore
        return self._base_dict | {f"{'_' if k in ['id', 'protocol'] else ''}{k}": v for k, v in kwargs.items()}

    def build_body(self, **kwargs: Any) -> dict[str, Any]:
        """Build JSON body from run-time body arguments

        Args:
            **kwargs (Any): run-time arguments to check to see if each should be added to the body

        Returns:
            dict[str, Any]: built JSON body
        """
        body: dict[str, Any] = {}
        for name, value in kwargs.items():
            if name in self._body_args:
                body[name] = value
        return body

    def build_url(self, **kwargs: Any) -> str:
        """Build the URL string from the passed in components and arguments

        Args:
            **kwargs (Any): additional entries for the dict

        Returns:
            str: built URL
        """
        url = self._endpoint
        for component in self._components:
            url += "/" + kwargs.pop(component)
        # Append parameters
        if self._arguments and (
            arg_part := urlencode(
                {
                    k: kwargs[k].value if isinstance(kwargs[k], enum.Enum) else kwargs[k]
                    for k in self._arguments
                    if kwargs[k] is not None
                },
                safe="/",
            )
        ):
            url += "?" + arg_part
        return url


MessageType = TypeVar("MessageType", bound=Message)

CommunicatorType = TypeVar("CommunicatorType", bound=BaseGoProCommunicator)


class Messages(ABC, dict, Generic[MessageType, CommunicatorType]):
    """Base class for setting and status containers

    Allows message groups to be iterable and supports dict-like access.

    Instance attributes that are an instance (or subclass) of Message are automatically accumulated during
    instantiation

    Args:
        communicator (CommunicatorType): communicator that will send messages
    """

    def __init__(self, communicator: CommunicatorType) -> None:
        self._communicator = communicator
        # Append any automatically discovered instance attributes (i.e. for settings and statuses)
        message_map: dict[IdType, MessageType] = {}
        for message in self.__dict__.values():
            if hasattr(message, "_identifier"):
                message_map[message._identifier] = message
        # Append any automatically discovered methods (i.e. for commands)
        for name, method in inspect.getmembers(self, predicate=inspect.ismethod):
            if not name.startswith("_"):
                message_map[name.replace("_", " ").title()] = method
        dict.__init__(self, message_map)


class BleMessages(Messages[MessageType, GoProBle]):
    """A container of BLE Messages.

    Identical to Messages and it just used for typing
    """


class HttpMessages(Messages[MessageType, GoProHttp]):
    """A container of HTTP Messages.

    Identical to Messages and it just used for typing
    """

================
File: demos/python/sdk_wireless_camera_control/open_gopro/constants.py
================
# constants.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Wed, Sep  1, 2021  5:05:44 PM

"""Constant numbers shared across the GoPro module. These do not change across Open GoPro Versions"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Final

from open_gopro.ble import BleUUID, UUIDs
from open_gopro.enum import GoProIntEnum

GOPRO_BASE_UUID: Final = "b5f9{}-aa8d-11e3-9046-0002a5d5c51b"


@dataclass(frozen=True)
class GoProUUIDs(UUIDs):
    """GoPro Proprietary BleUUID's."""

    # GoPro Wifi Access Point Service
    S_WIFI_ACCESS_POINT = BleUUID("Wifi Access Point Service", hex=GOPRO_BASE_UUID.format("0001"))
    WAP_SSID = BleUUID("Wifi AP SSID", hex=GOPRO_BASE_UUID.format("0002"))
    WAP_PASSWORD = BleUUID("Wifi AP Password", hex=GOPRO_BASE_UUID.format("0003"))
    WAP_POWER = BleUUID("Wifi Power", hex=GOPRO_BASE_UUID.format("0004"))
    WAP_STATE = BleUUID("Wifi State", hex=GOPRO_BASE_UUID.format("0005"))
    WAP_CSI_PASSWORD = BleUUID("CSI Password", hex=GOPRO_BASE_UUID.format("0006"))

    # GoPro Control & Query Service
    S_CONTROL_QUERY = BleUUID("Control and Query Service", hex="0000fea6-0000-1000-8000-00805f9b34fb")
    CQ_COMMAND = BleUUID("Command", hex=GOPRO_BASE_UUID.format("0072"))
    CQ_COMMAND_RESP = BleUUID("Command Response", hex=GOPRO_BASE_UUID.format("0073"))
    CQ_SETTINGS = BleUUID("Settings", hex=GOPRO_BASE_UUID.format("0074"))
    CQ_SETTINGS_RESP = BleUUID("Settings Response", hex=GOPRO_BASE_UUID.format("0075"))
    CQ_QUERY = BleUUID("Query", hex=GOPRO_BASE_UUID.format("0076"))
    CQ_QUERY_RESP = BleUUID("Query Response", hex=GOPRO_BASE_UUID.format("0077"))
    CQ_SENSOR = BleUUID("Sensor", hex=GOPRO_BASE_UUID.format("0078"))
    CQ_SENSOR_RESP = BleUUID("Sensor Response", hex=GOPRO_BASE_UUID.format("0079"))

    # GoPro Camera Management Service
    S_CAMERA_MANAGEMENT = BleUUID("Camera Management Service", hex=GOPRO_BASE_UUID.format("0090"))
    CM_NET_MGMT_COMM = BleUUID("Camera Management", hex=GOPRO_BASE_UUID.format("0091"))
    CN_NET_MGMT_RESP = BleUUID("Camera Management Response", hex=GOPRO_BASE_UUID.format("0092"))

    # Unknown
    S_INTERNAL = BleUUID("Unknown Service", hex=GOPRO_BASE_UUID.format("0080"))
    INTERNAL_81 = BleUUID("Internal 81", hex=GOPRO_BASE_UUID.format("0081"))
    INTERNAL_82 = BleUUID("Internal 82", hex=GOPRO_BASE_UUID.format("0082"))
    INTERNAL_83 = BleUUID("Internal 83", hex=GOPRO_BASE_UUID.format("0083"))
    INTERNAL_84 = BleUUID("Internal 84", hex=GOPRO_BASE_UUID.format("0084"))


class ErrorCode(GoProIntEnum):
    """Status Codes."""

    SUCCESS = 0
    ERROR = 1
    INVALID_PARAM = 2
    UNKNOWN = -1


class CmdId(GoProIntEnum):
    """Command ID's that are written to GoProUUIDs.CQ_COMMAND."""

    SET_SHUTTER = 0x01
    POWER_DOWN = 0x04
    SLEEP = 0x05
    SET_PAIRING_COMPLETE = 0x03
    SET_DATE_TIME = 0x0D
    GET_DATE_TIME = 0x0E
    SET_DATE_TIME_DST = 0x0F
    GET_DATE_TIME_DST = 0x10
    GET_CAMERA_SETTINGS = 0x12
    GET_CAMERA_STATUSES = 0x13
    GET_CAMERA_CAPABILITIES = 0x32
    SET_WIFI = 0x17
    TAG_HILIGHT = 0x18
    GET_SETTINGS_JSON = 0x3B
    GET_HW_INFO = 0x3C
    LOAD_PRESET_GROUP = 0x3E
    LOAD_PRESET = 0x40
    SET_THIRD_PARTY_CLIENT_INFO = 0x50
    GET_THIRD_PARTY_API_VERSION = 0x51
    REGISTER_ALL_SETTINGS = 0x52
    REGISTER_ALL_STATUSES = 0x53
    UNREGISTER_ALL_SETTINGS = 0x72
    UNREGISTER_ALL_STATUSES = 0x73
    REGISTER_ALL_CAPABILITIES = 0x62
    UNREGISTER_ALL_CAPABILITIES = 0x82


class ActionId(GoProIntEnum):
    """Action ID's that identify a protobuf command."""

    SCAN_WIFI_NETWORKS = 0x02
    GET_AP_ENTRIES = 0x03
    REQUEST_WIFI_CONNECT = 0x04
    REQUEST_WIFI_CONNECT_NEW = 0x05
    NOTIF_START_SCAN = 0x0B
    NOTIF_PROVIS_STATE = 0x0C
    REQUEST_PRESET_UPDATE_CUSTOM = 0x64
    SET_CAMERA_CONTROL = 0x69
    SET_TURBO_MODE = 0x6B
    GET_PRESET_STATUS = 0x72
    GET_LIVESTREAM_STATUS = 0x74
    RELEASE_NETWORK = 0x78
    SET_LIVESTREAM_MODE = 0x79
    SCAN_WIFI_NETWORKS_RSP = 0x82
    GET_AP_ENTRIES_RSP = 0x83
    REQUEST_WIFI_CONNECT_RSP = 0x84
    REQUEST_WIFI_CONNECT_NEW_RSP = 0x85
    REQUEST_COHN_SETTING = 0x65
    REQUEST_CLEAR_COHN_CERT = 0x66
    REQUEST_CREATE_COHN_CERT = 0x67
    REQUEST_GET_LAST_MEDIA = 0x6D
    REQUEST_GET_COHN_CERT = 0x6E
    REQUEST_GET_COHN_STATUS = 0x6F
    RESPONSE_PRESET_UPDATE_CUSTOM = 0xE4
    RESPONSE_COHN_SETTING = 0xE5
    RESPONSE_CLEAR_COHN_CERT = 0xE6
    RESPONSE_CREATE_COHN_CERT = 0xE7
    SET_CAMERA_CONTROL_RSP = 0xE9
    SET_TURBO_MODE_RSP = 0xEB
    RESPONSE_GET_LAST_MEDIA = 0xED
    RESPONSE_GET_COHN_CERT = 0xEE
    RESPONSE_GET_COHN_STATUS = 0xEF
    GET_PRESET_STATUS_RSP = 0xF2
    PRESET_MODIFIED_NOTIFICATION = 0xF3
    LIVESTREAM_STATUS_RSP = 0xF4
    LIVESTREAM_STATUS_NOTIF = 0xF5
    RELEASE_NETWORK_RSP = 0xF8
    SET_LIVESTREAM_MODE_RSP = 0xF9
    INTERNAL_FF = 0xFF


class FeatureId(GoProIntEnum):
    """ID's that group protobuf commands"""

    NETWORK_MANAGEMENT = 0x02
    COMMAND = 0xF1
    SETTING = 0xF3
    QUERY = 0xF5


class SettingId(GoProIntEnum):
    """Setting ID's that identify settings and are written to GoProUUIDs.CQ_SETTINGS."""

    RESOLUTION = 2
    FPS = 3
    INTERNAL_5 = 5
    INTERNAL_6 = 6
    INTERNAL_13 = 13
    INTERNAL_19 = 19
    INTERNAL_24 = 24
    INTERNAL_30 = 30
    INTERNAL_31 = 31
    INTERNAL_32 = 32
    INTERNAL_37 = 37
    INTERNAL_41 = 41
    INTERNAL_42 = 42
    INTERNAL_43 = 43
    INTERNAL_44 = 44
    INTERNAL_45 = 45
    INTERNAL_47 = 47
    INTERNAL_48 = 48
    INTERNAL_54 = 54
    AUTO_OFF = 59
    INTERNAL_60 = 60
    INTERNAL_61 = 61
    INTERNAL_62 = 62
    INTERNAL_64 = 64
    INTERNAL_65 = 65
    INTERNAL_66 = 66
    INTERNAL_67 = 67
    INTERNAL_68 = 68
    INTERNAL_69 = 69
    INTERNAL_75 = 75
    INTERNAL_76 = 76
    INTERNAL_79 = 79
    INTERNAL_83 = 83
    INTERNAL_84 = 84
    INTERNAL_85 = 85
    INTERNAL_86 = 86
    INTERNAL_87 = 87
    INTERNAL_88 = 88
    LED = 91
    INTERNAL_96 = 96
    INTERNAL_102 = 102
    INTERNAL_103 = 103
    INTERNAL_104 = 104
    INTERNAL_105 = 105
    INTERNAL_106 = 106
    VIDEO_ASPECT_RATIO = 108
    INTERNAL_111 = 111
    INTERNAL_112 = 112
    INTERNAL_114 = 114
    INTERNAL_115 = 115
    INTERNAL_116 = 116
    INTERNAL_117 = 117
    INTERNAL_118 = 118
    VIDEO_FOV = 121
    PHOTO_FOV = 122
    MULTI_SHOT_FOV = 123
    INTERNAL_124 = 124
    PHOTO_OUTPUT = 125
    INTERNAL_126 = 126
    MEDIA_FORMAT = 128
    INTERNAL_129 = 129
    INTERNAL_130 = 130
    INTERNAL_131 = 131
    INTERNAL_132 = 132
    INTERNAL_133 = 133
    ANTI_FLICKER = 134
    HYPERSMOOTH = 135
    INTERNAL_139 = 139
    INTERNAL_142 = 142
    INTERNAL_144 = 144
    INTERNAL_145 = 145
    INTERNAL_146 = 146
    INTERNAL_147 = 147
    INTERNAL_148 = 148
    INTERNAL_149 = 149
    VIDEO_HORIZON_LEVELING = 150
    PHOTO_HORIZON_LEVELING = 151
    INTERNAL_153 = 153
    INTERNAL_154 = 154
    INTERNAL_155 = 155
    VIDEO_DURATION = 156
    INTERNAL_157 = 157
    INTERNAL_158 = 158
    INTERNAL_159 = 159
    INTERNAL_160 = 160
    INTERNAL_161 = 161
    MAX_LENS_MOD = 162
    INTERNAL_163 = 163
    INTERNAL_164 = 164
    INTERNAL_165 = 165
    INTERNAL_166 = 166
    HINDSIGHT = 167
    INTERNAL_168 = 168
    INTERNAL_169 = 169
    PHOTO_INTERVAL = 171
    PHOTO_INTERVAL_DURATION = 172
    VIDEO_PERFORMANCE_MODE = 173
    INTERNAL_174 = 174
    CAMERA_UX_MODE = 175
    VIDEO_EASY_MODE = 176
    PHOTO_EASY_MODE = 177
    WIFI_BAND = 178
    STAR_TRAIL_LENGTH = 179
    SYSTEM_VIDEO_MODE = 180
    INTERNAL_181 = 181
    BIT_RATE = 182
    BIT_DEPTH = 183
    VIDEO_PROFILE = 184
    VIDEO_EASY_ASPECT_RATIO = 185
    VIDEO_MODE = 186
    TIMELAPSE_MODE = 187
    MULTI_SHOT_EASY_ASPECT_RATIO = 188
    ADDON_MAX_LENS_MOD = 189
    ADDON_MAX_LENS_MOD_ENABLE = 190
    PHOTO_MODE = 191
    MULTI_SHOT_NLV_ASPECT_RATIO = 192
    FRAMING = 193
    INTERNAL_194 = 194
    REGIONAL_FORMAT = 195
    INTERNAL_196 = 196
    INTERNAL_197 = 197
    INTERNAL_198 = 198
    INTERNAL_199 = 199
    INTERNAL_200 = 200
    QUALITY_CONTROL = 201
    INTERNAL_202 = 202
    INTERNAL_203 = 203
    INTERNAL_204 = 204
    INTERNAL_205 = 205
    INTERNAL_206 = 206
    INTERNAL_207 = 207
    INTERNAL_208 = 208
    INTERNAL_209 = 209
    INTERNAL_210 = 210
    INTERNAL_211 = 211
    INTERNAL_212 = 212
    INTERNAL_213 = 213
    INTERNAL_214 = 214
    INTERNAL_215 = 215
    CAMERA_VOLUME = 216
    LENS_ATTACHMENT = 217
    INTERNAL_218 = 218
    SETUP_SCREEN_SAVER = 219
    INTERNAL_220 = 220
    INTERNAL_221 = 221
    INTERNAL_222 = 222
    SETUP_LANGUAGE = 223
    INTERNAL_224 = 224
    AUTO_POWER_OFF = 225
    INTERNAL_226 = 226
    PHOTO_MODE_V2 = 227
    INTERNAL_228 = 228
    VIDEO_DIGITAL_LENSES_V2 = 229
    PHOTO_DIGITAL_LENSES_V2 = 230
    TIMELAPSE_DIGITAL_LENSES_V2 = 231
    VIDEO_FRAMING = 232
    MULTI_SHOT_FRAMING = 233
    FRAME_RATE = 234
    PROTOBUF_SETTING = 0xF3


class QueryCmdId(GoProIntEnum):
    """Command ID that is written to GoProUUIDs.CQ_QUERY."""

    GET_SETTING_VAL = 0x12
    GET_STATUS_VAL = 0x13
    GET_SETTING_NAME = 0x22
    GET_CAPABILITIES_VAL = 0x32
    GET_CAPABILITIES_NAME = 0x42
    REG_SETTING_VAL_UPDATE = 0x52
    REG_STATUS_VAL_UPDATE = 0x53
    REG_CAPABILITIES_UPDATE = 0x62
    UNREG_SETTING_VAL_UPDATE = 0x72
    UNREG_STATUS_VAL_UPDATE = 0x73
    UNREG_CAPABILITIES_UPDATE = 0x82
    SETTING_VAL_PUSH = 0x92
    STATUS_VAL_PUSH = 0x93
    SETTING_CAPABILITY_PUSH = 0xA2
    PROTOBUF_QUERY = 0xF5


class StatusId(GoProIntEnum):
    """Status ID to identify statuses sent to GoProUUIDs.CQ_QUERY or received from GoProUUIDs.CQ_QUERY_RESP."""

    BATT_PRESENT = 1
    BATT_LEVEL = 2
    DEPRECATED_3 = 3
    DEPRECATED_4 = 4
    SYSTEM_HOT = 6
    SYSTEM_BUSY = 8
    QUICK_CAPTURE = 9
    ENCODING = 10
    LCD_LOCK_ACTIVE = 11
    VIDEO_PROGRESS = 13
    INTERNAL_14 = 14
    WIRELESS_ENABLED = 17
    PAIR_STATE = 19
    PAIR_TYPE = 20
    PAIR_TIME = 21
    WAP_SCAN_STATE = 22
    WAP_SCAN_TIME = 23
    WAP_PROV_STAT = 24
    REMOTE_CTRL_VER = 26
    REMOTE_CTRL_CONN = 27
    PAIR_STATE2 = 28
    WLAN_SSID = 29
    AP_SSID = 30
    APP_COUNT = 31
    PREVIEW_ENABLED = 32
    SD_STATUS = 33
    PHOTOS_REM = 34
    VIDEO_REM = 35
    NUM_GROUP_PHOTO = 36
    NUM_GROUP_VIDEO = 37
    NUM_TOTAL_PHOTO = 38
    NUM_TOTAL_VIDEO = 39
    DEPRECATED_40 = 40
    OTA_STAT = 41
    DOWNLOAD_CANCEL_PEND = 42
    MODE_GROUP = 43
    LOCATE_ACTIVE = 45
    INTERNAL_46 = 46
    INTERNAL_47 = 47
    INTERNAL_48 = 48
    MULTI_COUNT_DOWN = 49
    SPACE_REM = 54
    STREAMING_SUPP = 55
    WIFI_BARS = 56
    CURRENT_TIME_MS = 57
    NUM_HILIGHTS = 58
    LAST_HILIGHT = 59
    NEXT_POLL = 60
    ANALYTICS_RDY = 61
    ANALYTICS_SIZE = 62
    IN_CONTEXT_MENU = 63
    TIMELAPSE_REM = 64
    EXPOSURE_TYPE = 65
    EXPOSURE_X = 66
    EXPOSURE_Y = 67
    GPS_STAT = 68
    AP_STATE = 69
    INT_BATT_PER = 70
    ACC_MIC_STAT = 74
    DIGITAL_ZOOM = 75
    WIRELESS_BAND = 76
    DIG_ZOOM_ACTIVE = 77
    MOBILE_VIDEO = 78
    FIRST_TIME = 79
    SEC_SD_STAT = 80
    BAND_5GHZ_AVAIL = 81
    SYSTEM_READY = 82
    BATT_OK_OTA = 83
    CAPTURE_DELAY = 84
    VIDEO_LOW_TEMP = 85
    ORIENTATION = 86
    DEPRECATED_87 = 87
    ZOOM_ENCODING = 88
    FLATMODE_ID = 89
    INTERNAL_90 = 90
    LOGS_READY = 91
    DEPRECATED_92 = 92
    VIDEO_PRESETS = 93
    PHOTO_PRESETS = 94
    TIMELAPSE_PRESETS = 95
    PRESETS_GROUP = 96
    ACTIVE_PRESET = 97
    PRESET_MODIFIED = 98
    LIVE_BURST_REM = 99
    LIVE_BURST_TOTAL = 100
    CAPT_DELAY_ACTIVE = 101
    MEDIA_MOD_MIC_STAT = 102
    TIMEWARP_SPEED_RAMP = 103
    LINUX_CORE_ACTIVE = 104
    CAMERA_LENS_TYPE = 105
    VIDEO_HINDSIGHT = 106
    SCHEDULED_PRESET = 107
    SCHEDULED_CAPTURE = 108
    CREATING_PRESET = 109
    MEDIA_MOD_STAT = 110
    SD_RATING_CHECK_ERROR = 111
    SD_WRITE_SPEED_ERROR = 112
    TURBO_MODE = 113
    CAMERA_CONTROL = 114
    USB_CONNECTED = 115
    CONTROL_OVER_USB = 116
    TOTAL_SD_SPACE_KB = 117
    PHOTO_INTERVAL_CAPTURE_COUNT = 118
    CAMERA_LENS_MOD = 119


class WebcamStatus(GoProIntEnum):
    """Webcam Statuses / states"""

    OFF = 0
    IDLE = 1
    HIGH_POWER_PREVIEW = 2
    LOW_POWER_PREVIEW = 3


class WebcamError(GoProIntEnum):
    """Errors common among Webcam commands"""

    SUCCESS = 0
    SET_PRESET = 1
    SET_WINDOW_SIZE = 2
    EXEC_STREAM = 3
    SHUTTER = 4
    COM_TIMEOUT = 5
    INVALID_PARAM = 6
    UNAVAILABLE = 7
    EXIT = 8

================
File: demos/python/sdk_wireless_camera_control/open_gopro/enum.py
================
# enum.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Mon Jul 31 17:04:07 UTC 2023

"""Custom enum definition"""

from __future__ import annotations

from enum import Enum, EnumMeta, IntEnum
from typing import Any, Iterator, Protocol, TypeVar, no_type_check

T = TypeVar("T")


class ProtobufDescriptor(Protocol):
    """Protocol definition for Protobuf enum descriptor used to generate GoPro enums from protobufs"""

    @property
    def name(self) -> str:
        """Human readable name of protobuf enum

        # noqa: DAR202

        Returns:
            str: enum name
        """

    @property
    def values_by_name(self) -> dict:
        """Get the enum values by name

        # noqa: DAR202

        Returns:
            dict: Dict of enum values mapped by name
        """

    @property
    def values_by_number(self) -> dict:
        """Get the enum values by number

        # noqa: DAR202

        Returns:
            dict: dict of enum numbers mapped by number
        """


class GoProEnumMeta(EnumMeta):
    """Modify enum metaclass to build GoPro specific enums"""

    _is_proto = False
    _iter_skip_names = ("NOT_APPLICABLE", "DESCRIPTOR")

    @no_type_check
    def __new__(mcs, name, bases, classdict, **kwargs) -> GoProEnumMeta:  # noqa
        is_proto = "__is_proto__" in classdict
        classdict["_ignore_"] = "__is_proto__"
        classdict["__doc__"] = ""  # Don't use useless "An enumeration" docstring
        e = super().__new__(mcs, name, bases, classdict, **kwargs)
        setattr(e, "_is_proto", is_proto)
        return e

    @no_type_check
    def __contains__(cls: type[Any], obj: object) -> bool:
        if isinstance(obj, Enum):
            return super().__contains__(obj)
        if isinstance(obj, int):
            return obj in [x.value for x in cls._member_map_.values()]
        if isinstance(obj, str):
            return obj.lower() in [x.name.lower() for x in cls._member_map_.values()]
        raise TypeError(
            f"unsupported operand type(s) for 'in': {type(obj).__qualname__} and {cls.__class__.__qualname__}"
        )

    def __iter__(cls: type[T]) -> Iterator[T]:
        """Do not return enum values whose name is in the _iter_skip_names list

        Returns:
            Iterator[T]: enum iterator
        """
        return iter([x[1] for x in cls._member_map_.items() if x[0] not in GoProEnumMeta._iter_skip_names])  # type: ignore


class GoProIntEnum(IntEnum, metaclass=GoProEnumMeta):
    """GoPro specific integer enum to be used for all settings, statuses, and parameters

    The names NOT_APPLICABLE and DESCRIPTOR are special as they will not be returned as part of the enum iterator
    """

    def __eq__(self, other: object) -> bool:
        if type(self)._is_proto:
            if isinstance(other, int):
                return self.value == other
            if isinstance(other, str):
                return self.name == other
            if isinstance(other, Enum):
                return self.value == other.value
            raise TypeError(f"Unexpected case: proto enum can only be str or int, not {type(other)}")
        return super(IntEnum, self).__eq__(other)

    def __hash__(self) -> Any:
        return hash(self.name + str(self.value))

    def __str__(self) -> str:
        return super(IntEnum, self).__str__()


class GoProEnum(Enum, metaclass=GoProEnumMeta):
    """GoPro specific enum to be used for all settings, statuses, and parameters

    The names NOT_APPLICABLE and DESCRIPTOR are special as they will not be returned as part of the enum iterator
    """

    def __eq__(self, other: object) -> bool:
        if type(self)._is_proto:
            if isinstance(other, int):
                return self.value == other
            if isinstance(other, str):
                return self.name == other
            if isinstance(other, Enum):
                return self.value == other.value
            raise TypeError(f"Unexpected case: proto enum can only be str or int, not {type(other)}")
        return super().__eq__(other)

    def __hash__(self) -> Any:
        return hash(self.name + str(self.value))


def enum_factory(proto_enum: ProtobufDescriptor) -> type[GoProIntEnum]:
    """Dynamically build a GoProEnum from a protobuf enum

    Args:
        proto_enum (ProtobufDescriptor): input protobuf enum descriptor

    Returns:
        type[GoProIntEnum]: generated GoProEnum
    """
    keys = proto_enum.values_by_name.keys()
    values = list(proto_enum.values_by_number.keys())
    # This has somehow changed between protobuf versions
    if isinstance(proto_enum.values_by_number, dict):
        values.reverse()
    return GoProIntEnum(  # type: ignore # pylint: disable=too-many-function-args
        proto_enum.name,  # type: ignore
        {
            **dict(zip(keys, values)),
            "__is_proto__": True,
        },
    )

================
File: demos/python/sdk_wireless_camera_control/open_gopro/exceptions.py
================
# exceptions.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Tue Sep  7 21:35:53 UTC 2021

"""Exceptions that pertain to Gopro-level functionality."""

from __future__ import annotations

from typing import Callable


class GoProError(Exception):
    """Base class for other GoPro-level exceptions."""


class ResponseParseError(GoProError):
    """Error when parsing received data."""

    def __init__(self, identifier: str, data: bytearray, msg: str = "") -> None:
        super().__init__(f"{msg}: Failed to parse {data.hex(':')} from {identifier}")


class InvalidOpenGoProVersion(GoProError):
    """Attempt to access an invalid Open GoPro API version"""

    def __init__(self, version: str) -> None:
        super().__init__(f"{version} is not a valid Open GoPro API version.")


class InvalidConfiguration(GoProError):
    """Something was attempted that is not possible for the current configuration."""

    def __init__(self, message: str) -> None:
        super().__init__(f"Invalid configuration: {message}")


class GoProNotOpened(GoProError):
    """A command was attempted without waiting for the GoPro instance to open."""

    def __init__(self, message: str) -> None:
        super().__init__(f"GoPro is not correctly open: {message}")


class FailedToFindDevice(GoProError):
    """The scan failed without finding a device."""

    def __init__(self) -> None:
        super().__init__("A scan timed out without finding a device")


class ConnectFailed(GoProError):
    """A BLE connection failed to establish

    Args:
        connection (str): type of connection that failed
        timeout (float): the timeout used for each attempt
        retries (int): how many retries were attempted
    """

    def __init__(self, connection: str, timeout: float, retries: int):
        super().__init__(f"{connection} connection failed to establish after {retries} retries with timeout {timeout}")


class ConnectionTerminated(GoProError):
    """A connection that was previously established has terminated."""

    def __init__(self, message: str) -> None:
        super().__init__(f"Connection terminated: {message}")


class ResponseTimeout(GoProError):
    """A response has timed out."""

    def __init__(self, timeout: float) -> None:
        super().__init__(f"Response timeout occurred of {timeout} seconds")


class InterfaceConfigFailure(GoProError):
    """An error has occurred while setting up the communication interface"""


ExceptionHandler = Callable[[Exception], None]
"""Exception handler callback type"""

================
File: demos/python/sdk_wireless_camera_control/open_gopro/gopro_base.py
================
# gopro.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Wed, Sep  1, 2021  5:05:47 PM

"""Implements top level interface to GoPro module."""

from __future__ import annotations

import asyncio
import enum
import json
import logging
import threading
import traceback
from abc import abstractmethod
from typing import Any, Awaitable, Callable, Final, Generic, TypeVar

import requests
import wrapt

import open_gopro.exceptions as GpException
from open_gopro.api import (
    BleCommands,
    BleSettings,
    BleStatuses,
    HttpCommands,
    HttpSettings,
    WiredApi,
    WirelessApi,
)
from open_gopro.communicator_interface import (
    GoProHttp,
    HttpMessage,
    Message,
    MessageRules,
)
from open_gopro.constants import ErrorCode
from open_gopro.logger import Logger
from open_gopro.models.response import GoProResp, RequestsHttpRespBuilderDirector
from open_gopro.types import JsonDict
from open_gopro.util import pretty_print

logger = logging.getLogger(__name__)

GoPro = TypeVar("GoPro", bound="GoProBase")
ApiType = TypeVar("ApiType", WiredApi, WirelessApi)
MessageMethodType = Callable[[Any, bool], Awaitable[GoProResp]]


class GoProMessageInterface(enum.Enum):
    """Enum to identify wireless interface"""

    HTTP = enum.auto()
    BLE = enum.auto()


@wrapt.decorator
def catch_thread_exception(wrapped: Callable, instance: GoProBase, args: Any, kwargs: Any) -> Callable | None:
    """Catch any exceptions from this method and pass them to the exception handler identifier by thread name

    Args:
        wrapped (Callable): method that this is wrapping
        instance (GoProBase): instance owner of method
        args (Any): positional args
        kwargs (Any): keyword args

    Returns:
        Callable | None: forwarded return of wrapped method or None if exception occurs
    """
    try:
        return wrapped(*args, **kwargs)
    except Exception as e:  # pylint: disable=broad-exception-caught
        instance._handle_exception(threading.current_thread().name, {"exception": e})
        return None


def ensure_opened(interface: tuple[GoProMessageInterface]) -> Callable:
    """Raise exception if relevant interface is not currently opened

    Args:
        interface (tuple[GoProMessageInterface]): wireless interface to verify

    Returns:
        Callable: Direct pass-through of callable after verification
    """

    @wrapt.decorator
    def wrapper(wrapped: Callable, instance: GoProBase, args: Any, kwargs: Any) -> Callable:
        if GoProMessageInterface.BLE in interface and not instance.is_ble_connected:
            raise GpException.GoProNotOpened("BLE not connected")
        if GoProMessageInterface.HTTP in interface and not instance.is_http_connected:
            raise GpException.GoProNotOpened("HTTP interface not connected")
        return wrapped(*args, **kwargs)

    return wrapper


@wrapt.decorator
async def enforce_message_rules(wrapped: MessageMethodType, instance: GoProBase, args: Any, kwargs: Any) -> GoProResp:
    """Decorator proxy to call the GoProBase's _enforce_message_rules method.

    Args:
        wrapped (MessageMethodType): Operation to enforce
        instance (GoProBase): GoProBase instance to use
        args (Any): positional arguments to wrapped
        kwargs (Any): keyword arguments to wrapped

    Returns:
        GoProResp: common response object
    """
    return await instance._enforce_message_rules(wrapped, *args, **kwargs)


class GoProBase(GoProHttp, Generic[ApiType]):
    """The base class for communicating with all GoPro Clients"""

    HTTP_TIMEOUT: Final = 5
    HTTP_GET_RETRIES: Final = 5

    def __init__(self, **kwargs: Any) -> None:
        self._should_maintain_state = kwargs.get("maintain_state", True)
        self._exception_cb = kwargs.get("exception_cb", None)

    async def __aenter__(self: GoPro) -> GoPro:
        await self.open()
        return self

    async def __aexit__(self, *_: Any) -> None:
        await self.close()

    @abstractmethod
    async def open(self, timeout: int = 10, retries: int = 5) -> None:
        """Connect to the GoPro Client and prepare it for communication

        Args:
            timeout (int): time before considering connection a failure. Defaults to 10.
            retries (int): number of connection retries. Defaults to 5.
        """

    @abstractmethod
    async def close(self) -> None:
        """Gracefully close the GoPro Client connection"""

    @property
    @abstractmethod
    async def is_ready(self) -> bool:
        """Is gopro ready to receive commands

        Returns:
            bool: yes if ready, no otherwise
        """

    @property
    @abstractmethod
    def identifier(self) -> str:
        """Unique identifier for the connected GoPro Client

        Returns:
            str: identifier
        """

    @property
    def version(self) -> str:
        """The API version that the connected camera supports

        Only 2.0 is currently supported

        Returns:
            str: supported version
        """
        return self._api.version

    @property
    @abstractmethod
    def http_command(self) -> HttpCommands:
        """Used to access the Wifi commands

        Returns:
            HttpCommands: the commands
        """

    @property
    @abstractmethod
    def http_setting(self) -> HttpSettings:
        """Used to access the Wifi settings

        Returns:
            HttpSettings: the settings
        """

    @property
    @abstractmethod
    def ble_command(self) -> BleCommands:
        """Used to call the BLE commands

        Returns:
            BleCommands: the commands
        """

    @property
    @abstractmethod
    def ble_setting(self) -> BleSettings:
        """Used to access the BLE settings

        Returns:
            BleSettings: the settings
        """

    @property
    @abstractmethod
    def ble_status(self) -> BleStatuses:
        """Used to access the BLE statuses

        Returns:
            BleStatuses: the statuses
        """

    @property
    @abstractmethod
    def is_open(self) -> bool:
        """Is this client ready for communication?

        Returns:
            bool: True if yes, False if no
        """

    @property
    @abstractmethod
    def is_ble_connected(self) -> bool:
        """Are we connected via BLE to the GoPro device?

        Returns:
            bool: True if yes, False if no
        """

    @property
    @abstractmethod
    def is_http_connected(self) -> bool:
        """Are we connected via HTTP to the GoPro device?

        Returns:
            bool: True if yes, False if no
        """

    @abstractmethod
    async def configure_cohn(self, timeout: int = 60) -> bool:
        """Prepare Camera on the Home Network

        Provision if not provisioned
        Then wait for COHN to be connected and ready

        Args:
            timeout (int): time in seconds to wait for COHN to be ready. Defaults to 60.

        Returns:
            bool: True if success, False otherwise
        """

    @property
    @abstractmethod
    async def is_cohn_provisioned(self) -> bool:
        """Is COHN currently provisioned?

        Get the current COHN status from the camera

        Returns:
            bool: True if COHN is provisioned, False otherwise
        """

    ##########################################################################################################
    #                                 End Public API
    ##########################################################################################################

    @abstractmethod
    async def _enforce_message_rules(
        self, wrapped: Callable, message: Message, rules: MessageRules, **kwargs: Any
    ) -> GoProResp:
        """Rule Enforcer. Called by enforce_message_rules decorator.

        Args:
            wrapped (Callable): operation to enforce
            message (Message): message passed to operation
            rules (MessageRules): rules to enforce
            **kwargs (Any) : arguments passed to operation

        Returns:
            GoProResp: Operation response
        """

    def _handle_exception(self, source: Any, context: JsonDict) -> None:
        """Gather exceptions from module threads and send through callback if registered.

        Note that this function signature matches asyncio's exception callback requirement.

        Args:
            source (Any): Where did the exception come from?
            context (JsonDict): Access exception via context["exception"]
        """
        # context["message"] will always be there; but context["exception"] may not
        if exception := context.get("exception", False):
            logger.error(f"Received exception {exception} from {source}")
            logger.error(traceback.format_exc())
            if self._exception_cb:
                self._exception_cb(exception)
        else:
            logger.error(f"Caught unknown message: {context['message']} from {source}")

    class _InternalState(enum.IntFlag):
        """State used to manage whether the GoPro instance is ready or not."""

        READY = 0
        ENCODING = 1 << 0
        SYSTEM_BUSY = 1 << 1

    @property
    @abstractmethod
    def _base_url(self) -> str:
        """Build the base endpoint for USB commands

        Returns:
            str: base endpoint with URL from serial number
        """

    @property
    @abstractmethod
    def _api(self) -> ApiType:
        """Unique identifier for the connected GoPro Client

        Returns:
            ApiType: identifier
        """

    @staticmethod
    def _ensure_opened(interface: tuple[GoProMessageInterface]) -> Callable:
        """Raise exception if relevant interface is not currently opened

        Args:
            interface (tuple[GoProMessageInterface]): wireless interface to verify

        Returns:
            Callable: Direct pass-through of callable after verification
        """
        return ensure_opened(interface)

    @staticmethod
    def _catch_thread_exception(*args: Any, **kwargs: Any) -> Callable | None:
        """Catch any exceptions from this method and pass them to the exception handler identifier by thread name

        Args:
            *args (Any): positional args
            **kwargs (Any): keyword args

        Returns:
            Callable | None: forwarded return of wrapped method or None if exception occurs
        """
        return catch_thread_exception(*args, **kwargs)

    def _build_http_request_args(self, message: HttpMessage) -> dict[str, Any]:
        """Helper method to build request kwargs from message

        Args:
            message (HttpMessage): message to build args from

        Returns:
            dict[str, Any]: built args
        """
        # Dynamically build get kwargs
        request_args: dict[str, Any] = {}
        if message._headers:
            request_args["headers"] = message._headers
        if message._certificate:
            request_args["verify"] = str(message._certificate)
        return request_args

    @enforce_message_rules
    async def _get_json(
        self, message: HttpMessage, *, timeout: int = HTTP_TIMEOUT, rules: MessageRules = MessageRules(), **kwargs: Any
    ) -> GoProResp:
        url = self._base_url + message.build_url(**kwargs)
        logger.debug(f"Sending:  {url}")
        logger.info(Logger.build_log_tx_str(pretty_print(message._as_dict(**kwargs))))
        for retry in range(1, GoProBase.HTTP_GET_RETRIES + 1):
            try:
                http_response = requests.get(url, timeout=timeout, **self._build_http_request_args(message))
                logger.trace(f"received raw json: {json.dumps(http_response.json() if http_response.text else {}, indent=4)}")  # type: ignore
                if not http_response.ok:
                    logger.warning(f"Received non-success status {http_response.status_code}: {http_response.reason}")
                response = RequestsHttpRespBuilderDirector(http_response, message._parser)()
                break
            except requests.exceptions.ConnectionError as e:
                # This appears to only occur after initial connection after pairing
                logger.warning(repr(e))
                # Back off before retrying. TODO This appears to be needed on MacOS
                await asyncio.sleep(2)
            except Exception as e:  # pylint: disable=broad-exception-caught
                logger.critical(f"Unexpected error: {repr(e)}")
            logger.warning(f"Retrying #{retry} to send the command...")
        else:
            raise GpException.ResponseTimeout(GoProBase.HTTP_GET_RETRIES)

        logger.info(Logger.build_log_rx_str(pretty_print(response._as_dict())))
        return response

    @enforce_message_rules
    async def _get_stream(
        self, message: HttpMessage, *, timeout: int = HTTP_TIMEOUT, rules: MessageRules = MessageRules(), **kwargs: Any
    ) -> GoProResp:
        url = self._base_url + message.build_url(path=kwargs["camera_file"])
        logger.debug(f"Sending:  {url}")
        with requests.get(url, stream=True, timeout=timeout, **self._build_http_request_args(message)) as request:
            request.raise_for_status()
            file = kwargs["local_file"]
            with open(file, "wb") as f:
                logger.debug(f"receiving stream to {file}...")
                for chunk in request.iter_content(chunk_size=8192):
                    f.write(chunk)

        return GoProResp(protocol=GoProResp.Protocol.HTTP, status=ErrorCode.SUCCESS, data=file, identifier=url)

    @enforce_message_rules
    async def _put_json(
        self, message: HttpMessage, *, timeout: int = HTTP_TIMEOUT, rules: MessageRules = MessageRules(), **kwargs: Any
    ) -> GoProResp:
        url = self._base_url + message.build_url(**kwargs)
        body = message.build_body(**kwargs)
        logger.debug(f"Sending:  {url} with body: {json.dumps(body, indent=4)}")
        for retry in range(1, GoProBase.HTTP_GET_RETRIES + 1):
            try:
                http_response = requests.put(url, timeout=timeout, json=body, **self._build_http_request_args(message))
                logger.trace(f"received raw json: {json.dumps(http_response.json() if http_response.text else {}, indent=4)}")  # type: ignore
                if not http_response.ok:
                    logger.warning(f"Received non-success status {http_response.status_code}: {http_response.reason}")
                response = RequestsHttpRespBuilderDirector(http_response, message._parser)()
                break
            except requests.exceptions.ConnectionError as e:
                # This appears to only occur after initial connection after pairing
                logger.warning(repr(e))
                # Back off before retrying. TODO This appears to be needed on MacOS
                await asyncio.sleep(2)
            except Exception as e:  # pylint: disable=broad-exception-caught
                logger.critical(f"Unexpected error: {repr(e)}")
            logger.warning(f"Retrying #{retry} to send the command...")
        else:
            raise GpException.ResponseTimeout(GoProBase.HTTP_GET_RETRIES)

        return response

================
File: demos/python/sdk_wireless_camera_control/open_gopro/gopro_wired.py
================
# gopro.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Wed, Sep  1, 2021  5:05:47 PM

"""Implements top level interface to GoPro module."""

from __future__ import annotations

import asyncio
import logging
from typing import Any, Callable, Final

import open_gopro.exceptions as GpException
import open_gopro.wifi.mdns_scanner  # Imported this way for pytest monkeypatching
from open_gopro.api import (
    BleCommands,
    BleSettings,
    BleStatuses,
    HttpCommands,
    HttpSettings,
    Params,
    WiredApi,
)
from open_gopro.communicator_interface import GoProWiredInterface, Message, MessageRules
from open_gopro.constants import StatusId
from open_gopro.gopro_base import GoProBase
from open_gopro.models import GoProResp
from open_gopro.types import CameraState, UpdateCb, UpdateType

logger = logging.getLogger(__name__)

GET_TIMEOUT: Final = 5
HTTP_GET_RETRIES: Final = 5


class WiredGoPro(GoProBase[WiredApi], GoProWiredInterface):
    """The top-level USB interface to a Wired GoPro device.

    See the `Open GoPro SDK <https://gopro.github.io/OpenGoPro/python_sdk>`_ for complete documentation.

    If a serial number is not passed when instantiating, the mDNS server will be queried to find a connected
    GoPro.

    This class also handles:
        - ensuring camera is ready / not encoding before transferring data

    It can be used via context manager:

    >>> async with WiredGoPro() as gopro:
    >>>     print("Yay! I'm connected via USB, opened, and ready to send / get data now!")
    >>>     # Send some messages now

    Or without:

    >>> gopro = WiredGoPro()
    >>> await gopro.open()
    >>> print("Yay! I'm connected via USB, opened, and ready to send / get data now!")
    >>> # Send some messages now

    Args:
        serial (str | None): (at least) last 3 digits of GoPro Serial number. If not set, first GoPro
            discovered from mDNS will be used. Defaults to None
        **kwargs (Any): additional keyword arguments to pass to base class
    """

    _BASE_IP: Final[str] = "172.2{}.1{}{}.51"
    _BASE_ENDPOINT: Final[str] = "http://{ip}:8080/"
    _MDNS_SERVICE_NAME: Final[str] = "_gopro-web._tcp.local."

    def __init__(self, serial: str | None = None, **kwargs: Any) -> None:
        GoProBase.__init__(self, **kwargs)
        GoProWiredInterface.__init__(self)
        self._serial = serial
        # We currently only support version 2.0
        self._wired_api = WiredApi(self)
        self._open = False
        self._poll_period = kwargs.get("poll_period", 2)
        self._encoding = False
        self._busy = False

    async def open(self, timeout: int = 10, retries: int = 1) -> None:
        """Connect to the Wired GoPro Client and prepare it for communication

        Args:
            timeout (int): time (in seconds) before considering connection a failure. Defaults to 10.
            retries (int): number of connection retries. Defaults to 1.

        # noqa: DAR401

        Raises:
            InvalidOpenGoProVersion: the GoPro camera does not support the correct Open GoPro API version
            FailedToFindDevice: could not auto-discover GoPro via mDNS # noqa: DAR402
        """
        if not self._serial:
            for retry in range(1, retries + 1):
                try:
                    ip_addr = await open_gopro.wifi.mdns_scanner.find_first_ip_addr(
                        WiredGoPro._MDNS_SERVICE_NAME, timeout
                    )
                    self._serial = "GoPro X" + "".join([ip_addr[5], *ip_addr[8:10]])
                    break
                except GpException.FailedToFindDevice as e:
                    if retry == retries:
                        raise e
                    logger.warning(f"Failed to discover GoPro. Retrying #{retry}")

        await self.http_command.wired_usb_control(control=Params.Toggle.ENABLE)
        # Find and configure API version
        if (version := (await self.http_command.get_open_gopro_api_version()).data) != self.version:
            raise GpException.InvalidOpenGoProVersion(version)
        logger.info(f"Using Open GoPro API version {version}")

        # Wait for initial ready state
        await self._wait_for_state({StatusId.ENCODING: False, StatusId.SYSTEM_BUSY: False})

        self._open = True

    async def close(self) -> None:
        """Gracefully close the GoPro Client connection"""

    @property
    async def is_ready(self) -> bool:
        """Is gopro ready to receive commands

        Returns:
            bool: yes if ready, no otherwise
        """
        current_state = (await self.http_command.get_camera_state()).data
        self._encoding = bool(current_state[StatusId.ENCODING])
        self._busy = bool(current_state[StatusId.SYSTEM_BUSY])
        return not (self._encoding or self._busy)

    @property
    def identifier(self) -> str:
        """Unique identifier for the connected GoPro Client

        Raises:
            GoProNotOpened: serial was not passed to instantiation and IP has not yet been discovered

        Returns:
            str: identifier
        """
        if self._serial:
            return self._serial
        raise GpException.GoProNotOpened("IP address has not yet been discovered")

    @property
    def version(self) -> str:
        """The Open GoPro API version of the GoPro Client

        Only Version 2.0 is currently supported.

        Returns:
            str: string version
        """
        return self._api.version

    @property
    def http_command(self) -> HttpCommands:
        """Used to access the USB commands

        Returns:
            HttpCommands: the commands
        """
        return self._api.http_command

    @property
    def http_setting(self) -> HttpSettings:
        """Used to access the USB settings

        Returns:
            HttpSettings: the settings
        """
        return self._api.http_setting

    @property
    def ble_command(self) -> BleCommands:
        """Used to call the BLE commands

        Raises:
            NotImplementedError: Not valid for WiredGoPro
        """
        raise NotImplementedError

    @property
    def ble_setting(self) -> BleSettings:
        """Used to access the BLE settings

        Raises:
            NotImplementedError: Not valid for WiredGoPro
        """
        raise NotImplementedError

    @property
    def ble_status(self) -> BleStatuses:
        """Used to access the BLE statuses

        Raises:
            NotImplementedError: Not valid for WiredGoPro
        """
        raise NotImplementedError

    @property
    def is_open(self) -> bool:
        """Is this client ready for communication?

        Returns:
            bool: True if yes, False if no
        """
        return self._open

    @property
    def is_ble_connected(self) -> bool:
        """Are we connected via BLE to the GoPro device?

        Returns:
            bool: True if yes, False if no
        """
        return False

    @property
    def is_http_connected(self) -> bool:
        """Are we connected via Wifi to the GoPro device?

        Returns:
            bool: True if yes, False if no
        """
        return self.is_open

    def register_update(self, callback: UpdateCb, update: UpdateType) -> None:
        """Register for callbacks when an update occurs

        Args:
            callback (UpdateCb): callback to be notified in
            update (UpdateType): update to register for

        Raises:
            NotImplementedError: not yet possible
        """
        raise NotImplementedError

    def unregister_update(self, callback: UpdateCb, update: UpdateType | None = None) -> None:
        """Unregister for asynchronous update(s)

        Args:
            callback (UpdateCb): callback to stop receiving update(s) on
            update (UpdateType | None): updates to unsubscribe for. Defaults to None (all
                updates that use this callback will be unsubscribed).

        Raises:
            NotImplementedError: not yet possible
        """
        raise NotImplementedError

    async def configure_cohn(self, timeout: int = 60) -> bool:
        """Prepare Camera on the Home Network

        Provision if not provisioned
        Then wait for COHN to be connected and ready

        Args:
            timeout (int): time in seconds to wait for COHN to be ready. Defaults to 60.

        Returns:
            bool: True if success, False otherwise

        Raises:
            NotImplementedError: not yet possible
        """
        raise NotImplementedError

    @property
    async def is_cohn_provisioned(self) -> bool:
        """Is COHN currently provisioned?

        Get the current COHN status from the camera

        Returns:
            bool: True if COHN is provisioned, False otherwise

        Raises:
            NotImplementedError: not yet possible
        """
        raise NotImplementedError

    ##########################################################################################################
    #                                 End Public API
    ##########################################################################################################

    async def _enforce_message_rules(
        self, wrapped: Callable, message: Message, rules: MessageRules = MessageRules(), **kwargs: Any
    ) -> GoProResp:
        # Acquire ready lock unless we are initializing or this is a Set Shutter Off command
        if self._should_maintain_state and self.is_open and not rules.is_fastpass(**kwargs):
            # Wait for not encoding and not busy
            logger.trace("Waiting for camera to be ready to receive messages.")  # type: ignore
            await self._wait_for_state({StatusId.ENCODING: False, StatusId.SYSTEM_BUSY: False})
            logger.trace("Camera is ready to receive messages")  # type: ignore
            response = await wrapped(message, **kwargs)
        else:  # Either we're not maintaining state, we're not opened yet, or this is a fastpass message
            response = await wrapped(message, **kwargs)

        # Release the lock if we acquired it
        if self._should_maintain_state:
            if response.ok:
                # Is there any special handling required after receiving the response?
                if rules.should_wait_for_encoding_start(**kwargs):
                    logger.trace("Waiting to receive encoding started.")  # type: ignore
                    # Wait for encoding to start
                    await self._wait_for_state({StatusId.ENCODING: True})
        return response

    async def _wait_for_state(self, check: CameraState) -> None:
        """Poll the current state until a variable amount of states are all equal to desired values

        Args:
            check (CameraState): dict{setting / status: value} of settings / statuses and values to wait for
        """
        while True:
            state = (await self.http_command.get_camera_state()).data
            for key, value in check.items():
                if state.get(key) != value:
                    logger.trace(f"Not ready ==> {key} != {value}")  # type: ignore
                    await asyncio.sleep(self._poll_period)
                    break  # Get new state and try again
            else:
                return  # Everything matches. Exit

    @property
    def _api(self) -> WiredApi:
        return self._wired_api

    @property
    def _base_url(self) -> str:
        """Build the base endpoint for USB commands

        Raises:
            GoProNotOpened: The GoPro serial has not yet been set / discovered

        Returns:
            str: base endpoint with URL from serial number
        """
        if not self._serial:
            raise GpException.GoProNotOpened("Serial / IP has not yet been discovered")
        return WiredGoPro._BASE_ENDPOINT.format(ip=WiredGoPro._BASE_IP.format(*self._serial[-3:]))

================
File: demos/python/sdk_wireless_camera_control/open_gopro/gopro_wireless.py
================
# gopro.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Wed, Sep  1, 2021  5:05:47 PM

"""Implements top level interface to GoPro module."""

from __future__ import annotations

import asyncio
import enum
import logging
import queue
from collections import defaultdict
from copy import deepcopy
from typing import Any, Callable, Final, Pattern

import open_gopro.exceptions as GpException
from open_gopro import proto
from open_gopro.api import (
    BleCommands,
    BleSettings,
    BleStatuses,
    HttpCommands,
    HttpSettings,
    Params,
    WirelessApi,
)
from open_gopro.ble import BleakWrapperController, BleUUID
from open_gopro.communicator_interface import (
    BleMessage,
    GoProWirelessInterface,
    HttpMessage,
    Message,
    MessageRules,
)
from open_gopro.constants import ActionId, GoProUUIDs, StatusId
from open_gopro.gopro_base import (
    GoProBase,
    GoProMessageInterface,
    enforce_message_rules,
)
from open_gopro.logger import Logger
from open_gopro.models.general import CohnInfo
from open_gopro.models.response import BleRespBuilder, GoProResp
from open_gopro.types import ResponseType, UpdateCb, UpdateType
from open_gopro.util import SnapshotQueue, get_current_dst_aware_time, pretty_print
from open_gopro.wifi import WifiCli

logger = logging.getLogger(__name__)

KEEP_ALIVE_INTERVAL: Final = 28


class WirelessGoPro(GoProBase[WirelessApi], GoProWirelessInterface):
    """The top-level BLE and Wifi interface to a Wireless GoPro device.

    See the `Open GoPro SDK <https://gopro.github.io/OpenGoPro/python_sdk>`_ for complete documentation.

    This will handle, for BLE:

    - discovering target GoPro device
    - establishing the connection
    - discovering GATT characteristics
    - enabling notifications
    - discovering Open GoPro version
    - setting the date, time, timezone, and DST
    - transferring data

    This will handle, for Wifi:

    - finding SSID and password
    - establishing Wifi connection
    - transferring data

    It will also do some synchronization, etc:

    - ensuring camera is ready / not encoding before transferring data
    - sending keep alive signal periodically

    If no target arg is passed in, the first discovered BLE GoPro device will be connected to.

    It can be used via context manager:

    >>> async with WirelessGoPro() as gopro:
    >>>     print("Yay! I'm connected via BLE, Wifi, opened, and ready to send / get data now!")
    >>>     # Send some messages now

    Or without:

    >>> gopro = WirelessGoPro()
    >>> await gopro.open()
    >>> print("Yay! I'm connected via BLE, Wifi, opened, and ready to send / get data now!")
    >>> # Send some messages now

    Args:
        target (Pattern | None): A regex to search for the target GoPro's name. For example, "GoPro 0456").
            Defaults to None (i.e. connect to first discovered GoPro)
        wifi_interface (str | None): Set to specify the wifi interface the local machine will use to connect
            to the GoPro. If None (or not set), first discovered interface will be used.
        sudo_password (str | None): User password for sudo. If not passed, you will be prompted if a password
            is needed which should only happen on Nix systems.
        enable_wifi (bool): Optionally do not enable Wifi if set to False. Defaults to True.
        **kwargs (Any): additional parameters for internal use / testing

    # noqa: DAR401

    Raises:
        InterfaceConfigFailure: In order to communicate via Wifi, there must be an available # noqa: DAR402
            Wifi Interface. By default during initialization, the Wifi driver will attempt to automatically
            discover such an interface. If it does not find any, it will raise this exception. Note that
            the interface can also be specified manually with the 'wifi_interface' argument.
    """

    WRITE_TIMEOUT: Final = 5

    class _LockOwner(enum.Enum):
        """Current owner of the communication lock"""

        RULE_ENFORCER = enum.auto()
        STATE_MANAGER = enum.auto()

    def __init__(
        self,
        target: Pattern | None = None,
        wifi_interface: str | None = None,
        sudo_password: str | None = None,
        enable_wifi: bool = True,
        **kwargs: Any,
    ) -> None:
        GoProBase.__init__(self, **kwargs)
        # Store initialization information
        self._should_enable_wifi = enable_wifi
        ble_adapter = kwargs.get("ble_adapter", BleakWrapperController)
        wifi_adapter = kwargs.get("wifi_adapter", WifiCli)
        # Set up API delegate
        self._wireless_api = WirelessApi(self)

        try:
            # Initialize GoPro Communication Client
            GoProWirelessInterface.__init__(
                self,
                ble_controller=ble_adapter(self._handle_exception),
                wifi_controller=wifi_adapter(wifi_interface, password=sudo_password) if enable_wifi else None,
                disconnected_cb=self._disconnect_handler,
                notification_cb=self._notification_handler,
                target=target,
            )
        except GpException.InterfaceConfigFailure as e:
            logger.error(
                "Could not find a suitable Wifi Interface. If there is an available Wifi interface, try passing it manually with the 'wifi_interface' argument."
            )
            raise e

        # Builders for currently accumulating synchronous responses, indexed by GoProUUIDs. This assumes there
        # can only be one active response per BleUUID
        self._active_builders: dict[BleUUID, BleRespBuilder] = {}
        # Responses that we are waiting for.
        self._sync_resp_wait_q: SnapshotQueue[ResponseType] = SnapshotQueue()
        # Synchronous response that has been parsed and are ready for their sender to receive as the response.
        self._sync_resp_ready_q: SnapshotQueue[GoProResp] = SnapshotQueue()

        self._listeners: dict[UpdateType, set[UpdateCb]] = defaultdict(set)

        # TO be set up when opening in async context
        self._loop: asyncio.AbstractEventLoop
        self._open = False
        self._ble_disconnect_event: asyncio.Event

        if self._should_maintain_state:
            self._state_tasks: list[asyncio.Task] = []
            self._lock_owner: WirelessGoPro._LockOwner | None = WirelessGoPro._LockOwner.STATE_MANAGER
            self._ready_lock: asyncio.Lock
            self._keep_alive_task: asyncio.Task
            self._encoding: bool
            self._busy: bool
            self._encoding_started: asyncio.Event

        self._cohn: CohnInfo | None = None

    @property
    def identifier(self) -> str:
        """Get a unique identifier for this instance.

        The identifier is the last 4 digits of the camera. That is, the same string that is used to
        scan for the camera for BLE.

        If no target has been provided and a camera is not yet found, this will be None

        Raises:
            GoProNotOpened: Client is not opened yet so no identifier is available

        Returns:
            str: last 4 digits if available, else None
        """
        if self._ble.identifier is None:
            raise GpException.GoProNotOpened("Client does not yet have an identifier.")
        return self._ble.identifier

    @property
    def is_ble_connected(self) -> bool:
        """Are we connected via BLE to the GoPro device?

        Returns:
            bool: True if yes, False if no
        """
        return self._ble.is_connected

    @property
    def is_http_connected(self) -> bool:
        """Are we connected via HTTP to the GoPro device?

        Returns:
            bool: True if yes, False if no
        """
        try:
            return bool(self._cohn) or self._wifi.is_connected
        except AttributeError:
            return False

    @property
    def ble_command(self) -> BleCommands:
        """Used to call the BLE commands

        Returns:
            BleCommands: the commands
        """
        return self._api.ble_command

    @property
    def ble_setting(self) -> BleSettings:
        """Used to access the BLE settings

        Returns:
            BleSettings: the settings
        """
        return self._api.ble_setting

    @property
    def ble_status(self) -> BleStatuses:
        """Used to access the BLE statuses

        Returns:
            BleStatuses: the statuses
        """
        return self._api.ble_status

    @property
    def http_command(self) -> HttpCommands:
        """Used to access the Wifi commands

        Returns:
            HttpCommands: the commands
        """
        return self._api.http_command

    @property
    def http_setting(self) -> HttpSettings:
        """Used to access the Wifi settings

        Returns:
            HttpSettings: the settings
        """
        return self._api.http_setting

    async def open(self, timeout: int = 15, retries: int = 5) -> None:
        """Perform all initialization commands for ble and wifi

        For BLE: scan and find device, establish connection, discover characteristics, configure queries
        start maintenance, and get Open GoPro version..

        For Wifi: discover SSID and password, enable and connect. Or disable if not using.

        Raises:
            Exception: Any exceptions during opening are propagated through
            InvalidOpenGoProVersion: Only 2.0 is supported

        Args:
            timeout (int): How long to wait for each connection before timing out. Defaults to 10.
            retries (int): How many connection attempts before considering connection failed. Defaults to 5.
        """
        # Set up concurrency
        self._loop = asyncio.get_running_loop()
        self._open = False
        self._ble_disconnect_event = asyncio.Event()

        # If we are to perform BLE housekeeping
        if self._should_maintain_state:
            self._ready_lock = asyncio.Lock()
            self._keep_alive_task = asyncio.create_task(self._periodic_keep_alive())
            self._encoding = True
            self._busy = True
            self._encoding_started = asyncio.Event()

        try:
            await self._open_ble(timeout, retries)

            # Set current dst-aware time. Don't assert on success since some old cameras don't support this command.
            await self.ble_command.set_date_time_tz_dst(
                **dict(zip(("date_time", "tz_offset", "is_dst"), get_current_dst_aware_time()))
            )

            # Find and configure API version
            version = (await self.ble_command.get_open_gopro_api_version()).data
            if version != self.version:
                raise GpException.InvalidOpenGoProVersion(version)
            logger.info(f"Using Open GoPro API version {version}")

            # Establish Wifi connection if desired
            if self._should_enable_wifi:
                await self._open_wifi(timeout, retries)
            else:
                # Otherwise, turn off Wifi
                logger.info("Turning off the camera's Wifi radio")
                await self.ble_command.enable_wifi_ap(enable=False)
            self._open = True

        except Exception as e:
            logger.error(f"Error while opening: {e}")
            await self.close()
            raise e

    async def close(self) -> None:
        """Safely stop the GoPro instance.

        This will disconnect BLE and WiFI if applicable.

        If not using the context manager, it is mandatory to call this before exiting the program in order to
        prevent reconnection issues because the OS has never disconnected from the previous session.
        """
        await self._close_wifi()
        await self._close_ble()
        self._open = False

    def register_update(self, callback: UpdateCb, update: UpdateType) -> None:
        """Register for callbacks when an update occurs

        Args:
            callback (UpdateCb): callback to be notified in
            update (UpdateType): update to register for
        """
        self._listeners[update].add(callback)

    def unregister_update(self, callback: UpdateCb, update: UpdateType | None = None) -> None:
        """Unregister for asynchronous update(s)

        Args:
            callback (UpdateCb): callback to stop receiving update(s) on
            update (UpdateType | None): updates to unsubscribe for. Defaults to None (all
                updates that use this callback will be unsubscribed).
        """
        if update:
            self._listeners.get(update, set()).remove(callback)
        else:
            # If update was not specified, remove all uses of callback
            for key in dict(self._listeners).keys():
                try:
                    self._listeners[key].remove(callback)
                except KeyError:
                    continue

    @property
    def is_open(self) -> bool:
        """Is this client ready for communication?

        Returns:
            bool: True if yes, False if no
        """
        return self._open

    @property
    async def is_ready(self) -> bool:
        """Is gopro ready to receive commands

        Returns:
            bool: yes if ready, no otherwise
        """
        return not (self._busy or self._encoding)

    ##########################################################################################################
    #### Abstracted commands

    # TODO move these into delegate / mixin?

    # TODO message rules are a mess here. Since these send other commands that need message rules, we deadlock
    # if we try to apply message rules to these

    async def _provision_cohn(self, timeout: int) -> bool:
        """Provision the camera for Camera on the Home Network

        Args:
            timeout (int): time in seconds to wait for provisioning success

        Returns:
            bool: True if success, False otherwise
        """
        logger.info("Provisioning COHN")
        provisioned = asyncio.Event()

        async def wait_for_cohn_provisioned(_: Any, status: proto.NotifyCOHNStatus) -> None:
            if status.enabled is True:
                provisioned.set()

        self.register_update(wait_for_cohn_provisioned, ActionId.RESPONSE_GET_COHN_STATUS)
        # ALways override. Assume if we're here, we are purposely (re)configuring COHN
        assert (await self.ble_command.cohn_create_certificate(override=True)).ok
        try:
            logger.debug("Waiting for COHN to provision")
            await self.ble_command.cohn_get_status(register=True)
            await asyncio.wait_for(provisioned.wait(), timeout)
            logger.info("COHN is provisioned!!")
            return True
        except TimeoutError:
            return False

    # TODO allow cohn_info to be passed in
    # TODO validate if network is connected if COHN needs to be configured
    @GoProBase._ensure_opened((GoProMessageInterface.BLE,))
    async def configure_cohn(self, timeout: int = 60) -> bool:
        """Prepare Camera on the Home Network

        Provision if not provisioned
        Then wait for COHN to be connected and ready

        Args:
            timeout (int): time in seconds to wait for COHN to be ready. Defaults to 60.

        Returns:
            bool: True if success, False otherwise
        """
        status = (await self.ble_command.cohn_get_status(register=False)).data
        # We need to provision if nor currently provisioned
        if not status.enabled:
            assert await self._provision_cohn(timeout)

        credentials: asyncio.Queue[tuple[str, str]] = asyncio.Queue()

        async def wait_for_cohn_ready(_: Any, status: proto.NotifyCOHNStatus) -> None:
            if status.state == proto.EnumCOHNNetworkState.COHN_STATE_NetworkConnected:
                await credentials.put((status.ipaddress, status.password))

        # Now we need to wait for COHN to be ready
        try:
            self.register_update(wait_for_cohn_ready, ActionId.RESPONSE_GET_COHN_STATUS)
            logger.info("Waiting for COHN to be connected")
            await self.ble_command.cohn_get_status(register=True)
            ip_address, password = await asyncio.wait_for(credentials.get(), timeout)
            cert = (await self.ble_command.cohn_get_certificate()).data.cert
            self._cohn = CohnInfo(ip_address, "gopro", password, cert)
            logger.info(f"Using COHN Credentials: {self._cohn}")
            return True
        except TimeoutError:
            return False

    @property
    async def is_cohn_provisioned(self) -> bool:
        """Is COHN currently provisioned?

        Get the current COHN status from the camera

        Returns:
            bool: True if COHN is provisioned, False otherwise
        """
        return (await self.ble_command.cohn_get_status(register=False)).data.enabled

    @GoProBase._ensure_opened((GoProMessageInterface.BLE,))
    async def keep_alive(self) -> bool:
        """Send a heartbeat to prevent the BLE connection from dropping.

        This is sent automatically by the GoPro instance if its `maintain_ble` argument is not False.

        Returns:
            bool: True if it succeeded,. False otherwise
        """
        return (await self.ble_setting.led.set(Params.LED.BLE_KEEP_ALIVE)).ok

    @GoProBase._ensure_opened((GoProMessageInterface.BLE,))
    async def connect_to_access_point(self, ssid: str, password: str) -> bool:
        """Connect the camera to a Wifi Access Point

        Args:
            ssid (str): SSID of AP
            password (str): password of AP

        Returns:
            bool: True if AP is currently connected, False otherwise
        """
        scan_result: asyncio.Queue[proto.NotifStartScanning] = asyncio.Queue()
        provisioned_result: asyncio.Queue[proto.NotifProvisioningState] = asyncio.Queue()

        async def wait_for_scan(_: Any, result: proto.NotifStartScanning) -> None:
            await scan_result.put(result)

        async def wait_for_provisioning(_: Any, result: proto.NotifProvisioningState) -> None:
            await provisioned_result.put(result)

        # Wait to receive scanning success
        logger.info("Scanning for Wifi networks")
        self.register_update(wait_for_scan, ActionId.NOTIF_START_SCAN)
        await self.ble_command.scan_wifi_networks()
        if (sresult := await scan_result.get()).scanning_state != proto.EnumScanning.SCANNING_SUCCESS:
            logger.error(f"Scan failed: {str(sresult.scanning_state)}")
            return False
        scan_id = sresult.scan_id
        self.unregister_update(wait_for_scan)

        # Get scan results and see if we need to provision
        for entry in (await self.ble_command.get_ap_entries(scan_id=scan_id)).data.entries:
            if entry.ssid == ssid:
                self.register_update(wait_for_provisioning, ActionId.NOTIF_PROVIS_STATE)
                # Are we already provisioned?
                if entry.scan_entry_flags & proto.EnumScanEntryFlags.SCAN_FLAG_CONFIGURED:
                    logger.info(f"Connecting to already provisioned network {ssid}...")
                    await self.ble_command.request_wifi_connect(ssid=ssid)
                else:
                    logger.info(f"Provisioning new network {ssid}...")
                    await self.ble_command.request_wifi_connect_new(ssid=ssid, password=password)
                if (
                    presult := (await provisioned_result.get())
                ).provisioning_state != proto.EnumProvisioning.PROVISIONING_SUCCESS_NEW_AP:
                    logger.error(f"Provision failed: {str(presult.provisioning_state)}")
                    return False
                self.unregister_update(wait_for_provisioning)
                logger.info(f"Successfully connected to {ssid}")
                return True
        logger.error(f"Could not find ssid {ssid}")
        return False

    ##########################################################################################################
    #                                 End Public API
    ##########################################################################################################

    async def _enforce_message_rules(
        self, wrapped: Callable, message: Message, rules: MessageRules = MessageRules(), **kwargs: Any
    ) -> GoProResp:
        # Acquire ready lock unless we are initializing or this is a Set Shutter Off command
        if self._should_maintain_state and self.is_open and not rules.is_fastpass(**kwargs):
            logger.trace(f"{wrapped.__name__} acquiring lock")  # type: ignore
            await self._ready_lock.acquire()
            logger.trace(f"{wrapped.__name__} has the lock")  # type: ignore
            self._lock_owner = WirelessGoPro._LockOwner.RULE_ENFORCER
            response = await wrapped(message, **kwargs)
        else:  # Either we're not maintaining state, we're not opened yet, or this is a fastpass message
            response = await wrapped(message, **kwargs)

        # Release the lock if we acquired it
        if self._should_maintain_state:
            if self._lock_owner is WirelessGoPro._LockOwner.RULE_ENFORCER:
                logger.trace(f"{wrapped.__name__} releasing the lock")  # type: ignore
                self._lock_owner = None
                self._ready_lock.release()
                logger.trace(f"{wrapped.__name__} released the lock")  # type: ignore
            # Is there any special handling required after receiving the response?
            if rules.should_wait_for_encoding_start(**kwargs):
                logger.trace("Waiting to receive encoding started.")  # type: ignore
                await self._encoding_started.wait()
                self._encoding_started.clear()
        return response

    async def _notify_listeners(self, update: UpdateType, value: Any) -> None:
        """Notify all registered listeners of this update

        Args:
            update (UpdateType): update to notify
            value (Any): value to notify
        """
        for listener in self._listeners.get(update, []):
            await listener(update, value)

    async def _periodic_keep_alive(self) -> None:
        """Task to periodically send the keep alive message via BLE."""
        while True:
            await asyncio.sleep(KEEP_ALIVE_INTERVAL)
            if self.is_ble_connected:
                await self.keep_alive()

    async def _open_ble(self, timeout: int = 10, retries: int = 5) -> None:
        """Connect the instance to a device via BLE.

        Args:
            timeout (int): Time in seconds before considering establishment failed. Defaults to 10 seconds.
            retries (int): How many tries to reconnect after failures. Defaults to 5.
        """
        # Establish connection, pair, etc.
        await self._ble.open(timeout, retries)
        # Start state maintenance
        if self._should_maintain_state:
            await self._ready_lock.acquire()
            encoding = (await self.ble_status.encoding_active.register_value_update(self._update_internal_state)).data
            await self._update_internal_state(StatusId.ENCODING, encoding)
            busy = (await self.ble_status.system_busy.register_value_update(self._update_internal_state)).data
            await self._update_internal_state(StatusId.SYSTEM_BUSY, busy)
        logger.info("BLE is ready!")

    async def _update_internal_state(self, update: UpdateType, value: int) -> None:
        """Update the internal state based on a status update.

        # Note!!! This needs to be reentrant-safe

        Used to update encoding and / or busy status

        Args:
            update (UpdateType): type of update (status ID)
            value (int): updated value
        """
        # Cancel any currently pending state update tasks
        for task in self._state_tasks:
            logger.trace("Cancelling pending acquire task.")  # type: ignore
            task.cancel()
        self._state_tasks = []

        logger.trace(f"State update received {update.name} ==> {value}")  # type: ignore
        should_notify_encoding = False
        if update == StatusId.ENCODING:
            self._encoding = bool(value)
            if self._encoding:
                should_notify_encoding = True
        elif update == StatusId.SYSTEM_BUSY:
            self._busy = bool(value)
        logger.trace(f"Current internal states: {self._encoding=} {self._busy=}")  # type: ignore

        if self._lock_owner is WirelessGoPro._LockOwner.STATE_MANAGER and await self.is_ready:
            logger.trace("Control releasing lock")  # type: ignore
            self._lock_owner = None
            self._ready_lock.release()
            logger.trace("Control released lock")  # type: ignore
        elif not (self._lock_owner is WirelessGoPro._LockOwner.STATE_MANAGER) and not await self.is_ready:
            logger.trace("Control acquiring lock")  # type: ignore
            task = asyncio.create_task(self._ready_lock.acquire())
            self._state_tasks.append(task)
            await task
            logger.trace("Control has lock")  # type: ignore
            self._lock_owner = WirelessGoPro._LockOwner.STATE_MANAGER

        if should_notify_encoding and self.is_open:
            logger.trace("Control setting encoded started")  # type: ignore
            self._encoding_started.set()

    async def _route_response(self, response: GoProResp) -> None:
        """After parsing response, route it to any stakeholders (such as registered listeners)

        Args:
            response (GoProResp): parsed response to route
        """
        original_response = deepcopy(response)
        # We only support queries for either one ID or all ID's. If this is an individual query, extract the value
        # for cleaner response data
        if response._is_query and not response._is_push and len(response.data) == 1:
            response.data = list(response.data.values())[0]

        # Check if this is the awaited synchronous response (id matches). Note! these have to come in order.
        if await self._sync_resp_wait_q.peek_front() == response.identifier:
            logger.info(Logger.build_log_rx_str(original_response, asynchronous=False))
            # Dequeue it and put this on the ready queue
            await self._sync_resp_wait_q.get()
            await self._sync_resp_ready_q.put(response)
        # If this wasn't the awaited synchronous response...
        else:
            logger.info(Logger.build_log_rx_str(original_response, asynchronous=True))
        if response._is_push:
            for update_id, value in response.data.items():
                await self._notify_listeners(update_id, value)
        elif isinstance(response.identifier, ActionId):
            await self._notify_listeners(response.identifier, response.data)

    def _notification_handler(self, handle: int, data: bytearray) -> None:
        """Receive notifications from the BLE controller.

        Args:
            handle (int): Attribute handle that notification was received on.
            data (bytearray): Bytestream that was received.
        """

        async def _async_notification_handler() -> None:
            # Responses we don't care about. For now, just the BLE-spec defined battery characteristic
            if (uuid := self._ble.gatt_db.handle2uuid(handle)) == GoProUUIDs.BATT_LEVEL:
                return
            logger.debug(f'Received response on BleUUID [{uuid}]: {data.hex(":")}')
            # Add to response dict if not already there
            if uuid not in self._active_builders:
                builder = BleRespBuilder()
                builder.set_uuid(uuid)
                self._active_builders[uuid] = builder
            # Accumulate the packet
            self._active_builders[uuid].accumulate(data)
            if (builder := self._active_builders[uuid]).is_finished_accumulating:
                logger.trace(f"Finished accumulating on {uuid}")  # type: ignore
                # Clear active response from response dict
                del self._active_builders[uuid]
                await self._route_response(builder.build())

        asyncio.run_coroutine_threadsafe(_async_notification_handler(), self._loop)

    async def _close_ble(self) -> None:
        """Terminate BLE connection if it is connected"""
        if self.is_ble_connected and self._ble is not None:
            if self._should_maintain_state:
                self._keep_alive_task.cancel()
            await self._ble.close()
            await self._ble_disconnect_event.wait()
            # TODO this event is never cleared since this object is not designed to be re-opened.

    def _disconnect_handler(self, _: Any) -> None:
        """Disconnect callback from BLE controller

        Raises:
            ConnectionTerminated: We entered this callback in an unexpected state.
        """
        if self._ble_disconnect_event.is_set():
            raise GpException.ConnectionTerminated("BLE connection terminated unexpectedly.")
        self._ble_disconnect_event.set()

    @GoProBase._ensure_opened((GoProMessageInterface.BLE,))
    @enforce_message_rules
    async def _send_ble_message(
        self, message: BleMessage, rules: MessageRules = MessageRules(), **kwargs: Any
    ) -> GoProResp:
        # Store information on the response we are expecting
        await self._sync_resp_wait_q.put(message._identifier)
        logger.info(Logger.build_log_tx_str(pretty_print(message._as_dict(**kwargs))))

        # Fragment data and write it
        for packet in self._fragment(message._build_data(**kwargs)):
            logger.debug(f"Writing to [{message._uuid.name}] UUID: {packet.hex(':')}")
            await self._ble.write(message._uuid, packet)

        # Wait to be notified that response was received
        try:
            response = await asyncio.wait_for(self._sync_resp_ready_q.get(), WirelessGoPro.WRITE_TIMEOUT)
        except queue.Empty as e:
            logger.error(f"Response timeout of {WirelessGoPro.WRITE_TIMEOUT} seconds!")
            raise GpException.ResponseTimeout(WirelessGoPro.WRITE_TIMEOUT) from e

        # Check status
        if not response.ok:
            logger.warning(f"Received non-success status: {response.status}")

        return response

    @GoProBase._ensure_opened((GoProMessageInterface.BLE,))
    @enforce_message_rules
    async def _read_ble_characteristic(
        self, message: BleMessage, rules: MessageRules = MessageRules(), **kwargs: Any
    ) -> GoProResp:
        received_data = await self._ble.read(message._uuid)
        logger.debug(f"Reading from {message._uuid.name}")
        builder = BleRespBuilder()
        builder.set_uuid(message._uuid)
        builder.set_packet(received_data)
        return builder.build()

    # TODO make decorator?
    def _handle_cohn(self, message: HttpMessage) -> HttpMessage:
        """Prepend COHN headers if COHN is enabled

        Args:
            message (HttpMessage): HTTP message to append headers to

        Returns:
            HttpMessage: potentially modified HTTP message
        """
        if self._cohn:
            message._headers["Authorization"] = self._cohn.auth_token
            message._certificate = self._cohn.cert_path
        return message

    async def _get_json(self, message: HttpMessage, *args: Any, **kwargs: Any) -> GoProResp:
        message = self._handle_cohn(message)
        return await super()._get_json(*args, message=message, **kwargs)

    async def _get_stream(self, message: HttpMessage, *args: Any, **kwargs: Any) -> GoProResp:
        message = self._handle_cohn(message)
        return await super()._get_stream(*args, message=message, **kwargs)

    async def _put_json(self, message: HttpMessage, *args: Any, **kwargs: Any) -> GoProResp:
        message = self._handle_cohn(message)
        return await super()._put_json(*args, message=message, **kwargs)

    @GoProBase._ensure_opened((GoProMessageInterface.BLE,))
    async def _open_wifi(self, timeout: int = 30, retries: int = 5) -> None:
        """Connect to a GoPro device via Wifi.

        Args:
            timeout (int): Time before considering establishment failed. Defaults to 10 seconds.
            retries (int): How many tries to reconnect after failures. Defaults to 5.

        Raises:
            ConnectFailed: Was not able to establish the Wifi Connection
        """
        logger.info("Discovering Wifi AP info and enabling via BLE")
        password = (await self.ble_command.get_wifi_password()).data
        ssid = (await self.ble_command.get_wifi_ssid()).data
        for retry in range(1, retries):
            try:
                assert (await self.ble_command.enable_wifi_ap(enable=True)).ok
                self._wifi.open(ssid, password, timeout, 1)
                break
            except GpException.ConnectFailed:
                logger.warning(f"Wifi connection failed. Retrying #{retry}")
                # In case camera Wifi is in strange disable, reset it
                assert (await self.ble_command.enable_wifi_ap(enable=False)).ok
        else:
            raise GpException.ConnectFailed("Wifi Connection failed", timeout, retries)

    async def _close_wifi(self) -> None:
        """Terminate the Wifi connection."""
        if hasattr(self, "_wifi"):  # Corner case where instantiation fails before superclass is initialized
            self._wifi.close()

    @property
    def _base_url(self) -> str:
        return f"https://{self._cohn.ip_address}/" if self._cohn else "http://10.5.5.9:8080/"

    @property
    def _api(self) -> WirelessApi:
        return self._wireless_api

================
File: demos/python/sdk_wireless_camera_control/open_gopro/logger.py
================
# logger.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Thu Aug 24 17:08:14 UTC 2023

"""Logger abstraction above default python logging"""

from __future__ import annotations

import http.client as http_client
import logging
from pathlib import Path
from typing import Any, Final

from rich import traceback
from rich.logging import RichHandler


class Logger:
    """A singleton class to manage logging for the Open GoPro internal modules

    Args:
        logger (logging.Logger): input logger that will be modified and then returned
        output (Path | None): Path of log file for file stream handler. If not set, will not log to file.
        modules (list[str] | None): Optional override of modules / levels. Will be merged into default modules.
    """

    _instances: dict[type[Logger], Logger] = {}
    ARROW_HEAD_COUNT: Final = 8
    ARROW_TAIL_COUNT: Final = 14

    def __new__(cls, *_: Any) -> Any:  # noqa https://github.com/PyCQA/pydocstyle/issues/515
        if cls not in cls._instances:
            c = object.__new__(cls)
            cls._instances[cls] = c
            return c
        raise RuntimeError("The logger can only be setup once and this should be done at the top level.")

    def __init__(
        self,
        logger: logging.Logger,
        output: Path | None = None,
        modules: list[str] | None = None,
    ) -> None:
        self.modules = [
            "open_gopro.gopro_base",
            "open_gopro.gopro_wired",
            "open_gopro.gopro_wireless",
            "open_gopro.api.builders",
            "open_gopro.api.parsers",
            "open_gopro.api.http_commands",
            "open_gopro.api.ble_commands",
            "open_gopro.communicator_interface",
            "open_gopro.ble.adapters.bleak_wrapper",
            "open_gopro.ble.client",
            "open_gopro.wifi.adapters.wireless",
            "open_gopro.wifi.mdns_scanner",
            "open_gopro.models.response",
            "open_gopro.util",
            "bleak",
            "urllib3",
            "http.client",
        ]

        self.logger = logger
        self.modules = modules or self.modules
        self.handlers: list[logging.Handler] = []

        # monkey-patch a `print` global into the http.client module; all calls to
        # print() in that module will then use our logger's debug method
        http_client.HTTPConnection.debuglevel = 1
        http_client.print = lambda *args: logging.getLogger("http.client").debug(" ".join(args))  # type: ignore

        self.file_handler: logging.Handler | None
        if output:
            # Logging to file with millisecond timing
            self.file_handler = logging.FileHandler(output, mode="w")
            file_formatter = logging.Formatter(
                fmt="%(threadName)13s:%(asctime)s.%(msecs)03d %(filename)-40s %(lineno)4s %(levelname)-8s | %(message)s",
                datefmt="%H:%M:%S",
            )
            self.file_handler.setFormatter(file_formatter)
            # Set to TRACE for concurrency debugging
            self.file_handler.setLevel(logging.DEBUG)
            logger.addHandler(self.file_handler)
            self.addLoggingHandler(self.file_handler)
        else:
            self.file_handler = None

        # Use Rich for colorful console logging
        self.stream_handler = RichHandler(rich_tracebacks=True, enable_link_path=True, show_time=False)
        stream_formatter = logging.Formatter("%(asctime)s.%(msecs)03d %(message)s", datefmt="%H:%M:%S")
        self.stream_handler.setFormatter(stream_formatter)
        self.stream_handler.setLevel(logging.INFO)
        logger.addHandler(self.stream_handler)
        self.addLoggingHandler(self.stream_handler)

        self.addLoggingLevel("TRACE", logging.DEBUG - 5)
        logger.setLevel(logging.TRACE)  # type: ignore # pylint: disable=no-member

        traceback.install()  # Enable exception tracebacks in rich logger

    @classmethod
    def get_instance(cls) -> Logger:
        """Get the singleton instance

        Raises:
            RuntimeError: Has not yet been instantiated

        Returns:
            Logger: singleton instance
        """
        if not (logger := cls._instances.get(Logger, None)):
            raise RuntimeError("Logging must first be setup")
        return logger

    def addLoggingHandler(self, handler: logging.Handler) -> None:
        """Add a handler for all of the internal GoPro modules

        Args:
            handler (logging.Handler): handler to add
        """
        self.logger.addHandler(handler)
        self.handlers.append(handler)

        # Enable / disable logging in modules
        for module in self.modules:
            l = logging.getLogger(module)
            l.setLevel(logging.TRACE)  # type: ignore
            l.addHandler(handler)

    # From https://stackoverflow.com/questions/2183233/how-to-add-a-custom-loglevel-to-pythons-logging-facility/35804945#35804945
    @staticmethod
    def addLoggingLevel(levelName: str, levelNum: int) -> None:
        """Comprehensively adds a new logging level to the `logging` module and the currently configured logging class.

        `levelName` becomes an attribute of the `logging` module with the value
        `levelNum`. `methodName` becomes a convenience method for both `logging`
        itself and the class returned by `logging.getLoggerClass()` (usually just
        `logging.Logger`). If `methodName` is not specified, `levelName.lower()` is
        used.

        To avoid accidental clobberings of existing attributes, this method will
        raise an `AttributeError` if the level name is already an attribute of the
        `logging` module or if the method name is already present

        Example:
        --------
        >>> addLoggingLevel('TRACE', logging.DEBUG - 5)
        >>> logging.getLogger(__name__).setLevel("TRACE")
        >>> logging.getLogger(__name__).trace('that worked')
        >>> logging.trace('so did this')
        >>> logging.TRACE
        5

        Args:
            levelName (str): name of level (i.e. TRACE)
            levelNum (int): integer level of new logging level
        """
        methodName = levelName.lower()

        def logForLevel(self: Any, message: str, *args: Any, **kwargs: Any) -> None:
            if self.isEnabledFor(levelNum):
                self._log(levelNum, message, args, **kwargs)

        def logToRoot(message: str, *args: Any, **kwargs: Any) -> None:
            logging.log(levelNum, message, *args, **kwargs)

        logging.addLevelName(levelNum, levelName)
        setattr(logging, levelName, levelNum)
        setattr(logging.getLoggerClass(), methodName, logForLevel)
        setattr(logging, methodName, logToRoot)

    @staticmethod
    def build_log_tx_str(stringable: Any) -> str:
        """Build a string with Tx arrows

        Args:
            stringable (Any): stringable object to surround with arrows

        Returns:
            str: string surrounded by Tx arrows
        """
        s = str(stringable).strip(r"{}")
        arrow = f"{'<'*Logger.ARROW_HEAD_COUNT}{'-'*Logger.ARROW_TAIL_COUNT}"
        return f"\n{arrow}{s}{arrow}\n"

    @staticmethod
    def build_log_rx_str(stringable: Any, asynchronous: bool = False) -> str:
        """Build a string with Rx arrows

        Args:
            stringable (Any): stringable object to surround with arrows
            asynchronous (bool): Should the arrows contain ASYNC?. Defaults to False.

        Returns:
            str: string surrounded by Rx arrows
        """
        s = str(stringable).strip(r"{}")
        assert Logger.ARROW_TAIL_COUNT > 5
        if asynchronous:
            arrow = f"{'-'*(Logger.ARROW_TAIL_COUNT//2-3)}ASYNC{'-'*(Logger.ARROW_TAIL_COUNT//2-2)}{'>'*Logger.ARROW_HEAD_COUNT}"
        else:
            arrow = f"{'-'*Logger.ARROW_TAIL_COUNT}{'>'*Logger.ARROW_HEAD_COUNT}"
        return f"\n{arrow}{s}{arrow}\n"


def setup_logging(
    base: logging.Logger | str,
    output: Path | None = None,
    modules: list[str] | None = None,
) -> logging.Logger:
    """Configure the GoPro modules for logging and get a logger that can be used by the application

    This can only be called once and should be done at the top level of the application.

    Args:
        base (logging.Logger | str): Name of application (i.e. __name__) or preconfigured logger to use as base
        output (Path | None): Path of log file for file stream handler. If not set, will not log to file.
        modules (list[str] | None): Optional override of modules / levels. Will be merged into default modules.

    Raises:
        TypeError: Base logger is not of correct type

    Returns:
        logging.Logger: updated logger that the application can use for logging
    """
    if isinstance(base, str):
        base = logging.getLogger(base)
    elif not isinstance(base, logging.Logger):
        raise TypeError("Base must be of type logging.Logger or str")
    l = Logger(base, output, modules)
    return l.logger


def set_file_logging_level(level: int) -> None:
    """Change the global logging level for the default file output handler

    Args:
        level (int): level to set
    """
    if fh := Logger.get_instance().file_handler:
        fh.setLevel(level)


def set_stream_logging_level(level: int) -> None:
    """Change the global logging level for the default stream output handler

    Args:
        level (int): level to set
    """
    Logger.get_instance().stream_handler.setLevel(level)


def set_logging_level(level: int) -> None:
    """Change the global logging level for the default file and stream output handlers

    Args:
        level (int): level to set
    """
    set_file_logging_level(level)
    set_stream_logging_level(level)


def add_logging_handler(handler: logging.Handler) -> None:
    """Add a handler to all of the GoPro internal modules

    Args:
        handler (logging.Handler): handler to add
    """
    Logger.get_instance().addLoggingHandler(handler)

================
File: demos/python/sdk_wireless_camera_control/open_gopro/parser_interface.py
================
# parsers.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Mon Jun 26 18:26:05 UTC 2023

"""Parser Protocol and Bases"""

from __future__ import annotations

import logging
from abc import ABC, abstractmethod
from collections import defaultdict
from typing import Any, Callable, ClassVar, Generic, Protocol, TypeVar, cast

from open_gopro.constants import ActionId, FeatureId
from open_gopro.types import JsonDict, ResponseType

logger = logging.getLogger(__name__)

T_co = TypeVar("T_co", covariant=True)
T = TypeVar("T")

########################################################################################
####### Transformers
########################################################################################


class BaseTransformer(ABC, Generic[T]):
    """Transformer interface.

    A transformer is something that transforms the input into the same output type
    """

    @abstractmethod
    def transform(self, data: T) -> T:
        """Transform data into output matching the input type

        Args:
            data (T): data to transform

        Returns:
            T: transformed data
        """


class BytesTransformer(BaseTransformer[bytes]):
    """Bytes to Bytes transformer interface"""


class JsonTransformer(BaseTransformer[JsonDict]):
    """Json to json transformer interface"""


########################################################################################
####### Parsers
########################################################################################


class BaseParser(ABC, Generic[T, T_co]):
    """Base Parser Interface

    A parser is something that transforms input into a different type
    """

    @abstractmethod
    def parse(self, data: T) -> T_co:  # pylint: disable=method-hidden
        """Parse data into output type

        Args:
            data (T): input data to parse

        Returns:
            T_co: parsed output
        """


class JsonParser(BaseParser[JsonDict, T_co]):
    """Json to Target Type Parser Interface"""


class BytesParser(BaseParser[bytes, T_co]):
    """Bytes to Target Type Parser Interface"""


class Parser(ABC, Generic[T]):
    """The common monolithic Parser that is used for all byte and json parsing / transforming

    Algorithm is:
        1. Variable number of byte transformers (bytes --> bytes)
        2. One bytes Json adapter (bytes --> json)
        3. Variable number of json transformers (json --> json)
        4. One JSON parser (json -> Any)

    Args:
        byte_transformers (list[BytesTransformer] | None): bytes --> bytes. Defaults to None.
        byte_json_adapter (BytesParser[JsonDict] | None): bytes --> json. Defaults to None.
        json_transformers (list[JsonTransformer] | None): json --> json. Defaults to None.
        json_parser (JsonParser[T] | None): json --> T. Defaults to None.
    """

    def __init__(
        self,
        byte_transformers: list[BytesTransformer] | None = None,
        byte_json_adapter: BytesParser[JsonDict] | None = None,
        json_transformers: list[JsonTransformer] | None = None,
        json_parser: JsonParser[T] | None = None,
    ) -> None:
        self.byte_transformers = byte_transformers or []
        self.byte_json_adapter = byte_json_adapter
        self.json_transformers = json_transformers or []
        self.json_parser = json_parser

    def parse(self, data: bytes | bytearray | JsonDict) -> T:
        """Perform the parsing using the stored transformers and parsers

        Args:
            data (bytes | bytearray | JsonDict): input bytes or json to parse

        Raises:
            RuntimeError: attempted to parse bytes when a byte-json adapter does not exist

        Returns:
            T: final parsed output
        """
        parsed_json: JsonDict
        if isinstance(data, (bytes, bytearray)):
            data = bytes(data)
            if not self.byte_json_adapter:
                raise RuntimeError("Can not parse bytes without Json Adapter")
            # Filter bytes
            parsed_bytes = bytes(data)
            for byte_transformer in self.byte_transformers:
                parsed_bytes = byte_transformer.transform(data)
            parsed_json = self.byte_json_adapter.parse(parsed_bytes)
        else:
            parsed_json = data

        for json_transformer in self.json_transformers:
            parsed_json = json_transformer.transform(parsed_json)
        if self.json_parser:
            return self.json_parser.parse(parsed_json)
        return cast(T, parsed_json)


########################################################################################
####### Builders
########################################################################################


class BytesBuilder(Protocol):
    """Base bytes serializer protocol definition"""

    def build(self, obj: Any) -> bytes:
        """Build bytestream from object

        # noqa: DAR202

        Args:
            obj (Any): object to serialize

        Returns:
            bytes: serialized bytestream
        """


class BytesParserBuilder(BytesParser[T_co], BytesBuilder):
    """Class capable of both building / parsing bytes to / from object"""

    @abstractmethod
    def parse(self, data: bytes) -> T_co:
        """Parse input bytes to output

        Args:
            data (bytes): data to parsed

        Returns:
            T_co: parsed output
        """

    @abstractmethod
    def build(self, obj: Any) -> bytes:
        """Build bytestream from object

        # noqa: DAR202

        Args:
            obj (Any): object to serialize

        Returns:
            bytes: serialized bytestream
        """


class GlobalParsers:
    """Parsers that relate globally to ID's as opposed to contextualized per-message

    This is intended to be used as a singleton, i.e. not instantiated
    """

    _feature_action_id_map: ClassVar[dict[FeatureId, list[ActionId]]] = defaultdict(list)
    _global_parsers: ClassVar[dict[ResponseType, Parser]] = {}

    @classmethod
    def add_feature_action_id_mapping(cls, feature_id: FeatureId, action_id: ActionId) -> None:
        """Add a feature id-to-action id mapping entry

        Args:
            feature_id (FeatureId): Feature ID of protobuf command
            action_id (ActionId): Action ID of protobuf command
        """
        cls._feature_action_id_map[feature_id].append(action_id)

    @classmethod
    def add(cls, identifier: ResponseType, parser: Parser) -> None:
        """Add a global parser that can be accessed by this class's class methods

        Args:
            identifier (ResponseType): identifier to add parser for
            parser (Parser): parser to add
        """
        cls._global_parsers[identifier] = parser

    @classmethod
    def get_query_container(cls, identifier: ResponseType) -> Callable | None:
        """Attempt to get a callable that will translate an input value to the ID-appropriate value.

        For example, _get_query_container(SettingId.RESOLUTION) will return
        :py:class:`open_gopro.api.params.Resolution`

        As another example, _get_query_container(StatusId.TURBO_MODE) will return bool()

        Note! Not all ID's are currently parsed so None will be returned if the container does not exist

        Args:
            identifier (ResponseType): identifier to find container for

        Returns:
            Callable | None: container if found else None
        """
        try:
            parser_builder = cast(BytesParserBuilder, cls._global_parsers[identifier].byte_json_adapter)
            return lambda data, parse=parser_builder.parse, build=parser_builder.build: parse(build(data))
        except KeyError:
            return None

    @classmethod
    def get_parser(cls, identifier: ResponseType) -> Parser | None:
        """Get a globally defined parser for the given ID.

        Currently, only BLE uses globally defined parsers

        Args:
            identifier (ResponseType): ID to get parser for

        Returns:
            Parser | None: parser if found, else None
        """
        return cls._global_parsers.get(identifier)

================
File: demos/python/sdk_wireless_camera_control/open_gopro/types.py
================
# types.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Mon Jul 31 17:04:07 UTC 2023

"""Commonly reused type aliases"""

from __future__ import annotations

from typing import Any, Callable, Coroutine, Union

try:
    from typing import TypeAlias
except ImportError:
    from typing_extensions import TypeAlias

import construct
from google.protobuf.message import Message

from open_gopro.constants import (
    ActionId,
    BleUUID,
    CmdId,
    QueryCmdId,
    SettingId,
    StatusId,
)

# Note! We need to use Union here for Python 3.9 support

Protobuf: TypeAlias = Message

ProducerType: TypeAlias = tuple[QueryCmdId, Union[SettingId, StatusId]]
"""Types that can be registered for."""

CmdType: TypeAlias = Union[CmdId, QueryCmdId, ActionId]
"""Types that identify a command."""

ResponseType: TypeAlias = Union[CmdType, StatusId, SettingId, BleUUID, str, construct.Enum]
"""Types that are used to identify a response."""

CameraState: TypeAlias = dict[Union[SettingId, StatusId], Any]
"""Status / setting id-to-value mappings"""

JsonDict: TypeAlias = dict[str, Any]
"""Generic JSON dictionary"""

UpdateType: TypeAlias = Union[SettingId, StatusId, ActionId]
"""Identifier Type of an asynchronous update"""

UpdateCb: TypeAlias = Callable[[UpdateType, Any], Coroutine[Any, Any, None]]
"""Callback definition for update handlers"""

IdType: TypeAlias = Union[SettingId, StatusId, ActionId, CmdId, BleUUID, str]
"""Message Identifier Type"""

================
File: demos/python/sdk_wireless_camera_control/open_gopro/util.py
================
# util.py/Open GoPro, Version 2.0 (C) Copyright 2021 GoPro, Inc. (http://gopro.com/OpenGoPro).
# This copyright was auto-generated on Wed, Sep  1, 2021  5:05:50 PM

"""Miscellaneous utilities for the GoPro package."""

from __future__ import annotations

import argparse
import asyncio
import enum
import logging
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Any, Callable, Generic, TypeVar

import pytz
from pydantic import BaseModel
from tzlocal import get_localzone

util_logger = logging.getLogger(__name__)


class Singleton:
    """To be subclassed to create a singleton class."""

    _instances: dict[type[Singleton], Singleton] = {}

    def __new__(cls, *_: Any) -> Any:  # noqa https://github.com/PyCQA/pydocstyle/issues/515
        if cls not in cls._instances:
            cls._instances[cls] = object.__new__(cls)
        return cls._instances[cls]


def map_keys(obj: Any, key: str, func: Callable) -> None:
    """Map all matching keys (deeply searched) using the input function

    Args:
        obj (Any): object to modify in place
        key (str): key to search for to modify
        func (Callable): mapping function
    """
    if isinstance(obj, dict):
        for k in obj.keys():
            if k == key:
                obj[k] = func(obj[k])
            else:
                map_keys(obj[k], key, func)
    elif isinstance(obj, list):
        for i in obj:
            map_keys(i, key, func)
    else:
        # neither a dict nor a list, do nothing
        pass


def scrub(obj: Any, bad_keys: list | None = None, bad_values: list | None = None) -> None:
    """Recursively scrub a collection (dict / list) of bad keys and / or bad values

    Args:
        obj (Any): collection to scrub
        bad_keys (list | None, optional): Keys to remove. Defaults to None.
        bad_values (list | None, optional): Values to remove. Defaults to None.

    Raises:
        ValueError: Missing bad keys / values
    """
    bad_keys = bad_keys or []
    bad_values = bad_values or []
    if not (bad_values or bad_keys):
        raise ValueError("Must pass either / or bad_keys or bad_values")

    def recurse(obj: Any) -> None:
        if isinstance(obj, dict):
            for key, value in {**obj}.items():
                if key in bad_keys or value in bad_values:
                    del obj[key]
                else:
                    recurse(obj[key])
        elif isinstance(obj, list):
            for i, value in enumerate(list(obj)):
                if value in bad_values:
                    del obj[i]
                else:
                    recurse(obj[i])
        else:
            # neither a dict nor a list, do nothing
            pass

    recurse(obj)


def pretty_print(obj: Any, stringify_all: bool = True, should_quote: bool = True) -> str:
    """Recursively iterate through object and turn elements into strings

    Args:
        obj (Any): object to recurse through
        stringify_all (bool): At the end of each recursion, should the element be turned into a string?
            For example, should an int be turned into a str? Defaults to True.
        should_quote (bool): Should each element be surrounded in quotes?. Defaults to True.

    Returns:
        str: pretty-printed string
    """
    output = ""
    nest_level = 0

    def sanitize(e: Any) -> str:
        """Get the value part and replace any underscored with spaces

        Args:
            e (Any): argument to sanitize

        Returns:
            str: sanitized string
        """
        value_part = str(e).lower().split(".")[1]
        value_part = value_part.replace("_", " ").title()
        return value_part

    def stringify(elem: Any) -> Any:
        """Get the string value of an element if it is not a number (int, float, etc.)

        Args:
            elem (Any): element to potentially stringify

        Returns:
            Any: string representation or original object
        """

        def quote(elem: Any) -> Any:
            return f'"{elem}"' if should_quote else elem

        ret: str
        if isinstance(elem, (bytes, bytearray)):
            ret = quote(elem.hex(":"))
        if isinstance(elem, enum.Enum) and isinstance(elem, int):
            ret = quote(str(elem) if not stringify_all else sanitize(elem))
        if isinstance(elem, (bool, int, float)):
            ret = quote(elem) if stringify_all else elem
        ret = str(elem)
        return quote(ret)

    def recurse(elem: Any) -> None:
        """Recursion function

        Args:
            elem (Any): current element to work on
        """
        nonlocal output
        nonlocal nest_level
        indent_size = 4
        # Convert to dict if possible
        if isinstance(elem, BaseModel):
            elem = dict(elem)
            scrub(elem, bad_values=[None])
        if isinstance(elem, dict):
            # nested dictionary
            nest_level += 1
            output += "{"
            for k, v in elem.items():
                output += f"\n{' ' * (indent_size * nest_level)}"
                # Add key
                recurse(k)
                output += " : "
                # Add value
                if isinstance(v, (dict, list, BaseModel)):
                    recurse(v)
                else:
                    output += stringify(v)
                output += ","

            nest_level -= 1
            output += f"\n{' '* (indent_size * nest_level)}}}"

        elif isinstance(elem, list):
            # nested list
            nest_level += 1
            output += f"[\n{' '* (indent_size * nest_level)}"
            if len(elem):
                for item in elem[:-1]:
                    recurse(item)
                    output += ", "
                recurse(elem[-1])
            nest_level -= 1
            output += f"\n{' '* (indent_size * nest_level)}]"

        else:
            output += stringify(elem)

    recurse(obj)
    return output


def cmd(command: str) -> str:
    """Send a command to the shell and return the result.

    Args:
        command (str): command to send

    Returns:
        str: response returned from shell
    """
    # We don't want password showing in the log
    if "sudo" in command:
        logged_command = command[: command.find('"') + 1] + "********" + command[command.find(" | sudo") - 1 :]
    else:
        logged_command = command
    util_logger.debug(f"Send cmd --> {logged_command}")
    response = (
        subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)  # type: ignore
        .stdout.read()
        .decode(errors="ignore")
    )
    util_logger.debug(f"Receive response --> {response}")

    return response


T = TypeVar("T")


class SnapshotQueue(asyncio.Queue, Generic[T]):
    """A subclass of the default queue module to safely take a snapshot of the queue

    This is so we can access the elements (in a thread safe manner) without dequeuing them.
    """

    def __init__(self, maxsize: int = 0) -> None:
        self._lock = asyncio.Lock()
        super().__init__(maxsize)

    async def get(self) -> T:
        """Wrapper for passing generic type through to subclass

        Returns:
            T: type of this Snapshot queue
        """
        return await super().get()

    async def peek_front(self) -> T | None:
        """Get the first element without dequeueing it

        Returns:
            T | None: First element of None if the queue is empty
        """
        async with self._lock:
            return None if self.empty() else self._queue[0]  # type: ignore


def add_cli_args_and_parse(
    parser: argparse.ArgumentParser,
    bluetooth: bool = True,
    wifi: bool = True,
) -> argparse.Namespace:
    """Append common argparse arguments to an argument parser

    WARNING!! This will also parse the arguments (i.e. call parser.parse_args) so ensure to add any additional
    arguments to the parser before passing it to this function.

    Args:
        parser (argparse.ArgumentParser): input parser to modify
        bluetooth (bool): Add bluetooth args?. Defaults to True.
        wifi (bool): Add WiFi args?. Defaults to True.

    Returns:
        argparse.Namespace: modified argument parser
    """
    # Common args
    parser.add_argument("--log", type=Path, help="Location to store detailed log", default="gopro_demo.log")

    if bluetooth:
        parser.add_argument(
            "--identifier",
            type=str,
            help="Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. \
                If not used, first discovered GoPro will be connected to",
            default=None,
        )

    if wifi:
        parser.add_argument(
            "--wifi_interface",
            type=str,
            help="System Wifi Interface. If not set, first discovered interface will be used.",
            default=None,
        )
        parser.add_argument(
            "--password",
            action="store_true",
            help="Set to read sudo password from stdin. If not set, you will be prompted for password if needed",
        )

    args = parser.parse_args()
    if wifi:
        args.password = sys.stdin.readline() if args.password else None

    return args


async def ainput(string: str, printer: Callable = sys.stdout.write) -> str:
    """Async version of input

    Args:
        string (str): prompt string
        printer (Callable): Callable to display prompt. Defaults to sys.stdout.write.

    Returns:
        str: Input read from console
    """
    await asyncio.get_event_loop().run_in_executor(None, lambda s=string: printer(s + " "))  # type: ignore
    return await asyncio.get_event_loop().run_in_executor(None, sys.stdin.readline)


def get_current_dst_aware_time() -> tuple[datetime, int, bool]:
    """Get the current time, utc offset in minutes, and daylight savings time

    Returns:
        tuple[datetime, int, bool]: [time, utc_offset in minutes, is_dst?]
    """
    tz = pytz.timezone(get_localzone().key)  # type: ignore
    now = tz.localize(datetime.now(), is_dst=None)
    try:
        is_dst = now.tzinfo._dst.seconds != 0  # type: ignore
        offset = (now.utcoffset().total_seconds() - now.tzinfo._dst.seconds) / 60  # type: ignore
    except AttributeError:
        is_dst = False
        offset = now.utcoffset().total_seconds() / 60  # type: ignore
    if is_dst:
        offset += 60
    return (now, int(offset), is_dst)
